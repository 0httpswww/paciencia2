<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Jogos Online</title>
    <meta name="description" content="Jogos Online - Arcade Space Shooter e muito mais.">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png">
    
    <!-- Monetag Popunder Script -->
    <script src="https://quge5.com/88/tag.min.js" data-zone="187944" async data-cfasync="false"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { 
            overscroll-behavior: none; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent; 
            font-family: 'Courier New', Courier, monospace;
            background-color: #050505;
            color: white; 
            user-select: none; 
            -webkit-user-select: none; 
            overflow: hidden;
        }

        /* Neon Text Effect */
        .neon-text {
            color: #fff;
            text-shadow: 
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px #ff00de,
                0 0 30px #ff00de,
                0 0 40px #ff00de,
                0 0 55px #ff00de,
                0 0 75px #ff00de;
        }
        
        .neon-box {
            box-shadow:
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px #0ff,
                0 0 30px #0ff,
                inset 0 0 10px #0ff; 
        }

        /* Starfield Animation for Menu BG (optional, game has its own) */
        .stars-bg {
            background: #000;
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
        "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
      }
    }
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js').then(function(registration) {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, function(err) {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</head>
<body>
    <div id="root" class="h-[100dvh] w-full overflow-hidden flex flex-col"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useRef, useCallback } from 'react';
      import { createRoot } from 'react-dom/client';
      import { Expand, Shrink, Heart, Shield, Zap, RefreshCw, Rocket, ChevronLeft } from 'lucide-react';

      // --- Galaxy Invader Game Component ---
      const GalaxyInvader = ({ onBack, triggerAd }) => {
          const canvasRef = useRef(null);
          const game = useRef({
              player: { x: 0, y: 0, w: 40, h: 40, health: 3, maxHealth: 3, weapon: 'single', shield: 0, lastShot: 0 },
              bullets: [],
              enemies: [],
              boss: null,
              particles: [],
              stars: [], // Starfield
              score: 0,
              level: 1,
              gameState: 'menu', // playing, boss, level-up, game-over
              width: 0,
              height: 0,
          });
          const [isFullscreen, setIsFullscreen] = useState(false);
          const [gameOver, setGameOver] = useState(false);

          const initGame = useCallback(() => {
              const canvas = canvasRef.current;
              const g = game.current;
              g.width = canvas.width;
              g.height = canvas.height;
              g.player.x = g.width / 2 - g.player.w / 2;
              g.player.y = g.height - 100;
              g.player.health = 3;
              g.player.weapon = 'single';
              g.score = 0;
              g.level = 1;
              g.bullets = [];
              g.enemies = [];
              g.boss = null;
              g.particles = [];
              g.gameState = 'playing';
              setGameOver(false);
              
              // Initialize Stars
              g.stars = [];
              for(let i=0; i<100; i++) {
                  g.stars.push({
                      x: Math.random() * g.width,
                      y: Math.random() * g.height,
                      size: Math.random() * 2,
                      speed: Math.random() * 3 + 0.5
                  });
              }
          }, []);

          const spawnEnemy = useCallback(() => {
              const g = game.current;
              if (g.gameState !== 'playing') return;

              if (Math.random() < 0.02 + g.level * 0.005) {
                  const type = Math.random() < 0.2 ? 'shooter' : 'basic';
                  const health = type === 'shooter' ? 2 : 1;
                  g.enemies.push({ 
                      x: Math.random() * (g.width - 30), 
                      y: -30, w: 30, h: 30, 
                      type, health,
                      lastShot: Date.now() 
                  });
              }
          }, []);

          const spawnBoss = useCallback(() => {
              const g = game.current;
              g.gameState = 'boss';
              g.enemies = [];
              g.boss = {
                  x: g.width / 2 - 75, y: -150, w: 150, h: 100,
                  health: 50 + g.level * 25, maxHealth: 50 + g.level * 25,
                  phase: 1, lastShot: Date.now(), moveDir: 1,
                  lastPatternChange: Date.now()
              };
          }, []);

          const update = useCallback(() => {
              const g = game.current;
              const now = Date.now();

              // Update Stars (Always move)
              g.stars.forEach(s => {
                  s.y += s.speed;
                  if (s.y > g.height) {
                      s.y = 0;
                      s.x = Math.random() * g.width;
                  }
              });

              if (g.gameState === 'playing' || g.gameState === 'boss') {
                  // Update player bullets
                  g.bullets = g.bullets.filter(b => b.y > -10 && !b.hit);
                  g.bullets.forEach(b => {
                      if(b.owner === 'player') b.y -= 8;
                      else {
                          b.x += b.vx;
                          b.y += b.vy;
                      }
                  });

                  // Update enemies
                  g.enemies.forEach(e => {
                      e.y += 1.5;
                      if (e.type === 'shooter' && now - e.lastShot > 2000) {
                          g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 5, h: 10, owner: 'enemy', vx: 0, vy: 4, color: '#f43f5e'});
                          e.lastShot = now;
                      }
                  });
                  g.enemies = g.enemies.filter(e => e.y < g.height);
                  
                  // Update Boss
                  if (g.boss) {
                      const boss = g.boss;
                      boss.y = Math.min(boss.y + 1, 80);
                      boss.x += boss.moveDir * 2;
                      if (boss.x <= 0 || boss.x + boss.w >= g.width) boss.moveDir *= -1;

                      if(now - boss.lastShot > (boss.health < boss.maxHealth / 2 ? 800 : 1500)) {
                          for(let i = 0; i < (boss.phase === 1 ? 5 : 8); i++) {
                              const angle = (i / (boss.phase === 1 ? 5 : 8)) * Math.PI * 2;
                              g.bullets.push({x: boss.x + boss.w/2, y: boss.y + boss.h, w: 8, h: 8, owner: 'enemy', vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, color: '#e11d48' });
                          }
                          boss.lastShot = now;
                      }
                  }

                  // Collisions
                  g.bullets.forEach(b => {
                      if (b.owner === 'player') {
                          g.enemies.forEach(e => {
                              if (!b.hit && b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
                                  b.hit = true;
                                  e.health--;
                                  if(e.health <= 0) g.score += 100;
                                  createExplosion(e.x + e.w/2, e.y + e.h/2, '#fb923c');
                              }
                          });
                           if (g.boss && !b.hit && b.x < g.boss.x + g.boss.w && b.x + b.w > g.boss.x && b.y < g.boss.y + g.boss.h && b.y + b.h > g.boss.y) {
                               b.hit = true;
                               g.boss.health--;
                               g.score += 50;
                               createExplosion(b.x, b.y, '#fca5a5');
                               if(g.boss.health <= 0) {
                                   g.score += 5000 * g.level;
                                   g.gameState = 'level-up';
                                   g.boss = null;
                                   createExplosion(g.width / 2, 130, '#ffffff', 100);
                                   setTimeout(() => { g.level++; g.gameState = 'playing'; }, 3000);
                               }
                           }

                      } else { // Enemy bullet
                          const p = g.player;
                          if (b.x < p.x + p.w && b.x + b.w > p.x && b.y < p.y + p.h && b.y + b.h > p.y) {
                              b.hit = true;
                              p.health--;
                              createExplosion(p.x + p.w / 2, p.y + p.h / 2, '#60a5fa');
                              if (p.health <= 0) {
                                  g.gameState = 'game-over';
                                  setGameOver(true);
                              }
                          }
                      }
                  });
                  
                  g.enemies = g.enemies.filter(e => e.health > 0);
                  
                  // Level progression
                  if (g.score > g.level * 2000 && g.gameState === 'playing') {
                      spawnBoss();
                  }
              }
              
              // Update particles
              g.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
              g.particles = g.particles.filter(p => p.life > 0);

              // Spawns
              spawnEnemy();

          }, [spawnEnemy, spawnBoss, initGame]);

          const createExplosion = (x, y, color, count = 20) => {
              for (let i = 0; i < count; i++) {
                  game.current.particles.push({
                      x, y,
                      vx: (Math.random() - 0.5) * 4,
                      vy: (Math.random() - 0.5) * 4,
                      life: Math.random() * 30 + 10,
                      color
                  });
              }
          };

          const draw = useCallback(() => {
              const canvas = canvasRef.current;
              if (!canvas) return;
              const ctx = canvas.getContext('2d');
              const g = game.current;
              
              // Clear with very dark semi-transparent black for trail effect or just solid
              ctx.fillStyle = '#050505';
              ctx.fillRect(0, 0, g.width, g.height);
              
              // Draw Stars
              ctx.fillStyle = '#ffffff';
              g.stars.forEach(s => {
                  ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                  ctx.beginPath();
                  ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.globalAlpha = 1.0;
              });

              // Draw player
              if (g.gameState !== 'game-over') {
                  const p = g.player;
                  ctx.fillStyle = '#00ffff'; // Neon Cyan
                  ctx.shadowBlur = 15;
                  ctx.shadowColor = '#00ffff';
                  ctx.beginPath();
                  ctx.moveTo(p.x, p.y + p.h);
                  ctx.lineTo(p.x + p.w / 2, p.y);
                  ctx.lineTo(p.x + p.w, p.y + p.h);
                  ctx.closePath();
                  ctx.fill();
                  ctx.shadowBlur = 0;
              }

              // Draw bullets
              g.bullets.forEach(b => {
                  ctx.fillStyle = b.color || '#fff000'; // Neon Yellow
                  ctx.shadowBlur = 5;
                  ctx.shadowColor = b.color || '#fff000';
                  ctx.fillRect(b.x, b.y, b.w, b.h);
                  ctx.shadowBlur = 0;
              });
              
              // Draw enemies
              g.enemies.forEach(e => {
                  ctx.fillStyle = e.type === 'shooter' ? '#ff0055' : '#00ff55';
                  ctx.shadowBlur = 10;
                  ctx.shadowColor = ctx.fillStyle;
                  ctx.fillRect(e.x, e.y, e.w, e.h);
                  ctx.shadowBlur = 0;
              });

              // Draw boss
              if (g.boss) {
                  const boss = g.boss;
                  ctx.fillStyle = '#ff00ff';
                  ctx.shadowBlur = 20;
                  ctx.shadowColor = '#ff00ff';
                  ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
                  ctx.shadowBlur = 0;
                  // Boss health bar
                  ctx.fillStyle = '#330033';
                  ctx.fillRect(boss.x, boss.y - 15, boss.w, 10);
                  ctx.fillStyle = '#ff00ff';
                  ctx.fillRect(boss.x, boss.y - 15, boss.w * (boss.health / boss.maxHealth), 10);
              }
              
              // Draw particles
              g.particles.forEach(p => {
                  ctx.fillStyle = p.color;
                  ctx.globalAlpha = p.life / 30;
                  ctx.fillRect(p.x, p.y, 3, 3);
                  ctx.globalAlpha = 1;
              });

              // Draw UI
              ctx.fillStyle = 'white';
              ctx.font = 'bold 18px "Courier New"';
              ctx.textAlign = 'left';
              ctx.fillText(`SCORE: ${g.score}`, 10, 30);
              ctx.textAlign = 'right';
              ctx.fillText(`LVL: ${g.level}`, g.width - 10, 30);
              
              // Health Hearts
              ctx.textAlign = 'left';
              let healthStr = '';
              for(let i=0; i<g.player.health; i++) healthStr += 'â™¥ ';
              ctx.fillStyle = '#ff0055';
              ctx.fillText(healthStr, 10, g.height - 20);

              if (g.gameState === 'game-over') {
                  ctx.fillStyle = 'rgba(0,0,0,0.85)';
                  ctx.fillRect(0,0,g.width,g.height);
                  ctx.fillStyle = '#ff0055';
                  ctx.font = 'bold 40px "Courier New"';
                  ctx.textAlign = 'center';
                  ctx.shadowBlur = 10;
                  ctx.shadowColor = '#ff0055';
                  ctx.fillText('GAME OVER', g.width/2, g.height/2 - 20);
                  ctx.shadowBlur = 0;
                  
                  ctx.fillStyle = 'white';
                  ctx.font = '20px "Courier New"';
                  ctx.fillText('Tap to Restart', g.width/2, g.height/2 + 30);
              }
              if (g.gameState === 'level-up') {
                  ctx.fillStyle = '#00ff55';
                  ctx.font = 'bold 30px "Courier New"';
                  ctx.textAlign = 'center';
                  ctx.shadowBlur = 15;
                  ctx.shadowColor = '#00ff55';
                  ctx.fillText('LEVEL COMPLETE', g.width/2, g.height/2);
                  ctx.shadowBlur = 0;
              }

          }, []);

          useEffect(() => {
              // Trigger Start immediately when component mounts
              initGame();

              const canvas = canvasRef.current;
              const g = game.current;
              
              const resizeCanvas = () => {
                if(canvas && canvas.parentElement) {
                    const { width, height } = canvas.parentElement.getBoundingClientRect();
                    canvas.width = width;
                    canvas.height = height;
                    g.width = width;
                    g.height = height;
                    // Keep player onscreen on resize
                    g.player.x = Math.min(g.player.x, width - g.player.w);
                    g.player.y = Math.min(g.player.y, height - g.player.h);
                    
                    // Re-init stars if empty (first run) or just let them be
                    if(g.stars.length === 0) {
                         for(let i=0; i<100; i++) {
                            g.stars.push({
                                x: Math.random() * g.width,
                                y: Math.random() * g.height,
                                size: Math.random() * 2,
                                speed: Math.random() * 3 + 0.5
                            });
                        }
                    }
                }
              };
              
              resizeCanvas();
              window.addEventListener('resize', resizeCanvas);

              let animationFrameId;
              const gameLoop = () => {
                  update();
                  draw();
                  animationFrameId = window.requestAnimationFrame(gameLoop);
              };
              gameLoop();

              const handleMove = (e) => {
                  if (g.gameState !== 'playing' && g.gameState !== 'boss') return;
                  
                  if(e.cancelable) e.preventDefault();

                  const rect = canvas.getBoundingClientRect();
                  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                  const x = clientX - rect.left;
                  const y = clientY - rect.top;
                  
                  g.player.x = Math.max(0, Math.min(g.width - g.player.w, x - g.player.w / 2));
                  g.player.y = Math.max(0, Math.min(g.height - g.player.h, y - g.player.h / 2));
                  
                  const now = Date.now();
                  if (now - g.player.lastShot > 200) {
                      g.bullets.push({x: g.player.x + g.player.w/2 - 2, y: g.player.y, w: 4, h: 15, owner: 'player'});
                      g.player.lastShot = now;
                  }
              };

              const handleClick = () => {
                  if (g.gameState === 'game-over') {
                      triggerAd();
                      initGame();
                  }
              }

              canvas.addEventListener('mousemove', handleMove);
              canvas.addEventListener('touchmove', handleMove, { passive: false });
              canvas.addEventListener('click', handleClick);

              return () => {
                  window.cancelAnimationFrame(animationFrameId);
                  window.removeEventListener('resize', resizeCanvas);
                  canvas.removeEventListener('mousemove', handleMove);
                  canvas.removeEventListener('touchmove', handleMove);
                  canvas.removeEventListener('click', handleClick);
              };
          }, [draw, update, initGame, triggerAd]);
          
          const toggleFullScreen = () => {
              if (!document.fullscreenElement) {
                  document.documentElement.requestFullscreen();
                  setIsFullscreen(true);
              } else {
                  if (document.exitFullscreen) {
                      document.exitFullscreen();
                      setIsFullscreen(false);
                  }
              }
          };

          return (
              <div className="w-full h-full relative flex flex-col items-center justify-center bg-black">
                  <canvas ref={canvasRef} className="w-full h-full block" />
                  
                  {/* Controls Overlay */}
                  <div className="absolute top-4 left-4 z-10">
                      <button onClick={onBack} className="p-3 bg-white/10 backdrop-blur-md rounded-full text-white hover:bg-white/20 transition">
                          <ChevronLeft size={24} />
                      </button>
                  </div>

                  <div className="absolute top-4 right-4 z-10 flex flex-col gap-2">
                      <button onClick={toggleFullScreen} className="p-3 bg-white/10 backdrop-blur-md rounded-full text-white hover:bg-white/20 transition">
                          {isFullscreen ? <Shrink size={20} /> : <Expand size={20} />}
                      </button>
                      {gameOver && (
                          <button onClick={() => { triggerAd(); initGame(); }} className="p-3 bg-red-500/80 backdrop-blur rounded-full text-white animate-pulse">
                              <RefreshCw size={20} />
                          </button>
                      )}
                  </div>
              </div>
          );
      };

      // --- Main App Component ---
      const App = () => {
          const [currentScreen, setCurrentScreen] = useState('home'); // home, galaxy-invader

          const triggerAd = useCallback(() => {
             console.log("Triggering Ad (Handled by Monetag script on click events)");
          }, []);

          const startGame = (gameName) => {
              triggerAd();
              setCurrentScreen(gameName);
          };

          const renderScreen = () => {
              switch(currentScreen) {
                  case 'galaxy-invader':
                      return <GalaxyInvader onBack={() => setCurrentScreen('home')} triggerAd={triggerAd} />;
                  default:
                      return (
                          <div className="w-full h-full flex flex-col items-center justify-center bg-black relative overflow-hidden">
                              {/* Background Decor */}
                              <div className="absolute inset-0 z-0">
                                  <div className="absolute top-[-20%] left-[-20%] w-[140%] h-[140%] bg-[radial-gradient(circle_at_center,_#220022_0%,_#000000_70%)] opacity-50"></div>
                              </div>

                              <div className="z-10 flex flex-col items-center gap-8 w-full max-w-md px-4">
                                  <h1 className="text-5xl md:text-6xl font-bold text-center neon-text tracking-wider">
                                      JoGos<br/>Onilne
                                  </h1>
                                  
                                  <div className="w-full grid gap-4 mt-8">
                                      <button 
                                          onClick={() => startGame('galaxy-invader')}
                                          className="group relative w-full h-32 bg-gray-900 border border-purple-500 rounded-xl overflow-hidden hover:scale-105 transition-all duration-300 neon-box"
                                      >
                                          <div className="absolute inset-0 bg-gradient-to-r from-purple-900/40 to-blue-900/40 group-hover:opacity-100 transition-opacity"></div>
                                          <div className="relative z-10 flex items-center justify-between p-6 h-full">
                                              <div className="flex flex-col items-start">
                                                  <span className="text-2xl font-bold text-cyan-400 drop-shadow-[0_0_5px_rgba(0,255,255,0.8)]">GALAXY INVADER</span>
                                                  <span className="text-xs text-gray-400 mt-1">Space Shooter Arcade</span>
                                              </div>
                                              <Rocket size={40} className="text-purple-400 drop-shadow-[0_0_10px_rgba(168,85,247,0.8)]" />
                                          </div>
                                      </button>

                                      <button 
                                          className="w-full h-24 bg-gray-900/50 border border-gray-800 rounded-xl flex items-center justify-center text-gray-600 cursor-not-allowed"
                                      >
                                          <span className="text-sm">Em Breve...</span>
                                      </button>
                                  </div>
                              </div>
                              
                              <div className="absolute bottom-4 text-gray-800 text-xs">
                                  v2.5.0
                              </div>
                          </div>
                      );
              }
          };

          return renderScreen();
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>