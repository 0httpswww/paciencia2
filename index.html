<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>JoGos Online</title>
    <meta name="description" content="JoGos Online - Arcade Space Shooter e muito mais.">
    <meta name="theme-color" content="#111111">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png">
    
    <!-- Monetag Popunder Script -->
    <script src="https://quge5.com/88/tag.min.js" data-zone="187944" async data-cfasync="false"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { 
            overscroll-behavior: none; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent; 
            font-family: 'Courier New', Courier, monospace;
            background-color: #111;
            /* Grid Background */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            color: white; 
            user-select: none; 
            -webkit-user-select: none; 
            overflow: hidden;
        }

        /* Neon Text Effect */
        .neon-text {
            color: #fff;
            text-shadow: 
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px #ff00de,
                0 0 30px #ff00de,
                0 0 40px #ff00de,
                0 0 55px #ff00de,
                0 0 75px #ff00de;
        }
        
        /* Glassmorphism for Home UI */
        .glass-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
        "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
      }
    }
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js').then(function(registration) {
                    console.log('ServiceWorker registration successful');
                }, function(err) {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</head>
<body>
    <div id="root" class="h-[100dvh] w-full overflow-hidden flex flex-col"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useRef, useCallback } from 'react';
      import { createRoot } from 'react-dom/client';
      import { Expand, Shrink, RefreshCw, Rocket, ChevronLeft, Shield, Zap } from 'lucide-react';

      // --- Sound System (Synthesized) ---
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      
      const playSound = (type) => {
          if (audioCtx.state === 'suspended') audioCtx.resume();
          const osc = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          osc.connect(gainNode);
          gainNode.connect(audioCtx.destination);

          const now = audioCtx.currentTime;

          switch(type) {
              case 'shoot':
                  osc.type = 'square';
                  osc.frequency.setValueAtTime(880, now);
                  osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'enemy_shoot':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(400, now);
                  osc.frequency.linearRampToValueAtTime(200, now + 0.1);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'explosion':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(100, now);
                  osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
                  gainNode.gain.setValueAtTime(0.2, now);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                  osc.start(now);
                  osc.stop(now + 0.5);
                  break;
              case 'hit':
                  osc.type = 'square';
                  osc.frequency.setValueAtTime(150, now);
                  osc.frequency.linearRampToValueAtTime(100, now + 0.1);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'powerup':
                  osc.type = 'sine';
                  osc.frequency.setValueAtTime(600, now);
                  osc.frequency.linearRampToValueAtTime(1200, now + 0.3);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
                  osc.start(now);
                  osc.stop(now + 0.3);
                  break;
          }
      };

      // --- Galaxy Invader Game Component ---
      const GalaxyInvader = ({ onBack, triggerAd }) => {
          const canvasRef = useRef(null);
          const game = useRef({
              player: { 
                  x: 0, y: 0, w: 40, h: 40, 
                  health: 100, maxHealth: 100, 
                  weaponLevel: 1, // 1 to 5
                  shieldActive: false,
                  shieldTimer: 0,
                  damageMultiplier: 1,
                  lastShot: 0 
              },
              bullets: [],
              enemies: [],
              powerups: [],
              boss: null,
              particles: [],
              stars: [],
              score: 0,
              level: 1,
              gameState: 'menu',
              width: 0,
              height: 0,
          });
          const [isFullscreen, setIsFullscreen] = useState(false);
          const [gameOver, setGameOver] = useState(false);

          const initGame = useCallback(() => {
              const canvas = canvasRef.current;
              const g = game.current;
              g.width = canvas.width;
              g.height = canvas.height;
              g.player.x = g.width / 2 - g.player.w / 2;
              g.player.y = g.height - 100;
              g.player.health = 100;
              g.player.weaponLevel = 1;
              g.player.shieldActive = false;
              g.player.shieldTimer = 0;
              g.player.damageMultiplier = 1;
              g.score = 0;
              g.level = 1;
              g.bullets = [];
              g.enemies = [];
              g.powerups = [];
              g.boss = null;
              g.particles = [];
              g.gameState = 'playing';
              setGameOver(false);
              
              g.stars = [];
              for(let i=0; i<80; i++) {
                  g.stars.push({
                      x: Math.random() * g.width,
                      y: Math.random() * g.height,
                      size: Math.random() * 2,
                      speed: Math.random() * 3 + 0.5
                  });
              }
          }, []);

          const spawnPowerup = (x, y) => {
              if (Math.random() < 0.2) { // 20% chance
                  const type = Math.random() < 0.5 ? 'weapon' : 'shield';
                  game.current.powerups.push({
                      x, y, w: 20, h: 20, type,
                      vy: 2
                  });
              }
          };

          const spawnEnemy = useCallback(() => {
              const g = game.current;
              if (g.gameState !== 'playing') return;

              // Spawn rate increases with level
              if (Math.random() < 0.02 + g.level * 0.002) {
                  const rand = Math.random();
                  let type = 'basic';
                  let health = 1 + Math.floor(g.level * 0.5);
                  let w = 30, h = 30;
                  
                  if (rand > 0.9 && g.level > 2) { type = 'tank'; health *= 3; w=40; h=40; }
                  else if (rand > 0.7 && g.level > 1) { type = 'speeder'; health = Math.max(1, health/2); }
                  else if (rand > 0.5) { type = 'shooter'; health *= 1.5; }

                  g.enemies.push({ 
                      x: Math.random() * (g.width - w), 
                      y: -40, w, h, 
                      type, health, maxHealth: health,
                      vx: type === 'speeder' ? (Math.random() - 0.5) * 4 : 0,
                      vy: type === 'speeder' ? 4 : (type === 'tank' ? 1 : 2),
                      lastShot: Date.now() + Math.random() * 1000,
                      angle: 0
                  });
              }
          }, []);

          const spawnBoss = useCallback(() => {
              const g = game.current;
              g.gameState = 'boss';
              g.enemies = []; // Clear small enemies
              g.boss = {
                  x: g.width / 2 - 60, y: -120, w: 120, h: 100,
                  health: 200 * g.level, maxHealth: 200 * g.level,
                  phase: 1, lastShot: Date.now(), moveDir: 1,
                  attackType: 0, attackTimer: 0
              };
          }, []);

          const update = useCallback(() => {
              const g = game.current;
              const now = Date.now();

              // Update Stars
              g.stars.forEach(s => {
                  s.y += s.speed;
                  if (s.y > g.height) {
                      s.y = 0;
                      s.x = Math.random() * g.width;
                  }
              });

              // Shield Timer
              if (g.player.shieldActive) {
                  g.player.shieldTimer -= 16; // approx 16ms per frame
                  if (g.player.shieldTimer <= 0) {
                      g.player.shieldActive = false;
                      g.player.damageMultiplier = 1;
                  }
              }

              if (g.gameState === 'playing' || g.gameState === 'boss') {
                  // Player Bullets
                  g.bullets.forEach(b => {
                      if(b.owner === 'player') b.y -= 10;
                      else {
                          b.x += b.vx;
                          b.y += b.vy;
                      }
                  });
                  g.bullets = g.bullets.filter(b => b.y > -50 && b.y < g.height + 50 && b.x > -50 && b.x < g.width + 50 && !b.hit);

                  // Enemies
                  g.enemies.forEach(e => {
                      e.x += e.vx;
                      e.y += e.vy;
                      if(e.x <= 0 || e.x + e.w >= g.width) e.vx *= -1;

                      // Enemy Shooting
                      if ((e.type === 'shooter' || e.type === 'tank') && now - e.lastShot > 1500) {
                          playSound('enemy_shoot');
                          if (e.type === 'tank') {
                               // Tank shoots spread
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 8, h: 8, owner: 'enemy', vx: -2, vy: 3, color: '#f87171'});
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 8, h: 8, owner: 'enemy', vx: 0, vy: 3, color: '#f87171'});
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 8, h: 8, owner: 'enemy', vx: 2, vy: 3, color: '#f87171'});
                          } else {
                               // Shooter aims at player
                               const dx = (g.player.x + g.player.w/2) - (e.x + e.w/2);
                               const dy = (g.player.y + g.player.h/2) - (e.y + e.h/2);
                               const angle = Math.atan2(dy, dx);
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 6, h: 6, owner: 'enemy', vx: Math.cos(angle)*4, vy: Math.sin(angle)*4, color: '#fbbf24'});
                          }
                          e.lastShot = now;
                      }
                  });
                  g.enemies = g.enemies.filter(e => e.y < g.height);

                  // Powerups
                  g.powerups.forEach(p => p.y += p.vy);
                  g.powerups = g.powerups.filter(p => p.y < g.height && !p.collected);

                  // Boss Logic
                  if (g.boss) {
                      const boss = g.boss;
                      if (boss.y < 50) boss.y += 1;
                      boss.x += boss.moveDir * (1 + g.level * 0.2);
                      if (boss.x <= 0 || boss.x + boss.w >= g.width) boss.moveDir *= -1;

                      if (now - boss.lastShot > 800) {
                          playSound('enemy_shoot');
                          boss.attackType = (boss.attackType + 1) % 3;
                          
                          // Pattern 1: Circle
                          if (boss.attackType === 0) {
                              for(let i=0; i<12; i++) {
                                  const angle = (i / 12) * Math.PI * 2;
                                  g.bullets.push({x: boss.x + boss.w/2, y: boss.y + boss.h/2, w: 8, h: 8, owner: 'enemy', vx: Math.cos(angle)*4, vy: Math.sin(angle)*4, color: '#ef4444'});
                              }
                          } 
                          // Pattern 2: Machine Gun
                          else if (boss.attackType === 1) {
                              for(let i=0; i<5; i++) {
                                  setTimeout(() => {
                                      g.bullets.push({x: boss.x + Math.random()*boss.w, y: boss.y + boss.h, w: 6, h: 12, owner: 'enemy', vx: 0, vy: 6, color: '#ef4444'});
                                  }, i * 100);
                              }
                          }
                          // Pattern 3: Aimed
                          else {
                              const dx = (g.player.x + g.player.w/2) - (boss.x + boss.w/2);
                              const dy = (g.player.y + g.player.h/2) - (boss.y + boss.h/2);
                              const angle = Math.atan2(dy, dx);
                              g.bullets.push({x: boss.x + boss.w/2, y: boss.y + boss.h, w: 15, h: 15, owner: 'enemy', vx: Math.cos(angle)*6, vy: Math.sin(angle)*6, color: '#b91c1c'});
                          }
                          boss.lastShot = now;
                      }
                  }

                  // Collisions
                  // 1. Player Bullets hitting Enemies/Boss
                  g.bullets.forEach(b => {
                      if (b.owner === 'player') {
                          // Check Enemies
                          g.enemies.forEach(e => {
                              if (!b.hit && rectIntersect(b, e)) {
                                  b.hit = true;
                                  const dmg = 1 * g.player.damageMultiplier;
                                  e.health -= dmg;
                                  createExplosion(b.x, b.y, '#fb923c', 5);
                                  if(e.health <= 0) {
                                      g.score += (e.type === 'tank' ? 300 : 100);
                                      createExplosion(e.x + e.w/2, e.y + e.h/2, '#fdba74', 15);
                                      playSound('explosion');
                                      spawnPowerup(e.x, e.y);
                                  }
                              }
                          });
                          // Check Boss
                          if (g.boss && !b.hit && rectIntersect(b, g.boss)) {
                              b.hit = true;
                              const dmg = 1 * g.player.damageMultiplier;
                              g.boss.health -= dmg;
                              g.score += 10;
                              createExplosion(b.x, b.y, '#f87171', 5);
                              if (g.boss.health <= 0) {
                                  playSound('explosion');
                                  g.score += 5000 * g.level;
                                  g.gameState = 'level-up';
                                  createExplosion(g.boss.x + g.boss.w/2, g.boss.y + g.boss.h/2, '#ffffff', 50);
                                  g.boss = null;
                                  setTimeout(() => { g.level++; g.gameState = 'playing'; }, 3000);
                              }
                          }
                      } 
                      // 2. Enemy Bullets hitting Player
                      else { 
                          if (!b.hit && rectIntersect(b, g.player)) {
                              b.hit = true;
                              if (!g.player.shieldActive) {
                                  g.player.health -= 10;
                                  playSound('hit');
                                  createExplosion(g.player.x + g.player.w/2, g.player.y + g.player.h/2, '#ef4444', 10);
                                  if (g.player.health <= 0) {
                                      g.gameState = 'game-over';
                                      playSound('explosion');
                                      setGameOver(true);
                                  }
                              } else {
                                  createExplosion(b.x, b.y, '#06b6d4', 5); // Shield deflect
                              }
                          }
                      }
                  });

                  // 3. Powerup collection
                  g.powerups.forEach(p => {
                      if (!p.collected && rectIntersect(p, g.player)) {
                          p.collected = true;
                          playSound('powerup');
                          if (p.type === 'weapon') {
                              g.player.weaponLevel = Math.min(5, g.player.weaponLevel + 1);
                              createExplosion(g.player.x, g.player.y, '#00ff00', 20);
                          } else if (p.type === 'shield') {
                              g.player.shieldActive = true;
                              g.player.shieldTimer = 10000; // 10 seconds
                              g.player.damageMultiplier = 5;
                              createExplosion(g.player.x, g.player.y, '#06b6d4', 20);
                          }
                      }
                  });

                  g.enemies = g.enemies.filter(e => e.health > 0);
                  
                  if (g.score > g.level * 2500 && !g.boss && g.gameState === 'playing') {
                      spawnBoss();
                  }
              }

              // Update Particles
              g.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
              g.particles = g.particles.filter(p => p.life > 0);

              spawnEnemy();
          }, [spawnEnemy, spawnBoss, initGame]);

          const rectIntersect = (r1, r2) => {
              return !(r2.x > r1.x + r1.w || 
                       r2.x + r2.w < r1.x || 
                       r2.y > r1.y + r1.h || 
                       r2.y + r2.h < r1.y);
          };

          const createExplosion = (x, y, color, count = 20) => {
              for (let i = 0; i < count; i++) {
                  game.current.particles.push({
                      x, y,
                      vx: (Math.random() - 0.5) * 6,
                      vy: (Math.random() - 0.5) * 6,
                      life: Math.random() * 20 + 10,
                      color
                  });
              }
          };

          const firePlayerWeapon = (g) => {
              playSound('shoot');
              const { x, y, w, h, weaponLevel } = g.player;
              const cx = x + w / 2;
              
              const bulletProps = { w: 4, h: 12, owner: 'player', color: '#67e8f9' }; // Cyan neon

              if (weaponLevel === 1) {
                  g.bullets.push({ ...bulletProps, x: cx - 2, y });
              } else if (weaponLevel === 2) {
                  g.bullets.push({ ...bulletProps, x: cx - 10, y });
                  g.bullets.push({ ...bulletProps, x: cx + 6, y });
              } else if (weaponLevel === 3) {
                  g.bullets.push({ ...bulletProps, x: cx - 2, y });
                  g.bullets.push({ ...bulletProps, x: cx - 12, y: y + 5, vx: -1, vy: -10 });
                  g.bullets.push({ ...bulletProps, x: cx + 8, y: y + 5, vx: 1, vy: -10 });
              } else if (weaponLevel === 4) {
                  // V-shape wide
                  g.bullets.push({ ...bulletProps, x: cx - 15, y, vx: -2, vy: -10 });
                  g.bullets.push({ ...bulletProps, x: cx - 5, y, vx: 0, vy: -10 });
                  g.bullets.push({ ...bulletProps, x: cx + 5, y, vx: 0, vy: -10 });
                  g.bullets.push({ ...bulletProps, x: cx + 15, y, vx: 2, vy: -10 });
              } else {
                  // Omni burst (Level 5)
                  for(let i=-2; i<=2; i++) {
                      g.bullets.push({ ...bulletProps, x: cx, y: y, vx: i * 1.5, vy: -10 });
                  }
              }
          };

          const draw = useCallback(() => {
              const canvas = canvasRef.current;
              if (!canvas) return;
              const ctx = canvas.getContext('2d');
              const g = game.current;
              
              // Clear
              ctx.clearRect(0, 0, g.width, g.height);
              
              // Draw Stars
              ctx.fillStyle = '#ffffff';
              g.stars.forEach(s => {
                  ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                  ctx.beginPath();
                  ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.globalAlpha = 1.0;
              });

              // Draw Player
              if (g.gameState !== 'game-over') {
                  const p = g.player;
                  ctx.fillStyle = '#00ffff'; 
                  ctx.shadowBlur = 15;
                  ctx.shadowColor = '#00ffff';
                  
                  // Ship body
                  ctx.beginPath();
                  ctx.moveTo(p.x + p.w/2, p.y);
                  ctx.lineTo(p.x + p.w, p.y + p.h);
                  ctx.lineTo(p.x + p.w/2, p.y + p.h - 10);
                  ctx.lineTo(p.x, p.y + p.h);
                  ctx.closePath();
                  ctx.fill();

                  // Shield Visual
                  if (p.shieldActive) {
                      ctx.strokeStyle = `rgba(6, 182, 212, ${Math.random() * 0.5 + 0.5})`;
                      ctx.lineWidth = 3;
                      ctx.beginPath();
                      ctx.arc(p.x + p.w/2, p.y + p.h/2, p.w, 0, Math.PI * 2);
                      ctx.stroke();
                  }
                  ctx.shadowBlur = 0;
              }

              // Powerups
              g.powerups.forEach(p => {
                  ctx.fillStyle = p.type === 'weapon' ? '#22c55e' : '#06b6d4';
                  ctx.beginPath();
                  ctx.arc(p.x + 10, p.y + 10, 10, 0, Math.PI*2);
                  ctx.fill();
                  ctx.fillStyle = '#000';
                  ctx.font = '12px Arial';
                  ctx.fillText(p.type === 'weapon' ? 'W' : 'S', p.x + 6, p.y + 14);
              });

              // Bullets
              g.bullets.forEach(b => {
                  ctx.fillStyle = b.color || '#fff';
                  ctx.fillRect(b.x, b.y, b.w, b.h);
              });

              // Enemies
              g.enemies.forEach(e => {
                  ctx.fillStyle = e.type === 'tank' ? '#ef4444' : (e.type === 'speeder' ? '#f59e0b' : '#a855f7');
                  ctx.shadowBlur = 10;
                  ctx.shadowColor = ctx.fillStyle;
                  ctx.fillRect(e.x, e.y, e.w, e.h);
                  // Enemy HP bar (small)
                  ctx.fillStyle = 'red';
                  ctx.fillRect(e.x, e.y - 5, e.w, 3);
                  ctx.fillStyle = 'lime';
                  ctx.fillRect(e.x, e.y - 5, e.w * (e.health/e.maxHealth), 3);
                  ctx.shadowBlur = 0;
              });

              // Boss
              if (g.boss) {
                  const boss = g.boss;
                  ctx.fillStyle = '#ff0055';
                  ctx.shadowBlur = 20;
                  ctx.shadowColor = '#ff0055';
                  // Complex Boss Shape
                  ctx.beginPath();
                  ctx.moveTo(boss.x, boss.y);
                  ctx.lineTo(boss.x + boss.w, boss.y);
                  ctx.lineTo(boss.x + boss.w/2, boss.y + boss.h);
                  ctx.closePath();
                  ctx.fill();
                  
                  ctx.shadowBlur = 0;
                  // Boss HP
                  ctx.fillStyle = '#330033';
                  ctx.fillRect(10, 50, g.width - 20, 10);
                  ctx.fillStyle = '#ff00ff';
                  ctx.fillRect(10, 50, (g.width - 20) * (boss.health / boss.maxHealth), 10);
              }

              // Particles
              g.particles.forEach(p => {
                  ctx.fillStyle = p.color;
                  ctx.globalAlpha = p.life / 20;
                  ctx.fillRect(p.x, p.y, 3, 3);
                  ctx.globalAlpha = 1;
              });

              // HUD
              ctx.fillStyle = 'white';
              ctx.font = 'bold 16px "Courier New"';
              ctx.fillText(`SCORE: ${g.score}`, 10, 25);
              ctx.textAlign = 'right';
              ctx.fillText(`LVL: ${g.level}`, g.width - 10, 25);
              ctx.textAlign = 'left';

              // Player HP Bar
              const hpBarWidth = 150;
              const hpPercent = Math.max(0, g.player.health / g.player.maxHealth);
              ctx.fillStyle = '#333';
              ctx.fillRect(10, g.height - 30, hpBarWidth, 15);
              ctx.fillStyle = hpPercent > 0.5 ? '#22c55e' : (hpPercent > 0.2 ? '#eab308' : '#ef4444');
              ctx.fillRect(10, g.height - 30, hpBarWidth * hpPercent, 15);
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 1;
              ctx.strokeRect(10, g.height - 30, hpBarWidth, 15);
              ctx.fillStyle = '#fff';
              ctx.font = '12px "Courier New"';
              ctx.fillText(`${Math.ceil(g.player.health)}%`, 15, g.height - 18);

              // Shield Status
              if (g.player.shieldActive) {
                  ctx.fillStyle = '#06b6d4';
                  ctx.fillText(`SHIELD: ${Math.ceil(g.player.shieldTimer/1000)}s`, 170, g.height - 18);
              }

              if (g.gameState === 'game-over') {
                  ctx.fillStyle = 'rgba(0,0,0,0.8)';
                  ctx.fillRect(0,0,g.width,g.height);
                  ctx.fillStyle = '#ff0055';
                  ctx.font = 'bold 40px "Courier New"';
                  ctx.textAlign = 'center';
                  ctx.fillText('GAME OVER', g.width/2, g.height/2 - 20);
                  ctx.fillStyle = 'white';
                  ctx.font = '20px "Courier New"';
                  ctx.fillText('Tap to Restart', g.width/2, g.height/2 + 30);
              }

          }, []);

          useEffect(() => {
              initGame();
              const canvas = canvasRef.current;
              const g = game.current;
              
              const resizeCanvas = () => {
                if(canvas && canvas.parentElement) {
                    const { width, height } = canvas.parentElement.getBoundingClientRect();
                    canvas.width = width;
                    canvas.height = height;
                    g.width = width;
                    g.height = height;
                    if(g.stars.length === 0) {
                         for(let i=0; i<80; i++) g.stars.push({x: Math.random()*g.width, y: Math.random()*g.height, size: Math.random()*2, speed: Math.random()*3+0.5});
                    }
                }
              };
              
              resizeCanvas();
              window.addEventListener('resize', resizeCanvas);

              let animationFrameId;
              const gameLoop = () => {
                  update();
                  draw();
                  animationFrameId = window.requestAnimationFrame(gameLoop);
              };
              gameLoop();

              const handleMove = (e) => {
                  if (g.gameState !== 'playing' && g.gameState !== 'boss') return;
                  if(e.cancelable) e.preventDefault();
                  const rect = canvas.getBoundingClientRect();
                  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                  const x = clientX - rect.left;
                  const y = clientY - rect.top;
                  g.player.x = Math.max(0, Math.min(g.width - g.player.w, x - g.player.w / 2));
                  g.player.y = Math.max(0, Math.min(g.height - g.player.h, y - g.player.h / 2));
                  
                  // Auto-fire while moving/touching
                  const now = Date.now();
                  if (now - g.player.lastShot > 150) { // Fire rate
                      firePlayerWeapon(g);
                      g.player.lastShot = now;
                  }
              };

              const handleClick = () => {
                  if (g.gameState === 'game-over') {
                      triggerAd();
                      initGame();
                  }
              }

              canvas.addEventListener('mousemove', handleMove);
              canvas.addEventListener('touchmove', handleMove, { passive: false });
              canvas.addEventListener('click', handleClick);

              return () => {
                  window.cancelAnimationFrame(animationFrameId);
                  window.removeEventListener('resize', resizeCanvas);
                  canvas.removeEventListener('mousemove', handleMove);
                  canvas.removeEventListener('touchmove', handleMove);
                  canvas.removeEventListener('click', handleClick);
              };
          }, [draw, update, initGame, triggerAd]);

          return (
              <div className="w-full h-full relative flex flex-col items-center justify-center bg-transparent">
                  <canvas ref={canvasRef} className="w-full h-full block" />
                  
                  <div className="absolute top-4 left-4 z-10">
                      <button onClick={onBack} className="p-3 bg-white/20 backdrop-blur-md rounded-full text-white hover:bg-white/30 transition border border-white/20">
                          <ChevronLeft size={24} />
                      </button>
                  </div>
              </div>
          );
      };

      // --- Main App Component ---
      const App = () => {
          const [currentScreen, setCurrentScreen] = useState('home');
          const [lastAdTime, setLastAdTime] = useState(0);

          const triggerAd = useCallback(() => {
             const now = Date.now();
             // Cooldown: 2 minutes (120000 ms)
             if (now - lastAdTime > 120000) {
                 console.log("Triggering Ad (Cooldown passed)");
                 // The actual ad display is handled by the external Monetag script observing user interaction.
                 // We can potentially simulate a click or just let the natural interaction flow.
                 // Since we removed explicit intrusive UI, we rely on the global script.
                 setLastAdTime(now);
             } else {
                 console.log("Ad skipped (Cooldown active)");
             }
          }, [lastAdTime]);

          const startGame = (gameName) => {
              triggerAd();
              setCurrentScreen(gameName);
          };

          const renderScreen = () => {
              switch(currentScreen) {
                  case 'galaxy-invader':
                      return <GalaxyInvader onBack={() => setCurrentScreen('home')} triggerAd={triggerAd} />;
                  default:
                      return (
                          <div className="w-full h-full flex flex-col items-center justify-center relative overflow-hidden">
                              {/* Content Container */}
                              <div className="z-10 flex flex-col items-center gap-8 w-full max-w-md px-4">
                                  {/* Neon Title */}
                                  <h1 className="text-5xl md:text-6xl font-bold text-center neon-text tracking-wider">
                                      JoGos<br/>Online
                                  </h1>
                                  
                                  {/* Game Cards - Light Theme */}
                                  <div className="w-full grid gap-4 mt-8">
                                      <button 
                                          onClick={() => startGame('galaxy-invader')}
                                          className="glass-box group relative w-full h-32 rounded-xl overflow-hidden hover:scale-105 transition-all duration-300"
                                      >
                                          {/* Hover gradient */}
                                          <div className="absolute inset-0 bg-gradient-to-r from-white/10 to-transparent opacity-0 group-hover:opacity-100 transition-opacity"></div>
                                          
                                          <div className="relative z-10 flex items-center justify-between p-6 h-full text-white">
                                              <div className="flex flex-col items-start">
                                                  <span className="text-2xl font-bold text-white drop-shadow-md">GALAXY INVADER</span>
                                                  <span className="text-xs text-gray-200 mt-1">Space Shooter Arcade</span>
                                              </div>
                                              <Rocket size={40} className="text-purple-300 drop-shadow-[0_0_10px_rgba(168,85,247,0.8)]" />
                                          </div>
                                      </button>

                                      <button 
                                          className="glass-box w-full h-24 rounded-xl flex items-center justify-center text-gray-400 cursor-not-allowed border border-white/10"
                                      >
                                          <span className="text-sm font-semibold tracking-widest">EM BREVE...</span>
                                      </button>
                                  </div>
                              </div>
                              
                              <div className="absolute bottom-4 text-gray-500 text-xs">
                                  v3.0.0
                              </div>
                          </div>
                      );
              }
          };

          return renderScreen();
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>