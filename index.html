<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Paciência Pro - Solitaire</title>
    <meta name="description" content="Jogue Paciência (Solitaire) Grátis. Leve, rápido e funciona offline.">
    <meta name="theme-color" content="#0f3526">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png">
    
    <!-- Preload Assets -->
    <link rel="preload" href="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png" as="image">
    
    <!-- Monetag Verification -->
    <meta name="monetag" content="90e74a99c3a7b6c2ba03e69c9477a61d">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@700;900&family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for React -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3768566268455535" crossorigin="anonymous"></script>

    <!-- Monetag Scripts -->
    <script src="https://fpyf8.com/88/tag.min.js" data-zone="187944" async data-cfasync="false"></script>
    <script>(function(s){s.dataset.zone='10234172',s.src='https://nap5k.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>
    <script>(function(s){s.dataset.zone='10236160',s.src='https://nap5k.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>

    <style>
        body { 
            overscroll-behavior: none; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent;
            font-family: 'Inter', sans-serif;
            overflow: hidden; 
            background-color: #0f3526;
            user-select: none;
            -webkit-user-select: none;
        }
        .card-draggable { 
            touch-action: none; 
        }
        /* Hardware Acceleration Class */
        .hardware-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }

        /* Install Button Animations */
        @keyframes gradient-xy {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .animate-gradient-xy {
            background-size: 200% 200%;
            animation: gradient-xy 3s ease infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-150%) skewX(-15deg); }
            100% { transform: translateX(150%) skewX(-15deg); }
        }
        @keyframes neon-pulse {
            0%, 100% { box-shadow: 0 0 10px #9333ea, 0 0 20px #9333ea; border-color: #9333ea; }
            50% { box-shadow: 0 0 10px #22c55e, 0 0 20px #22c55e; border-color: #22c55e; }
        }
        .animate-neon-pulse {
            animation: neon-pulse 2s infinite;
        }
        
        /* 3D Victory Text */
        .victory-text {
            font-family: 'Crimson Pro', serif;
            background: linear-gradient(to bottom, #fde047, #ca8a04);
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0px 4px 10px rgba(0,0,0,0.5);
            filter: drop-shadow(0 0 20px rgba(234, 179, 8, 0.6));
            animation: zoom-in-bounce 1s ease-out forwards;
        }
        @keyframes zoom-in-bounce {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            60% { transform: scale(1.2) rotate(5deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        /* Win Wave */
        @keyframes win-wave { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-30px); } }
        .animate-win-wave { animation: win-wave 1s ease-in-out infinite; }
        
        /* Hint Animations */
        .hint-source { animation: pulse-yellow 1.5s infinite; filter: brightness(1.2); }
        .hint-target { animation: pulse-green 1.5s infinite; box-shadow: 0 0 15px #4ade80; z-index: 50; }
        @keyframes pulse-yellow { 0%, 100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(250, 204, 21, 0); } }
        @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); } }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useCallback, useRef, memo } from 'react';
      import { createRoot } from 'react-dom/client';
      import { Heart, Diamond, Club, Spade, Trophy, Clock, RotateCcw, X, LayoutGrid, RefreshCw, Eye, Play, Pause, Volume2, VolumeX, Maximize, Crown, Undo2, Lightbulb, Wand2, CalendarCheck, Moon, Sun, Smartphone, Gift, CheckCircle2, Share } from 'lucide-react';

      // --- UTILS & CONSTANTS ---
      const Suit = { Hearts: 'hearts', Diamonds: 'diamonds', Clubs: 'clubs', Spades: 'spades' };
      const Rank = { Ace: 1, Two: 2, Three: 3, Four: 4, Five: 5, Six: 6, Seven: 7, Eight: 8, Nine: 9, Ten: 10, Jack: 11, Queen: 12, King: 13 };
      const GameMode = { FreeCell: 'freeCell', Klondike: 'klondike' };
      
      // Stop Ad Propagation
      const stopAdEvent = (e) => {
          if (!e) return;
          e.stopPropagation();
          e.preventDefault();
          if (e.nativeEvent) e.nativeEvent.stopImmediatePropagation();
      };

      const getCardColor = (suit) => (suit === Suit.Hearts || suit === Suit.Diamonds ? 'red' : 'black');

      const createDeck = (faceUp = true) => {
        const deck = [];
        const suits = [Suit.Hearts, Suit.Diamonds, Suit.Clubs, Suit.Spades];
        const ranks = Object.values(Rank);
        suits.forEach((suit) => {
          ranks.forEach((rank) => {
            deck.push({ id: `${suit}-${rank}`, suit, rank, isFaceUp: faceUp });
          });
        });
        return deck;
      };

      const shuffleDeck = (deck) => {
        const newDeck = [...deck];
        for (let i = newDeck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
        }
        return newDeck;
      };

      // Rules
      const isMoveValid = (card, targetCard, targetType, mode, targetSuit) => {
        if (targetType === 'freeCell') return targetCard === null && mode === GameMode.FreeCell;
        
        if (targetType === 'foundation') {
          if (!targetCard) return card.rank === Rank.Ace && card.suit === targetSuit;
          return card.suit === targetCard.suit && card.rank === targetCard.rank + 1;
        }

        if (targetType === 'tableau') {
          if (!targetCard) {
            if (mode === GameMode.Klondike) return card.rank === Rank.King;
            return true;
          }
          const cardColor = getCardColor(card.suit);
          const targetColor = getCardColor(targetCard.suit);
          return cardColor !== targetColor && card.rank === targetCard.rank - 1;
        }
        return false;
      };

      const isStackValid = (cards) => {
        if (cards.length <= 1) return true;
        for (let i = 0; i < cards.length - 1; i++) {
          const current = cards[i];
          const next = cards[i + 1];
          if (!current.isFaceUp || !next.isFaceUp) return false;
          if (getCardColor(current.suit) === getCardColor(next.suit) || current.rank !== next.rank + 1) return false;
        }
        return true;
      };

      const getMaxMovableStack = (emptyFreeCells, emptyTableauCols) => {
        return (1 + emptyFreeCells) * Math.pow(2, emptyTableauCols);
      };

      // --- COMPONENTS ---
      const SuitIcon = ({ suit, className, fill = true }) => {
        const props = { className, strokeWidth: fill ? 0 : 2 };
        switch (suit) {
          case Suit.Hearts: return <Heart {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Diamonds: return <Diamond {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Clubs: return <Club {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Spades: return <Spade {...props} fill={fill ? "currentColor" : "none"} />;
        }
      };

      const RankLabel = ({ rank }) => {
        let label = rank.toString();
        if (rank === 1) label = 'A';
        else if (rank === 11) label = 'J';
        else if (rank === 12) label = 'Q';
        else if (rank === 13) label = 'K';
        return <span className="font-serif tracking-tighter font-black drop-shadow-[0_1px_0_rgba(0,0,0,0.1)]">{label}</span>;
      };

      // SVG Textures
      const PARCHMENT_TEXTURE = `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E")`;
      const BACK_PATTERN = `url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23991b1b' fill-opacity='0.4' fill-rule='evenodd'%3E%3Cpath d='M10 0L20 10L10 20L0 10z'/%3E%3C/g%3E%3C/svg%3E")`;

      const SolitaireCard = memo(({ card, onPointerDown, isSelected, className = '', style, draggable }) => {
        const isFaceCard = card.rank >= 11;
        const isAce = card.rank === 1;
        const color = getCardColor(card.suit);
        const textColor = color === 'red' ? 'text-[#d40000]' : 'text-[#1a1a1a]';
        
        return (
          <div
            className={`relative w-full aspect-[2.5/3.5] select-none [perspective:1000px] ${draggable ? 'cursor-grab active:cursor-grabbing' : ''} ${className}`}
            onPointerDown={(e) => { 
                if (onPointerDown) {
                    stopAdEvent(e);
                    onPointerDown(e, e.currentTarget); 
                }
            }}
            onClick={stopAdEvent}
            style={{ ...style, zIndex: isSelected ? 100 : style?.zIndex }}
          >
            <div className={`w-full h-full relative transition-transform duration-200 ease-[cubic-bezier(0.25,0.8,0.25,1)] [transform-style:preserve-3d] will-change-transform ${card.isFaceUp ? '[transform:rotateY(0deg)]' : '[transform:rotateY(180deg)]'}`}>
              
              {/* FRONT */}
              <div className={`absolute inset-0 [backface-visibility:hidden] bg-[#fcfaf5] rounded-[6%] overflow-hidden flex items-center justify-center transition-all duration-300 ${isSelected ? 'ring-[3px] ring-yellow-400 ring-offset-2 ring-offset-[#0f3526] -translate-y-2 brightness-105' : 'shadow-[0_2px_4px_rgba(0,0,0,0.15)]'}`}>
                 <div className="absolute inset-0 pointer-events-none mix-blend-multiply opacity-50" style={{ backgroundImage: PARCHMENT_TEXTURE }}></div>
                 <div className="absolute inset-0 bg-gradient-to-br from-white/80 to-transparent pointer-events-none"></div>

                 <div className={`absolute top-[4%] left-[6%] flex flex-col items-center leading-none ${textColor} w-[18%]`}>
                    <span className="text-[min(18px,4.5vw)] sm:text-2xl font-bold font-serif"><RankLabel rank={card.rank} /></span>
                    <SuitIcon suit={card.suit} className="w-[min(14px,3.5vw)] h-[min(14px,3.5vw)] sm:w-4 sm:h-4" />
                 </div>
                 
                 <div className={`absolute inset-[15%] flex items-center justify-center ${textColor}`}>
                     {isFaceCard || isAce ? <SuitIcon suit={card.suit} className="w-[60%] h-[60%] drop-shadow-md" /> : 
                     <div className="text-4xl font-black opacity-10"><SuitIcon suit={card.suit} /></div>}
                 </div>

                 <div className={`absolute bottom-[4%] right-[6%] flex flex-col items-center leading-none rotate-180 ${textColor} w-[18%]`}>
                    <span className="text-[min(18px,4.5vw)] sm:text-2xl font-bold font-serif"><RankLabel rank={card.rank} /></span>
                    <SuitIcon suit={card.suit} className="w-[min(14px,3.5vw)] h-[min(14px,3.5vw)] sm:w-4 sm:h-4" />
                 </div>
              </div>

              {/* BACK */}
              <div className="absolute inset-0 [backface-visibility:hidden] [transform:rotateY(180deg)] bg-[#7f1d1d] rounded-[6%] border-[3px] border-[#fcfaf5] shadow-[inset_0_0_4px_rgba(0,0,0,0.3)] flex items-center justify-center">
                 <div className="absolute inset-1.5 border border-[#fbbf24]/20 rounded-[4.5%]" style={{ backgroundImage: BACK_PATTERN }}></div>
                 <div className="relative w-[35%] h-[25%] bg-[#450a0a] rounded-[50%] flex items-center justify-center shadow-inner border-2 border-[#fbbf24]/40 z-10">
                     <Crown className="w-[60%] h-[60%] text-[#fbbf24] drop-shadow-md" strokeWidth={1.5} />
                 </div>
              </div>
            </div>
          </div>
        );
      });

      const DraggableMenu = ({ children }) => {
         const [pos, setPos] = useState({ x: window.innerWidth / 2, y: window.innerHeight - 150 });
         const [isDragging, setIsDragging] = useState(false);
         const offset = useRef({ x: 0, y: 0 });

         const handlePointerDown = (e) => {
             stopAdEvent(e);
             if (e.target.closest('button')) return;
             setIsDragging(true);
             offset.current = { x: e.clientX - pos.x, y: e.clientY - pos.y };
             e.target.setPointerCapture(e.pointerId);
         };

         const handlePointerMove = (e) => {
             if (!isDragging) return;
             stopAdEvent(e);
             const newX = Math.min(window.innerWidth - 60, Math.max(60, e.clientX - offset.current.x));
             const newY = Math.min(window.innerHeight - 40, Math.max(40, e.clientY - offset.current.y));
             setPos({ x: newX, y: newY });
         };

         const handlePointerUp = (e) => {
             if(isDragging) {
                setIsDragging(false);
                e.target.releasePointerCapture(e.pointerId);
             }
         };

         return (
             <div 
                className="fixed z-[200] touch-none flex flex-col items-center gap-1 cursor-grab active:cursor-grabbing"
                style={{ left: pos.x, top: pos.y, transform: 'translate(-50%, -50%)' }}
                onPointerDown={handlePointerDown}
                onPointerMove={handlePointerMove}
                onPointerUp={handlePointerUp}
             >
                <div className="w-16 h-1.5 bg-white/20 rounded-full mb-1 shadow-sm"></div>
                <div className="bg-[#0a1f16]/90 backdrop-blur-xl p-2 rounded-2xl border border-yellow-500/30 shadow-[0_10px_30px_rgba(0,0,0,0.5)] flex items-center gap-4 pointer-events-auto select-none">
                    {children}
                </div>
                <div className="text-[10px] text-white/30 font-bold uppercase tracking-widest mt-1">Menu</div>
             </div>
         );
      };

      const InstallModal = ({ onInstall, onClose, isIOS, hasNativePrompt }) => (
        <div className="fixed inset-0 z-[300] bg-black/90 backdrop-blur-md flex items-center justify-center p-4" onClick={stopAdEvent}>
            <div className="bg-[#1e293b] rounded-3xl p-8 max-w-sm w-full text-center border border-yellow-500/50 shadow-2xl relative overflow-hidden">
                <div className="absolute inset-0 bg-gradient-to-tr from-purple-600/20 to-green-500/20 pointer-events-none"></div>
                <button onClick={onClose} className="absolute top-4 right-4 text-white/50 hover:text-white"><X /></button>
                <div className="relative z-10">
                    <div className="mb-6 inline-block relative">
                         <div className="absolute inset-0 bg-gradient-to-r from-purple-500 to-green-500 rounded-full blur-xl opacity-50 animate-pulse"></div>
                         <div className="relative bg-white/10 p-4 rounded-full border border-white/20"><Smartphone className="w-12 h-12 text-white" /></div>
                    </div>
                    <h2 className="text-2xl font-black text-white mb-2 uppercase tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-yellow-600">Criar Atalho?</h2>
                    <p className="text-gray-300 mb-6 text-sm">Adicione à tela inicial para jogar sem travar.</p>
                    {isIOS ? (
                        <div className="text-left bg-white/5 p-4 rounded-xl border border-white/10 mb-6 text-xs text-gray-300 space-y-2">
                             <p>1. Toque em <Share className="w-3 h-3 inline" /> <strong>Compartilhar</strong></p>
                             <p>2. Selecione <strong>Adicionar à Tela de Início</strong></p>
                        </div>
                    ) : (
                        <div className="flex gap-3">
                            <button onClick={onClose} className="flex-1 py-3 rounded-xl font-bold uppercase text-white/70 bg-red-500/10 border border-red-500/20">NÃO</button>
                            <button onClick={onInstall} className="flex-[1.5] py-3 rounded-xl font-bold uppercase text-white bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 animate-pulse">SIM</button>
                        </div>
                    )}
                </div>
            </div>
        </div>
      );

      const AdBanner = ({ className = '', slotId = "1109009056", format = 'auto' }) => {
        const initialized = useRef(false);
        useEffect(() => {
          if (initialized.current) return;
          try { (window.adsbygoogle = window.adsbygoogle || []).push({}); initialized.current = true; } catch (e) {}
        }, []);
        return (
          <div className={`bg-gray-800/20 flex items-center justify-center text-gray-500 text-[10px] uppercase tracking-widest border border-white/5 overflow-hidden ${className}`}>
            <ins className="adsbygoogle block w-full h-full" data-ad-client="ca-pub-3768566268455535" data-ad-slot={slotId} data-ad-format={format} data-full-width-responsive="true"></ins>
            <span className="absolute -z-10">Publicidade</span>
          </div>
        );
      };

      // --- MAIN APP ---
      function App() {
        const [gameMode, setGameMode] = useState(GameMode.FreeCell);
        const [gameState, setGameState] = useState({
            mode: GameMode.FreeCell,
            freeCells: [null, null, null, null],
            stock: [], waste: [],
            foundation: { [Suit.Hearts]: [], [Suit.Diamonds]: [], [Suit.Clubs]: [], [Suit.Spades]: [] },
            tableau: [], score: 0, moves: 0, time: 0, gameWon: false
        });
        const [history, setHistory] = useState([]);
        const [selected, setSelected] = useState(null);
        const [hint, setHint] = useState(null);
        const [isNightMode, setIsNightMode] = useState(false);
        const [showInstallButton, setShowInstallButton] = useState(true);
        const [showInstallModal, setShowInstallModal] = useState(false);
        const [deferredPrompt, setDeferredPrompt] = useState(null);
        const [showInterstitial, setShowInterstitial] = useState(false);
        const [interstitialTimer, setInterstitialTimer] = useState(0);

        const activeDragRef = useRef(null);
        const dragRaf = useRef(null);

        // INITIALIZATION
        const startNewGame = useCallback(() => {
            const deck = shuffleDeck(createDeck(gameMode === GameMode.FreeCell));
            let newTableau = [], stock = [], waste = [];
            
            if (gameMode === GameMode.FreeCell) {
                newTableau = Array(8).fill().map(() => []);
                let idx = 0;
                for(let col=0; col<8; col++) {
                    const count = col < 4 ? 7 : 6;
                    for(let i=0; i<count; i++) newTableau[col].push(deck[idx++]);
                }
            } else {
                newTableau = Array(7).fill().map(() => []);
                let idx = 0;
                for(let col=0; col<7; col++) {
                    for(let i=0; i<=col; i++) {
                        const card = deck[idx++];
                        card.isFaceUp = (i === col);
                        newTableau[col].push(card);
                    }
                }
                stock = deck.slice(idx).map(c => ({...c, isFaceUp: false}));
            }
            
            setGameState({
                mode: gameMode,
                freeCells: [null,null,null,null],
                stock, waste,
                foundation: { [Suit.Hearts]: [], [Suit.Diamonds]: [], [Suit.Clubs]: [], [Suit.Spades]: [] },
                tableau: newTableau, score: 0, moves: 0, time: 0, gameWon: false
            });
            setHistory([]); setSelected(null); setHint(null);
        }, [gameMode]);

        useEffect(() => { startNewGame(); }, [startNewGame]);

        // INSTALLATION LOGIC
        useEffect(() => {
            const handlePrompt = (e) => { e.preventDefault(); setDeferredPrompt(e); setShowInstallButton(true); setTimeout(() => setShowInstallModal(true), 2000); };
            window.addEventListener('beforeinstallprompt', handlePrompt);
            return () => window.removeEventListener('beforeinstallprompt', handlePrompt);
        }, []);

        const handleInstallClick = async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') setDeferredPrompt(null);
            } else {
                setShowInstallModal(true);
            }
        };

        // ADS LOGIC (1 Min Start, 5 Min Loop)
        useEffect(() => {
            const startTimer = setTimeout(() => { setShowInterstitial(true); setInterstitialTimer(5);
                const loop = setInterval(() => { if(!document.hidden) { setShowInterstitial(true); setInterstitialTimer(5); } }, 300000);
                return () => clearInterval(loop);
            }, 60000);
            return () => clearTimeout(startTimer);
        }, []);
        
        useEffect(() => {
            if(showInterstitial && interstitialTimer > 0) {
                const i = setInterval(() => setInterstitialTimer(p => p-1), 1000);
                return () => clearInterval(i);
            }
        }, [showInterstitial, interstitialTimer]);

        // GAMEPLAY HELPERS
        const saveHistory = () => setHistory(prev => [...prev.slice(-49), JSON.parse(JSON.stringify(gameState))]);
        
        const handleUndo = () => {
            if(!history.length) return;
            setGameState(history[history.length-1]);
            setHistory(h => h.slice(0, -1));
        };

        const handleCardMove = (source, targetType, targetIndex, suit) => {
            saveHistory();
            setGameState(prev => {
                const newState = {...prev};
                let cards = [];
                
                // EXTRACT
                if (source.pileType === 'freeCell') { cards = [newState.freeCells[source.pileIndex]]; newState.freeCells[source.pileIndex] = null; }
                else if (source.pileType === 'waste') { cards = [newState.waste.pop()]; }
                else if (source.pileType === 'tableau') {
                    const col = newState.tableau[source.pileIndex];
                    cards = col.slice(source.cardIndex);
                    
                    if (prev.mode === GameMode.FreeCell && cards.length > 1) {
                         const emptyFC = newState.freeCells.filter(c => c === null).length;
                         let emptyTab = newState.tableau.filter(c => c.length === 0).length;
                         if (targetType === 'tableau' && newState.tableau[targetIndex].length === 0) emptyTab = Math.max(0, emptyTab - 1);
                         if (cards.length > getMaxMovableStack(emptyFC, emptyTab)) return prev;
                    }

                    newState.tableau[source.pileIndex] = col.slice(0, source.cardIndex);
                    // Flip Klondike card underneath
                    if (prev.mode === GameMode.Klondike && newState.tableau[source.pileIndex].length > 0) {
                        const top = newState.tableau[source.pileIndex][newState.tableau[source.pileIndex].length - 1];
                        if (!top.isFaceUp) { top.isFaceUp = true; newState.score += 5; }
                    }
                }

                // INSERT
                if (targetType === 'freeCell') newState.freeCells[targetIndex] = cards[0];
                else if (targetType === 'tableau') newState.tableau[targetIndex].push(...cards);
                else if (targetType === 'foundation') newState.foundation[suit].push(cards[0]);
                
                newState.moves++;
                newState.score += 10;
                return newState;
            });
            setSelected(null);
        };

        const handleCardClick = (card, pileType, pileIndex, cardIndex) => {
            if (!card && pileType === 'tableau') {
                if(selected && isMoveValid(selected.card, null, 'tableau', gameState.mode)) handleCardMove(selected, 'tableau', pileIndex);
                return;
            }
            if (!card || (!card.isFaceUp && pileType === 'tableau')) return;

            // Auto Move
            if (pileType !== 'foundation') {
                const fPile = gameState.foundation[card.suit];
                const fTarget = fPile.length ? fPile[fPile.length-1] : null;
                if (cardIndex === (pileType==='tableau' ? gameState.tableau[pileIndex].length-1 : 0)) {
                    if(isMoveValid(card, fTarget, 'foundation', gameState.mode, card.suit)) {
                        handleCardMove({card, pileType, pileIndex, cardIndex}, 'foundation', null, card.suit);
                        return;
                    }
                }
            }

            if (selected && selected.card.id === card.id) { setSelected(null); return; }
            
            if(selected) {
                if (pileType === 'tableau') {
                     if (isMoveValid(selected.card, card, 'tableau', gameState.mode)) {
                         handleCardMove(selected, 'tableau', pileIndex);
                         return;
                     }
                }
                setSelected(null);
            } else {
                if (pileType === 'tableau') {
                    if (isStackValid(gameState.tableau[pileIndex].slice(cardIndex))) setSelected({card, pileType, pileIndex, cardIndex});
                } else if (pileType === 'freeCell' || pileType === 'waste') {
                    setSelected({card, pileType, pileIndex, cardIndex: 0});
                }
            }
        };

        const handleDragStart = (e, card, pileType, pileIndex, cardIndex, domEl) => {
             stopAdEvent(e);
             if(!card.isFaceUp) return;
             if(pileType === 'tableau' && !isStackValid(gameState.tableau[pileIndex].slice(cardIndex))) return;
             
             // CAPTURE EXACT WIDTH TO PREVENT GIANT CARD BUG
             const rect = domEl.getBoundingClientRect();
             const cardWidth = rect.width;

             let elements = [domEl];
             let stackOffset = 0;
             
             if(pileType === 'tableau') {
                 const siblings = Array.from(domEl.parentElement.children);
                 const idx = siblings.indexOf(domEl);
                 elements = siblings.slice(idx);
                 stackOffset = gameMode === GameMode.Klondike ? 15 : 28;
             }
             
             // Set transition none immediately to follow finger
             elements.forEach(el => {
                 el.style.transition = 'none';
                 el.style.zIndex = '9999'; // CRITICAL FIX: Ensure drag is always on top
             });
             
             activeDragRef.current = {
                 card, pileType, pileIndex, cardIndex,
                 startX: e.clientX, startY: e.clientY,
                 offsetX: e.clientX - rect.left, offsetY: e.clientY - rect.top,
                 elements, stackOffset,
                 width: cardWidth
             };
             
             window.addEventListener('pointermove', handlePointerMove);
             window.addEventListener('pointerup', handlePointerUp);
        };

        const handlePointerMove = (e) => {
            if(!activeDragRef.current) return;
            if(dragRaf.current) cancelAnimationFrame(dragRaf.current);
            dragRaf.current = requestAnimationFrame(() => {
                if(!activeDragRef.current) return;
                const { elements, offsetX, offsetY, stackOffset, width } = activeDragRef.current;
                
                elements.forEach((el, i) => {
                    // Force Fixed Position to break out of stacking context
                    el.style.position = 'fixed';
                    el.style.width = width + 'px'; // Lock Width
                    el.style.left = '0px'; 
                    el.style.top = '0px';
                    el.style.zIndex = (9999 + i).toString(); // Super High Z-Index
                    el.style.pointerEvents = 'none'; // Allow clicking through to drop zone
                    el.style.transform = `translate3d(${e.clientX - offsetX}px, ${e.clientY - offsetY + (i * stackOffset)}px, 0) scale(1.05)`;
                    el.style.boxShadow = '0 15px 30px rgba(0,0,0,0.5)'; // Lift effect
                });
            });
        };

        const handlePointerUp = (e) => {
            window.removeEventListener('pointermove', handlePointerMove);
            window.removeEventListener('pointerup', handlePointerUp);
            if(!activeDragRef.current) return;
            
            const { card, pileType, pileIndex, cardIndex, elements, startX, startY } = activeDragRef.current;
            elements.forEach(el => { el.style = ''; }); // Reset all inline styles
            activeDragRef.current = null;

            // Tap Detection
            if (Math.hypot(e.clientX - startX, e.clientY - startY) < 10) {
                handleCardClick(card, pileType, pileIndex, cardIndex);
            } else {
                // Hit Test
                const hits = document.elementsFromPoint(e.clientX, e.clientY);
                const dropZone = hits.find(el => el.dataset.dropZone === 'true');
                if (dropZone) {
                    const type = dropZone.dataset.dropType;
                    const idx = parseInt(dropZone.dataset.dropIndex);
                    const suit = dropZone.dataset.dropSuit;
                    
                    let targetCard = null;
                    if(type === 'tableau') {
                        const col = gameState.tableau[idx];
                        if(col.length) targetCard = col[col.length-1];
                    } else if (type === 'foundation') {
                        const pile = gameState.foundation[suit];
                        if(pile.length) targetCard = pile[pile.length-1];
                    } else if (type === 'freeCell') {
                        targetCard = gameState.freeCells[idx];
                    }
                    
                    if (isMoveValid(card, targetCard, type, gameState.mode, suit)) {
                        handleCardMove({card, pileType, pileIndex, cardIndex}, type, idx, suit);
                    }
                }
            }
        };

        const handleStock = () => {
             if(gameMode !== GameMode.Klondike) return;
             setGameState(prev => {
                 const ns = {...prev};
                 if(ns.stock.length === 0) {
                     ns.stock = ns.waste.reverse().map(c => ({...c, isFaceUp: false}));
                     ns.waste = [];
                 } else {
                     const c = ns.stock.pop();
                     c.isFaceUp = true;
                     ns.waste.push(c);
                 }
                 ns.moves++;
                 return ns;
             });
             setSelected(null);
        };
        
        const handleHint = () => {
              for (let i = 0; i < gameState.tableau.length; i++) {
                  const col = gameState.tableau[i];
                  if(col.length){
                      const card = col[col.length-1];
                      const fTarget = gameState.foundation[card.suit].length ? gameState.foundation[card.suit][gameState.foundation[card.suit].length-1] : null;
                      if(isMoveValid(card, fTarget, 'foundation', gameState.mode, card.suit)){
                           setHint({sourceId: card.id, targetId: `foundation-${card.suit}`});
                           setTimeout(()=>setHint(null), 2000); return;
                      }
                  }
              }
        };

        const handleAuto = () => {
             let moved = false;
             const ns = JSON.parse(JSON.stringify(gameState));
             for(let i=0; i<ns.tableau.length; i++) {
                 const col = ns.tableau[i];
                 if(col.length) {
                     const card = col[col.length-1];
                     const fPile = ns.foundation[card.suit];
                     const fTarget = fPile.length ? fPile[fPile.length-1] : null;
                     if(isMoveValid(card, fTarget, 'foundation', ns.mode, card.suit)) {
                         saveHistory();
                         col.pop(); fPile.push(card);
                         if(ns.mode === GameMode.Klondike && col.length && !col[col.length-1].isFaceUp) col[col.length-1].isFaceUp=true;
                         moved=true; break;
                     }
                 }
             }
             if(moved) setGameState(ns);
        };

        return (
            <div className={`min-h-screen flex flex-col ${isNightMode ? 'bg-[#0f172a]' : 'bg-[#0f3526]'} transition-colors duration-500 overflow-hidden`} onClick={(e) => { stopAdEvent(e); }}>
                {/* Header */}
                <header className="px-4 py-2 bg-black/30 backdrop-blur-md flex items-center justify-between sticky top-0 z-50 border-b border-white/5">
                    <div className="flex items-center gap-3">
                        <Trophy className="text-yellow-500 w-5 h-5" />
                        <h1 className="text-white font-serif font-bold text-lg">Solitaire Pro</h1>
                    </div>
                    <div className="flex items-center gap-2">
                        {showInstallButton && <button onClick={handleInstallClick} className="group relative px-4 py-1.5 rounded-full overflow-hidden transition-all duration-300 hover:scale-105 active:scale-95 animate-neon-pulse flex items-center gap-2 border-2 border-transparent">
                            <div className="absolute inset-0 bg-gradient-to-r from-purple-800 via-green-600 to-purple-800 opacity-90 group-hover:opacity-100 animate-gradient-xy"></div>
                            <Smartphone className="w-4 h-4 text-white z-10" />
                            <span className="text-xs font-black uppercase text-white z-10 tracking-wider">Instalar</span>
                        </button>}
                        <div className="flex bg-black/40 rounded-lg p-1">
                            <button onClick={()=>setGameMode(GameMode.FreeCell)} className={`px-3 py-1 text-xs rounded ${gameMode===GameMode.FreeCell?'bg-emerald-600 text-white':'text-white/50'}`}>FreeCell</button>
                            <button onClick={()=>setGameMode(GameMode.Klondike)} className={`px-3 py-1 text-xs rounded ${gameMode===GameMode.Klondike?'bg-emerald-600 text-white':'text-white/50'}`}>Clássico</button>
                        </div>
                        <button onClick={()=>setIsNightMode(!isNightMode)} className="text-yellow-300 p-2">{isNightMode?<Sun size={18}/>:<Moon size={18}/>}</button>
                    </div>
                </header>
                
                {/* Stats */}
                <div className="flex justify-center py-1 bg-black/20 gap-6 text-xs font-mono text-white/80 border-b border-white/5">
                    <span>SCORE: {gameState.score}</span>
                    <span>MOVES: {gameState.moves}</span>
                </div>

                {/* Main Game Area */}
                <main className="flex-grow p-2 sm:p-4 max-w-5xl mx-auto w-full relative z-0 pb-32">
                    <div className="grid grid-cols-8 gap-1 sm:gap-3 mb-4 sm:mb-8">
                        {/* Top Row: FreeCells/Stock + Foundations */}
                        {gameMode === GameMode.FreeCell ? (
                            gameState.freeCells.map((c, i) => (
                                <div key={i} data-drop-zone="true" data-drop-type="freeCell" data-drop-index={i} onClick={()=>handleCardClick(c, 'freeCell', i)} className={`aspect-[2.5/3.5] rounded bg-black/20 border-2 ${selected?.pileType==='freeCell' && selected.pileIndex===i ? 'border-yellow-400':'border-white/10'}`}>
                                    {c && <SolitaireCard card={c} draggable onPointerDown={(e,el)=>handleDragStart(e,c,'freeCell',i,0,el)} isSelected={selected?.card.id===c.id} />}
                                </div>
                            ))
                        ) : (
                            <>
                                <div className="col-span-1 aspect-[2.5/3.5] bg-black/20 rounded border-2 border-white/10 flex items-center justify-center" onClick={handleStock}>
                                    {gameState.stock.length > 0 ? (
                                        <div className="relative w-full h-full"><div className="absolute inset-0.5 bg-[#5c0b0b] rounded-[4%] border border-white/20"></div><RefreshCw className="absolute inset-0 m-auto text-white/20" /></div>
                                    ) : <RefreshCw className="text-white/20" />}
                                </div>
                                <div className="col-span-1 aspect-[2.5/3.5]">
                                    {gameState.waste.length>0 && <SolitaireCard card={gameState.waste[gameState.waste.length-1]} draggable onPointerDown={(e,el)=>handleDragStart(e,gameState.waste[gameState.waste.length-1],'waste',0,0,el)} isSelected={selected?.card.id===gameState.waste[gameState.waste.length-1].id} />}
                                </div>
                                <div className="col-span-2"></div>
                            </>
                        )}
                        
                        {/* Foundations */}
                        {[Suit.Hearts, Suit.Diamonds, Suit.Clubs, Suit.Spades].map((s, i) => {
                             const fPile = gameState.foundation[s];
                             const top = fPile.length ? fPile[fPile.length-1] : null;
                             return (
                                 <div key={s} data-drop-zone="true" data-drop-type="foundation" data-drop-suit={s} className={`col-span-1 aspect-[2.5/3.5] rounded bg-black/20 border-2 border-white/10 flex items-center justify-center ${hint?.targetId===`foundation-${s}`?'ring-2 ring-emerald-400':''}`}>
                                     {top ? <SolitaireCard card={top} /> : <SuitIcon suit={s} className="text-white/10 w-8 h-8" />}
                                 </div>
                             );
                        })}
                    </div>

                    {/* Tableau */}
                    <div className="grid grid-cols-8 gap-1 sm:gap-3 h-full">
                         {gameState.tableau.map((col, i) => (
                             <div key={i} data-drop-zone="true" data-drop-type="tableau" data-drop-index={i} onClick={()=>col.length===0 && handleCardClick(null, 'tableau', i)} className="relative h-[60vh]">
                                 {col.map((card, idx) => (
                                     <div key={card.id} className="absolute w-full" style={{top: `${idx * (gameMode===GameMode.Klondike && !card.isFaceUp ? 10 : 25)}px`, zIndex: idx}}>
                                         <SolitaireCard card={card} draggable={card.isFaceUp} onPointerDown={(e,el)=>handleDragStart(e,card,'tableau',i,idx,el)} isSelected={selected?.card.id===card.id} className={hint?.sourceId===card.id?'ring-2 ring-yellow-400':''} />
                                     </div>
                                 ))}
                             </div>
                         ))}
                    </div>
                </main>

                {/* Draggable Floating Menu (Moved out of fixed bottom bar) */}
                <DraggableMenu>
                    <button onClick={handleUndo} disabled={!history.length} className={`flex flex-col items-center p-2 rounded-lg w-14 ${!history.length?'opacity-30':'hover:bg-white/10'} text-white transition`}>
                        <Undo2 size={20} /><span className="text-[9px] uppercase font-bold mt-1">Undo</span>
                    </button>
                    <div className="w-px h-8 bg-white/10"></div>
                    <button onClick={handleHint} className="flex flex-col items-center p-2 rounded-lg w-14 hover:bg-white/10 text-yellow-300 transition">
                        <Lightbulb size={20} /><span className="text-[9px] uppercase font-bold mt-1">Dica</span>
                    </button>
                    <div className="w-px h-8 bg-white/10"></div>
                    <button onClick={handleAuto} className="flex flex-col items-center p-2 rounded-lg w-14 hover:bg-white/10 text-emerald-400 transition">
                        <Wand2 size={20} /><span className="text-[9px] uppercase font-bold mt-1">Auto</span>
                    </button>
                </DraggableMenu>
                
                {/* Modals & Overlays */}
                {showInstallModal && <InstallModal onInstall={handleInstallClick} onClose={()=>setShowInstallModal(false)} hasNativePrompt={!!deferredPrompt} isIOS={/iPhone|iPad|iPod/.test(navigator.userAgent)} />}
                {showInterstitial && (
                    <div className="fixed inset-0 z-[999] bg-black flex flex-col items-center justify-center p-4">
                        <div className="bg-[#202020] p-1 rounded-lg w-full max-w-sm aspect-square"><AdBanner className="w-full h-full" /></div>
                        <div className="mt-4 text-white text-sm">{interstitialTimer>0 ? `Anúncio em ${interstitialTimer}s` : <button onClick={()=>setShowInterstitial(false)} className="bg-white text-black px-6 py-2 rounded-full font-bold">Fechar</button>}</div>
                    </div>
                )}
            </div>
        );
      }

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>