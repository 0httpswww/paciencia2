<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>JoGos Online</title>
    <meta name="description" content="JoGos Online - Arcade, Racing & Learning.">
    <meta name="theme-color" content="#050505">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png">
    
    <!-- Monetag Popunder Script -->
    <script src="https://quge5.com/88/tag.min.js" data-zone="187944" async data-cfasync="false"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { 
            overscroll-behavior: none; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent; 
            font-family: 'Courier New', Courier, monospace;
            background-color: #050505;
            /* Grid Background */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            color: white; 
            user-select: none; 
            -webkit-user-select: none; 
            overflow: hidden;
        }

        /* Dark Futuristic Professional Title */
        .neon-title {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-weight: 900;
            background: linear-gradient(180deg, #e2e8f0 0%, #94a3b8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 
                0 0 20px rgba(148, 163, 184, 0.3);
            filter: drop-shadow(0 0 2px rgba(148, 163, 184, 0.5));
            letter-spacing: -2px;
            text-transform: uppercase;
        }

        .neon-text-small {
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        /* White Glow for Menu Items */
        .glass-box {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }
        .glass-box:hover {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.02);
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
        "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
      }
    }
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js').then(function(registration) {
                    console.log('ServiceWorker registration successful');
                }, function(err) {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</head>
<body>
    <div id="root" class="h-[100dvh] w-full overflow-hidden flex flex-col"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
      import { createRoot } from 'react-dom/client';
      import { Expand, Shrink, RefreshCw, Rocket, ChevronLeft, Shield, Zap, Car, Languages, Heart, Star, CheckCircle, XCircle, Volume2 } from 'lucide-react';

      // --- Sound System (Synthesized & Safe) ---
      // Lazy initialization to avoid "Script error" or blocking warnings
      let audioContext = null;

      const getAudioContext = () => {
          if (!audioContext) {
              const AudioCtx = window.AudioContext || window.webkitAudioContext;
              if (AudioCtx) {
                  audioContext = new AudioCtx();
              }
          }
          return audioContext;
      };

      const playSound = (type, pitchMod = 0) => {
          const ctx = getAudioContext();
          if (!ctx) return;
          if (ctx.state === 'suspended') ctx.resume().catch(() => {});

          const osc = ctx.createOscillator();
          const gainNode = ctx.createGain();
          osc.connect(gainNode);
          gainNode.connect(ctx.destination);

          const now = ctx.currentTime;

          switch(type) {
              case 'shoot':
                  osc.type = 'square';
                  osc.frequency.setValueAtTime(880, now);
                  osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'laser':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(1200, now);
                  osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
                  osc.start(now);
                  osc.stop(now + 0.15);
                  break;
              case 'enemy_shoot':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(400, now);
                  osc.frequency.linearRampToValueAtTime(200, now + 0.1);
                  gainNode.gain.setValueAtTime(0.03, now);
                  gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'explosion':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(100, now);
                  osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                  osc.start(now);
                  osc.stop(now + 0.5);
                  break;
              case 'engine':
                  // Continuous sound managed differently, this is just a burst
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(100 + pitchMod, now);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'drift':
                  osc.type = 'triangle';
                  osc.frequency.setValueAtTime(800, now);
                  osc.frequency.linearRampToValueAtTime(600, now + 0.2);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                  osc.start(now);
                  osc.stop(now + 0.2);
                  break;
              case 'correct':
                  osc.type = 'sine';
                  osc.frequency.setValueAtTime(600, now);
                  osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                  osc.start(now);
                  osc.stop(now + 0.2);
                  break;
              case 'wrong':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(200, now);
                  osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                  osc.start(now);
                  osc.stop(now + 0.3);
                  break;
              case 'powerup':
                  osc.type = 'sine';
                  osc.frequency.setValueAtTime(400, now);
                  osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                  osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                  osc.start(now);
                  osc.stop(now + 0.2);
                  break;
          }
      };

      const speakText = (text) => {
          if ('speechSynthesis' in window) {
               window.speechSynthesis.cancel();
               const utterance = new SpeechSynthesisUtterance(text);
               utterance.lang = 'en-US';
               utterance.rate = 0.9;
               window.speechSynthesis.speak(utterance);
          }
      };

      // --- LinguaQuest (Duolingo Style) ---
      const LinguaQuest = ({ onBack, triggerAd }) => {
          // Move lessons outside to prevent regeneration on render
          const lessonsData = useMemo(() => [
              { id: 1, type: 'translate', q: 'The cat eats fish', a: ['O gato come peixe', 'O cachorro bebe agua', 'O passaro voa'], correct: 0 },
              { id: 2, type: 'listen', q: 'Hello, how are you?', a: ['Ola, como vai voce?', 'Adeus, ate logo', 'Bom dia, amigo'], correct: 0, text: 'Hello, how are you?' },
              { id: 3, type: 'translate', q: 'Where is the library?', a: ['Onde fica a biblioteca?', 'Onde esta o livro?', 'Eu gosto de ler'], correct: 0 },
              { id: 4, type: 'translate', q: 'I like to play soccer', a: ['Eu gosto de jogar futebol', 'Eu gosto de comer', 'Eu nao gosto de esporte'], correct: 0 },
              { id: 5, type: 'listen', q: 'Good morning', a: ['Bom dia', 'Boa noite', 'Boa tarde'], correct: 0, text: 'Good morning' },
              { id: 6, type: 'translate', q: 'My car is blue', a: ['Meu carro e azul', 'Minha casa e azul', 'O ceu e azul'], correct: 0 },
          ], []);

          const [currentLesson, setCurrentLesson] = useState(0);
          const [hearts, setHearts] = useState(5);
          const [xp, setXp] = useState(0);
          const [streak, setStreak] = useState(1);
          const [status, setStatus] = useState('playing'); // playing, correct, wrong, completed, failed
          const [selectedOption, setSelectedOption] = useState(null);

          const handleCheck = () => {
              if (selectedOption === null) return;
              
              const lesson = lessonsData[currentLesson];
              if (selectedOption === lesson.correct) {
                  setStatus('correct');
                  playSound('correct');
                  setXp(p => p + 10);
              } else {
                  setStatus('wrong');
                  playSound('wrong');
                  setHearts(h => h - 1);
              }
          };

          const handleNext = () => {
              if (hearts <= 0) {
                  setStatus('failed');
                  return;
              }
              if (currentLesson < lessonsData.length - 1) {
                  setCurrentLesson(p => p + 1);
                  setStatus('playing');
                  setSelectedOption(null);
              } else {
                  setStatus('completed');
                  triggerAd();
              }
          };

          const restart = () => {
              setCurrentLesson(0);
              setHearts(5);
              setStatus('playing');
              setSelectedOption(null);
              triggerAd();
          };

          const lesson = lessonsData[currentLesson];

          if (status === 'completed') {
              return (
                  <div className="w-full h-full flex flex-col items-center justify-center bg-[#111] text-white p-6">
                      <Star size={64} className="text-yellow-400 mb-4 animate-bounce" />
                      <h2 className="text-3xl font-bold mb-2 neon-text-small">Lesson Complete!</h2>
                      <p className="text-gray-400 mb-8">+50 XP Earned</p>
                      <button onClick={restart} className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transform transition hover:scale-105">
                          Continue
                      </button>
                  </div>
              );
          }

          if (status === 'failed') {
               return (
                  <div className="w-full h-full flex flex-col items-center justify-center bg-[#111] text-white p-6">
                      <Heart size={64} className="text-red-500 mb-4 animate-pulse" />
                      <h2 className="text-3xl font-bold mb-2">Out of Hearts!</h2>
                      <p className="text-gray-400 mb-8">Don't give up, try again.</p>
                      <button onClick={restart} className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full shadow-lg">
                          Try Again
                      </button>
                  </div>
              );
          }

          return (
              <div className="w-full h-full flex flex-col bg-[#111] text-white">
                  {/* Header */}
                  <div className="flex items-center justify-between p-4 border-b border-gray-800">
                      <button onClick={onBack}><XCircle className="text-gray-400" /></button>
                      <div className="flex-1 mx-4 bg-gray-700 h-3 rounded-full overflow-hidden">
                          <div 
                              className="bg-green-500 h-full transition-all duration-500" 
                              style={{ width: `${((currentLesson) / lessonsData.length) * 100}%` }}
                          ></div>
                      </div>
                      <div className="flex items-center gap-1 text-red-500">
                          <Heart fill="currentColor" size={20} />
                          <span className="font-bold">{hearts}</span>
                      </div>
                  </div>

                  {/* Content */}
                  <div className="flex-1 flex flex-col items-center justify-center p-6 max-w-lg mx-auto w-full">
                      <h2 className="text-2xl font-bold mb-8 text-center">
                          {lesson.type === 'translate' ? 'Translate this sentence' : 'Listen and select'}
                      </h2>

                      {lesson.type === 'listen' && (
                          <button 
                              onClick={() => speakText(lesson.text)}
                              className="mb-8 p-6 bg-blue-500/20 border-2 border-blue-500 rounded-2xl hover:bg-blue-500/30 transition"
                          >
                              <Volume2 size={48} className="text-blue-400" />
                          </button>
                      )}

                      {lesson.type === 'translate' && (
                          <div className="mb-8 p-4 border border-gray-600 rounded-xl flex items-center gap-3">
                              {/* Character Avatar */}
                              <div className="w-12 h-12 bg-green-500 rounded-full flex items-center justify-center font-bold text-2xl text-black">D</div>
                              <div className="bg-gray-800 p-3 rounded-xl rounded-tl-none border border-gray-700">
                                  {lesson.q}
                              </div>
                          </div>
                      )}

                      <div className="w-full grid gap-3">
                          {lesson.a.map((option, idx) => (
                              <button
                                  key={idx}
                                  onClick={() => status === 'playing' && setSelectedOption(idx)}
                                  disabled={status !== 'playing'}
                                  className={`p-4 rounded-xl border-2 text-left transition-all transform ${
                                      selectedOption === idx 
                                          ? 'border-blue-500 bg-blue-500/20' 
                                          : 'border-gray-700 hover:bg-gray-800'
                                  }`}
                              >
                                  {option}
                              </button>
                          ))}
                      </div>
                  </div>

                  {/* Footer */}
                  <div className={`p-4 border-t ${status === 'correct' ? 'bg-green-900/30 border-green-500' : (status === 'wrong' ? 'bg-red-900/30 border-red-500' : 'border-gray-800')}`}>
                      <div className="max-w-lg mx-auto flex items-center justify-between">
                          {status === 'correct' && (
                              <div className="flex items-center gap-2 text-green-400 font-bold">
                                  <CheckCircle size={32} />
                                  <div className="flex flex-col">
                                      <span>Correct!</span>
                                  </div>
                              </div>
                          )}
                          {status === 'wrong' && (
                              <div className="flex items-center gap-2 text-red-400 font-bold">
                                  <XCircle size={32} />
                                  <div className="flex flex-col">
                                      <span>Correct answer:</span>
                                      <span className="text-sm font-normal text-white">{lesson.a[lesson.correct]}</span>
                                  </div>
                              </div>
                          )}
                          {status === 'playing' ? (
                              <button 
                                  onClick={handleCheck}
                                  disabled={selectedOption === null}
                                  className={`w-full py-3 rounded-xl font-bold transition ${selectedOption !== null ? 'bg-green-500 text-white hover:bg-green-600' : 'bg-gray-700 text-gray-500'}`}
                              >
                                  CHECK
                              </button>
                          ) : (
                              <button 
                                  onClick={handleNext}
                                  className={`ml-auto px-8 py-3 rounded-xl font-bold text-white transition ${status === 'correct' ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'}`}
                              >
                                  CONTINUE
                              </button>
                          )}
                      </div>
                  </div>
              </div>
          );
      };

      // --- Neon Racer Game (Top Gear Style) ---
      const NeonRacer = ({ onBack, triggerAd }) => {
          const canvasRef = useRef(null);
          const requestRef = useRef();
          
          const gameState = useRef({
              speed: 0,
              maxSpeed: 250,
              position: 0,
              playerX: 0,
              score: 0,
              segments: [],
              roadWidth: 2000,
              segmentLength: 200,
              trackLength: 0,
              fov: 100,
              cameraHeight: 1000,
              cameraDepth: 0.84, // 1 / Math.tan((fov / 2) * Math.PI / 180)
              colors: {
                  light: { road: '#333', grass: '#111', rumble: '#555', lane: '#CCCCCC' },
                  dark: { road: '#222', grass: '#050505', rumble: '#BBBBBB', lane: '#000000' } // lane hidden
              },
              keys: { left: false, right: false, up: false, down: false },
              bgOffset: 0,
              lap: 1,
              totalLaps: 3
          });

          // Generate Track
          useEffect(() => {
              const g = gameState.current;
              g.segments = [];
              const addSegment = (curve) => {
                  const n = g.segments.length;
                  g.segments.push({
                      index: n,
                      p1: { world: { y: 0, z: n * g.segmentLength }, camera: {}, screen: {} },
                      p2: { world: { y: 0, z: (n + 1) * g.segmentLength }, camera: {}, screen: {} },
                      curve: curve,
                      color: Math.floor(n / 3) % 2 ? g.colors.dark : g.colors.light
                  });
              };
              
              // Build road structure
              for(let i=0; i<500; i++) addSegment(0); // Start straight
              for(let i=0; i<400; i++) addSegment(i < 200 ? 2 : -2); // S curve
              for(let i=0; i<400; i++) addSegment(i < 200 ? -2 : 2); // S curve
              for(let i=0; i<200; i++) addSegment(0); // Straight
              for(let i=0; i<600; i++) addSegment(i < 300 ? -3 : 3); // Hard turn
              for(let i=0; i<200; i++) addSegment(0); // Finish straight

              g.trackLength = g.segments.length * g.segmentLength;
          }, []);

          // Projection math
          const project = (p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) => {
              p.camera.x = (p.world.x || 0) - cameraX;
              p.camera.y = (p.world.y || 0) - cameraY;
              p.camera.z = (p.world.z || 0) - cameraZ; // World Z - Camera Z
              
              // If behind camera
              if (p.camera.z <= 0) return;

              p.screen.scale = cameraDepth / p.camera.z;
              p.screen.x = Math.round((width / 2) + (p.screen.scale * p.camera.x * width / 2));
              p.screen.y = Math.round((height / 2) - (p.screen.scale * p.camera.y * height / 2));
              p.screen.w = Math.round(p.screen.scale * roadWidth * width / 2);
          };

          const renderPolygon = (ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) => {
              ctx.fillStyle = color;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.lineTo(x3, y3);
              ctx.lineTo(x4, y4);
              ctx.closePath();
              ctx.fill();
          };

          const update = (dt) => {
              const g = gameState.current;
              const playerSegment = g.segments[Math.floor(g.position / g.segmentLength) % g.segments.length];
              const speedPercent = g.speed / g.maxSpeed;
              const dx = dt * 2 * speedPercent; 

              g.position = (g.position + dt * g.speed) % g.trackLength;
              
              // Controls
              if (g.keys.left) g.playerX -= dx;
              else if (g.keys.right) g.playerX += dx;

              g.playerX -= (dx * speedPercent * playerSegment.curve * 2); // Centrifugal

              if (g.keys.up) g.speed += 100 * dt; // Accel
              else if (g.keys.down) g.speed -= 300 * dt; // Brake
              else g.speed -= 50 * dt; // Decel

              g.playerX = Math.max(-2, Math.min(2, g.playerX));
              g.speed = Math.max(0, Math.min(g.maxSpeed, g.speed));
              
              // Engine Sound Loop trigger
              if (g.speed > 10 && Math.random() < 0.1) playSound('engine', g.speed / 2);
              if (Math.abs(playerSegment.curve) > 1 && g.speed > 150 && Math.random() < 0.1) playSound('drift');

              g.bgOffset = (g.bgOffset + playerSegment.curve * speedPercent) % 1000;
          };

          const draw = (ctx, width, height) => {
              const g = gameState.current;
              
              // Clear
              ctx.fillStyle = '#050505'; // Sky
              ctx.fillRect(0, 0, width, height);
              
              // Draw Mountains/Sky (Simple parallax)
              ctx.fillStyle = '#1a0b2e'; // Dark mountain
              ctx.beginPath();
              ctx.moveTo(0, height/2);
              for(let i=0; i<=width; i+=50) {
                  ctx.lineTo(i, (height/2) - 50 - Math.sin((i + g.bgOffset)/100)*30);
              }
              ctx.lineTo(width, height/2);
              ctx.fill();

              // Render Road
              let baseSegment = g.segments[Math.floor(g.position / g.segmentLength) % g.segments.length];
              let basePercent = (g.position % g.segmentLength) / g.segmentLength;
              let playerX = g.playerX * g.roadWidth;
              let dx = -(baseSegment.curve * basePercent);
              let x = 0;
              let maxY = height;

              for(let n=0; n<300; n++) {
                  let id = (baseSegment.index + n) % g.segments.length;
                  let segment = g.segments[id];
                  let loop = Math.floor((baseSegment.index + n) / g.segments.length);
                  
                  // Project P1
                  segment.p1.world.x = x - playerX - dx;
                  segment.p1.world.z = (n * g.segmentLength) + (loop * g.trackLength) - (g.position % g.segmentLength); // Relative Z
                  project(segment.p1, 0, g.cameraHeight, 0, g.cameraDepth, width, height, g.roadWidth);

                  // Project P2
                  x += dx;
                  dx += segment.curve;
                  segment.p2.world.x = x - playerX - dx;
                  segment.p2.world.z = ((n+1) * g.segmentLength) + (loop * g.trackLength) - (g.position % g.segmentLength);
                  project(segment.p2, 0, g.cameraHeight, 0, g.cameraDepth, width, height, g.roadWidth);

                  if (segment.p1.camera.z <= 0 || segment.p2.screen.y >= maxY || segment.p2.screen.y >= segment.p1.screen.y) continue;

                  renderPolygon(ctx, 
                      segment.p1.screen.x - segment.p1.screen.w, segment.p1.screen.y,
                      segment.p1.screen.x + segment.p1.screen.w, segment.p1.screen.y,
                      segment.p2.screen.x + segment.p2.screen.w, segment.p2.screen.y,
                      segment.p2.screen.x - segment.p2.screen.w, segment.p2.screen.y,
                      segment.color.grass
                  );
                  renderPolygon(ctx, 
                      segment.p1.screen.x - segment.p1.screen.w * 0.8, segment.p1.screen.y,
                      segment.p1.screen.x + segment.p1.screen.w * 0.8, segment.p1.screen.y,
                      segment.p2.screen.x + segment.p2.screen.w * 0.8, segment.p2.screen.y,
                      segment.p2.screen.x - segment.p2.screen.w * 0.8, segment.p2.screen.y,
                      segment.color.rumble
                  );
                  renderPolygon(ctx, 
                      segment.p1.screen.x - segment.p1.screen.w * 0.7, segment.p1.screen.y,
                      segment.p1.screen.x + segment.p1.screen.w * 0.7, segment.p1.screen.y,
                      segment.p2.screen.x + segment.p2.screen.w * 0.7, segment.p2.screen.y,
                      segment.p2.screen.x - segment.p2.screen.w * 0.7, segment.p2.screen.y,
                      segment.color.road
                  );
                  
                  maxY = segment.p1.screen.y;
              }

              // Draw Player Car
              const carW = width * 0.3;
              const carH = carW * 0.5;
              const carX = width / 2 - carW / 2;
              const carY = height - carH - 20;

              // Car Body
              ctx.fillStyle = '#ff0055';
              ctx.shadowColor = '#ff0055';
              ctx.shadowBlur = 20;
              ctx.fillRect(carX, carY + carH/2, carW, carH/2); // Bumper
              ctx.beginPath(); // Cabin
              ctx.moveTo(carX + carW*0.1, carY + carH/2);
              ctx.lineTo(carX + carW*0.2, carY);
              ctx.lineTo(carX + carW*0.8, carY);
              ctx.lineTo(carX + carW*0.9, carY + carH/2);
              ctx.fill();

              // Tail Lights
              ctx.fillStyle = '#ffaaaa';
              ctx.shadowBlur = 10;
              ctx.fillRect(carX + carW*0.1, carY + carH*0.6, carW*0.15, carH*0.15);
              ctx.fillRect(carX + carW*0.75, carY + carH*0.6, carW*0.15, carH*0.15);
              ctx.shadowBlur = 0;

              // Dashboard
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(10, 10, 120, 40);
              ctx.fillStyle = '#0ff';
              ctx.font = '20px Courier';
              ctx.fillText(`${Math.floor(g.speed)} km/h`, 20, 35);
          };

          useEffect(() => {
              const canvas = canvasRef.current;
              let lastTime = Date.now();
              
              // Handle input
              const down = (e) => {
                  switch(e.key) {
                      case 'ArrowLeft': gameState.current.keys.left = true; break;
                      case 'ArrowRight': gameState.current.keys.right = true; break;
                      case 'ArrowUp': gameState.current.keys.up = true; break;
                      case 'ArrowDown': gameState.current.keys.down = true; break;
                  }
              };
              const up = (e) => {
                  switch(e.key) {
                      case 'ArrowLeft': gameState.current.keys.left = false; break;
                      case 'ArrowRight': gameState.current.keys.right = false; break;
                      case 'ArrowUp': gameState.current.keys.up = false; break;
                      case 'ArrowDown': gameState.current.keys.down = false; break;
                  }
              };

              // Touch controls
              const tStart = (e) => {
                  e.preventDefault();
                  const x = e.touches[0].clientX;
                  const w = window.innerWidth;
                  if (x < w/3) gameState.current.keys.left = true;
                  else if (x > w*2/3) gameState.current.keys.right = true;
                  else gameState.current.keys.up = true;
              };
              const tEnd = () => {
                   gameState.current.keys.left = false;
                   gameState.current.keys.right = false;
                   gameState.current.keys.up = false;
              };

              window.addEventListener('keydown', down);
              window.addEventListener('keyup', up);
              canvas.addEventListener('touchstart', tStart, {passive: false});
              canvas.addEventListener('touchend', tEnd);

              // Resize handler
              const handleResize = () => {
                 if (canvas && canvas.parentElement) {
                     canvas.width = canvas.parentElement.clientWidth;
                     canvas.height = canvas.parentElement.clientHeight;
                 }
              };
              window.addEventListener('resize', handleResize);
              handleResize();

              const loop = () => {
                  const now = Date.now();
                  const dt = Math.min(1, (now - lastTime) / 1000);
                  lastTime = now;
                  
                  update(dt);
                  if (canvas) draw(canvas.getContext('2d'), canvas.width, canvas.height);
                  requestRef.current = requestAnimationFrame(loop);
              };
              requestRef.current = requestAnimationFrame(loop);

              return () => {
                  window.removeEventListener('keydown', down);
                  window.removeEventListener('keyup', up);
                  window.removeEventListener('resize', handleResize);
                  cancelAnimationFrame(requestRef.current);
              };
          }, []);

          return (
              <div className="w-full h-full relative">
                  <canvas ref={canvasRef} className="block w-full h-full" />
                  <div className="absolute top-4 left-4">
                      <button onClick={onBack} className="p-3 bg-black/50 text-white rounded-full"><ChevronLeft /></button>
                  </div>
                  <div className="absolute bottom-10 w-full text-center text-white/50 text-sm pointer-events-none">
                      Tap Sides to Turn â€¢ Center to Accel
                  </div>
              </div>
          );
      };

      // --- Galaxy Invader Game Component (Updated) ---
      const GalaxyInvader = ({ onBack, triggerAd }) => {
          const canvasRef = useRef(null);
          const game = useRef({
              player: { 
                  x: 0, y: 0, w: 40, h: 40, 
                  health: 100, maxHealth: 100, 
                  weaponLevel: 1, 
                  shieldActive: false,
                  shieldTimer: 0,
                  damageMultiplier: 1,
                  lastShot: 0,
                  shootAngle: 0, // For Spiral/Wave patterns
              },
              bullets: [],
              enemies: [],
              powerups: [],
              boss: null,
              particles: [],
              stars: [],
              score: 0,
              level: 1,
              nextBossThreshold: 5000,
              gameState: 'menu',
              width: 0,
              height: 0,
          });
          const [gameOver, setGameOver] = useState(false);

          const initGame = useCallback(() => {
              const canvas = canvasRef.current;
              const g = game.current;
              g.width = canvas.width;
              g.height = canvas.height;
              g.player.x = g.width / 2 - g.player.w / 2;
              g.player.y = g.height - 100;
              g.player.health = 100;
              g.player.weaponLevel = 1;
              g.player.shieldActive = false;
              g.player.shieldTimer = 0;
              g.score = 0;
              g.level = 1;
              g.nextBossThreshold = 5000;
              g.bullets = [];
              g.enemies = [];
              g.powerups = [];
              g.boss = null;
              g.particles = [];
              g.gameState = 'playing';
              setGameOver(false);
              
              g.stars = [];
              for(let i=0; i<80; i++) {
                  g.stars.push({
                      x: Math.random() * g.width,
                      y: Math.random() * g.height,
                      size: Math.random() * 2,
                      speed: Math.random() * 3 + 0.5
                  });
              }
          }, []);

          const spawnPowerup = (x, y) => {
              if (Math.random() < 0.35) { 
                  const type = Math.random() < 0.8 ? 'weapon' : 'shield';
                  game.current.powerups.push({
                      x, y, w: 20, h: 20, type,
                      vy: 2
                  });
              }
          };

          const getClosestEnemy = (x, y) => {
              const g = game.current;
              let closest = null;
              let minDist = Infinity;
              const targets = g.boss ? [g.boss] : g.enemies;
              
              targets.forEach(e => {
                  const dx = e.x - x;
                  const dy = e.y - y;
                  const dist = Math.sqrt(dx*dx + dy*dy);
                  if (dist < minDist) {
                      minDist = dist;
                      closest = e;
                  }
              });
              return closest;
          };

          const spawnEnemy = useCallback(() => {
              const g = game.current;
              if (g.gameState !== 'playing') return;

              if (Math.random() < 0.02 + g.level * 0.003) {
                  const rand = Math.random();
                  let type = 'basic';
                  let health = 1 + Math.floor(g.level * 0.5);
                  let w = 30, h = 30;
                  
                  if (rand > 0.95 && g.level > 3) { type = 'bomber'; health *= 5; w=45; h=40; } 
                  else if (rand > 0.9 && g.level > 2) { type = 'tank'; health *= 3; w=40; h=40; } 
                  else if (rand > 0.8 && g.level > 1) { type = 'seeker'; health *= 1.5; w=25; h=25; } 
                  else if (rand > 0.7 && g.level > 3) { type = 'ufo'; health *= 2; w=35; h=35; } 
                  else if (rand > 0.6 && g.level > 2) { type = 'swarmer'; health = 1; w=20; h=20; } 
                  else if (rand > 0.5) { type = 'shooter'; health *= 1.5; }

                  g.enemies.push({ 
                      x: Math.random() * (g.width - w), 
                      y: -40, w, h, 
                      type, health, maxHealth: health,
                      vx: type === 'seeker' ? 0 : (type === 'ufo' ? Math.cos(Date.now()/500)*3 : (type === 'swarmer' ? 5 : 0)),
                      vy: type === 'seeker' ? 3 : (type === 'tank' || type === 'bomber' ? 1 : (type === 'swarmer' ? 4 : 2)),
                      lastShot: Date.now() + Math.random() * 1000,
                      swayOffset: Math.random() * 10
                  });
              }
          }, []);

          const spawnBoss = useCallback(() => {
              const g = game.current;
              g.gameState = 'boss';
              g.enemies = []; 
              g.boss = {
                  x: g.width / 2 - 60, y: -120, w: 120, h: 100,
                  health: 200 * g.level, maxHealth: 200 * g.level,
                  phase: 1, lastShot: Date.now(), moveDir: 1,
                  attackType: 0
              };
          }, []);

          const update = useCallback(() => {
              const g = game.current;
              const now = Date.now();

              g.stars.forEach(s => {
                  s.y += s.speed;
                  if (s.y > g.height) { s.y = 0; s.x = Math.random() * g.width; }
              });

              if (g.player.shieldActive) {
                  g.player.shieldTimer -= 16;
                  if (g.player.shieldTimer <= 0) {
                      g.player.shieldActive = false;
                      g.player.damageMultiplier = 1;
                  }
              }

              if (g.gameState === 'playing' || g.gameState === 'boss') {
                  // Player Bullets
                  g.bullets.forEach(b => {
                      // Apply Movement
                      if (b.behavior === 'homing') {
                          // Homing Logic
                          const target = getClosestEnemy(b.x, b.y);
                          if (target) {
                              const angle = Math.atan2((target.y + target.h/2) - b.y, (target.x + target.w/2) - b.x);
                              b.vx = b.vx * 0.95 + Math.cos(angle) * 1;
                              b.vy = b.vy * 0.95 + Math.sin(angle) * 1;
                          }
                          b.x += b.vx * 8;
                          b.y += b.vy * 8;
                      } else if (b.behavior === 'bounce') {
                          // Bouncing Logic
                          b.x += b.vx;
                          b.y += b.vy;
                          if (b.x <= 0 || b.x >= g.width) b.vx *= -1;
                      } else if (b.behavior === 'curve') {
                           b.vx += Math.sin(now / 100) * 0.5;
                           b.x += b.vx;
                           b.y += b.vy;
                      } else if (b.behavior === 'split') {
                          b.x += b.vx;
                          b.y += b.vy;
                          b.dist += Math.abs(b.vy);
                          if (b.dist > 200 && !b.split) {
                              b.hit = true; // Kill parent
                              // Spawn children
                              for(let i=-1; i<=1; i++) {
                                   g.bullets.push({x: b.x, y: b.y, w: 6, h: 6, owner: 'player', vx: i*3, vy: -10, color: '#f0f', dmg: 1});
                              }
                          }
                      } else {
                          // Standard
                          if (b.vx !== undefined) b.x += b.vx;
                          if (b.vy !== undefined) b.y += b.vy;
                      }
                  });
                  
                  // Cleanup bullets
                  g.bullets = g.bullets.filter(b => b.y > -100 && b.y < g.height + 50 && b.x > -50 && b.x < g.width + 50 && !b.hit);

                  // Enemies
                  g.enemies.forEach(e => {
                      if (e.type === 'seeker') {
                          const dx = (g.player.x + g.player.w/2) - (e.x + e.w/2);
                          e.vx = dx * 0.02;
                      } else if (e.type === 'ufo') {
                          e.vx = Math.sin(now / 300) * 3;
                      } else if (e.type === 'swarmer') {
                          e.vx = Math.sin((now / 200) + e.swayOffset) * 5;
                      }

                      e.x += e.vx;
                      e.y += e.vy;
                      
                      // Bounce checks
                      if (e.type !== 'ufo' && e.type !== 'swarmer' && (e.x <= 0 || e.x + e.w >= g.width)) e.vx *= -1;
                      if (e.type === 'swarmer' && (e.x <= 0 || e.x + e.w >= g.width)) e.x = Math.max(0, Math.min(g.width - e.w, e.x));

                      // Enemy Shooting
                      if (now - e.lastShot > 1500) {
                          if (e.type === 'bomber') {
                              g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 12, h: 12, owner: 'enemy', vx: 0, vy: 4, color: '#fb923c'});
                              e.lastShot = now;
                          } else if (e.type === 'ufo') {
                              playSound('enemy_shoot');
                              for(let i=0; i<4; i++) {
                                  const angle = (now/1000) + (i * Math.PI/2);
                                  g.bullets.push({x: e.x+e.w/2, y: e.y+e.h/2, w: 6, h: 6, owner: 'enemy', vx: Math.cos(angle)*3, vy: Math.sin(angle)*3, color: '#a855f7'});
                              }
                              e.lastShot = now;
                          } else if (e.type === 'tank') {
                               playSound('enemy_shoot');
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 8, h: 8, owner: 'enemy', vx: -2, vy: 3, color: '#f87171'});
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 8, h: 8, owner: 'enemy', vx: 2, vy: 3, color: '#f87171'});
                               e.lastShot = now;
                          } else if (e.type === 'shooter') {
                               playSound('enemy_shoot');
                               const dx = (g.player.x + g.player.w/2) - (e.x + e.w/2);
                               const dy = (g.player.y + g.player.h/2) - (e.y + e.h/2);
                               const angle = Math.atan2(dy, dx);
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 6, h: 6, owner: 'enemy', vx: Math.cos(angle)*4, vy: Math.sin(angle)*4, color: '#fbbf24'});
                               e.lastShot = now;
                          }
                      }
                  });
                  g.enemies = g.enemies.filter(e => e.y < g.height);

                  // Powerups
                  g.powerups.forEach(p => p.y += p.vy);
                  g.powerups = g.powerups.filter(p => p.y < g.height && !p.collected);

                  // Boss Logic
                  if (g.boss) {
                      const boss = g.boss;
                      if (boss.y < 50) boss.y += 1;
                      boss.x += boss.moveDir * (1 + g.level * 0.2);
                      if (boss.x <= 0 || boss.x + boss.w >= g.width) boss.moveDir *= -1;

                      if (now - boss.lastShot > 800) {
                          playSound('enemy_shoot');
                          boss.attackType = (boss.attackType + 1) % 3;
                          if (boss.attackType === 0) {
                              for(let i=0; i<12; i++) {
                                  const angle = (i / 12) * Math.PI * 2;
                                  g.bullets.push({x: boss.x + boss.w/2, y: boss.y + boss.h/2, w: 8, h: 8, owner: 'enemy', vx: Math.cos(angle)*4, vy: Math.sin(angle)*4, color: '#ef4444'});
                              }
                          } else if (boss.attackType === 1) {
                              g.bullets.push({x: boss.x+20, y: boss.y+boss.h, w:8, h:15, owner:'enemy', vx:0, vy:5, color:'#f00'});
                              g.bullets.push({x: boss.x+boss.w-20, y: boss.y+boss.h, w:8, h:15, owner:'enemy', vx:0, vy:5, color:'#f00'});
                          }
                          boss.lastShot = now;
                      }
                  }

                  // Collisions
                  g.bullets.forEach(b => {
                      if (b.owner === 'player') {
                          g.enemies.forEach(e => {
                              if (!b.hit && rectIntersect(b, e)) {
                                  if (b.behavior !== 'beam') b.hit = true; // Beams pierce
                                  e.health -= (b.dmg || 1) * g.player.damageMultiplier;
                                  createExplosion(b.x, b.y, '#fb923c', 3);
                                  if(e.health <= 0) {
                                      g.score += 100;
                                      createExplosion(e.x + e.w/2, e.y + e.h/2, '#fdba74', 10);
                                      playSound('explosion');
                                      spawnPowerup(e.x, e.y);
                                  }
                              }
                          });
                          if (g.boss && !b.hit && rectIntersect(b, g.boss)) {
                              if (b.behavior !== 'beam') b.hit = true;
                              g.boss.health -= (b.dmg || 1) * g.player.damageMultiplier;
                              createExplosion(b.x, b.y, '#f87171', 5);
                              if (g.boss.health <= 0) {
                                  playSound('explosion');
                                  g.score += 5000;
                                  g.gameState = 'level-up';
                                  g.boss = null;
                                  g.nextBossThreshold += 5000;
                                  setTimeout(() => { g.level++; g.gameState = 'playing'; }, 3000);
                              }
                          }
                      } else { 
                          if (!b.hit && rectIntersect(b, g.player)) {
                              b.hit = true;
                              if (!g.player.shieldActive) {
                                  g.player.health -= 10;
                                  playSound('hit');
                                  createExplosion(g.player.x, g.player.y, '#ef4444', 10);
                                  if (g.player.health <= 0) {
                                      g.gameState = 'game-over';
                                      playSound('explosion');
                                      setGameOver(true);
                                  }
                              }
                          }
                      }
                  });

                  g.powerups.forEach(p => {
                      if (!p.collected && rectIntersect(p, g.player)) {
                          p.collected = true;
                          playSound('powerup');
                          if (p.type === 'weapon') g.player.weaponLevel = Math.min(10, g.player.weaponLevel + 1); // Cap at 10
                          else if (p.type === 'shield') {
                              g.player.shieldActive = true;
                              g.player.shieldTimer = 10000; 
                              g.player.damageMultiplier = 5; 
                          }
                      }
                  });

                  g.enemies = g.enemies.filter(e => e.health > 0);
                  if (g.score >= g.nextBossThreshold && !g.boss && g.gameState === 'playing') spawnBoss();
              }

              g.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
              g.particles = g.particles.filter(p => p.life > 0);

              spawnEnemy();
          }, [spawnEnemy, spawnBoss, initGame]);

          const rectIntersect = (r1, r2) => {
              return !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x || r2.y > r1.y + r1.h || r2.y + r2.h < r1.y);
          };

          const createExplosion = (x, y, color, count = 20) => {
              for (let i = 0; i < count; i++) {
                  game.current.particles.push({
                      x, y,
                      vx: (Math.random() - 0.5) * 6,
                      vy: (Math.random() - 0.5) * 6,
                      life: Math.random() * 20 + 10,
                      color
                  });
              }
          };

          const firePlayerWeapon = (g) => {
              const { x, y, w, weaponLevel, shieldActive } = g.player;
              const cx = x + w / 2;
              
              // --- Special Shield: Chaos Blossom ---
              if (shieldActive) {
                  playSound('laser', 0.5); 
                  // Concentrated Beam Center
                  g.bullets.push({ x: cx - 6, y: y, w: 12, h: 50, owner: 'player', vy: -25, color: '#facc15', dmg: 5, behavior: 'beam', glow: true });
                  
                  // Radial Pulse
                  const numBullets = 20;
                  for (let i = 0; i < numBullets; i++) {
                     const angle = (i / numBullets) * Math.PI * 2;
                     g.bullets.push({
                         x: cx, y: y + 20, w: 6, h: 6,
                         owner: 'player',
                         vx: Math.cos(angle) * 12,
                         vy: Math.sin(angle) * 12,
                         color: '#ffff00',
                         dmg: 3
                     });
                  }
                  return;
              }

              g.player.shootAngle += 0.2; // Increment for spiral/wave patterns

              playSound('shoot');

              // --- Weapon Levels 1-10 ---
              switch(weaponLevel) {
                  case 1: // Classic
                      g.bullets.push({ x: cx - 2, y, w: 4, h: 12, owner: 'player', vy: -12, color: '#67e8f9', dmg: 1 });
                      break;
                  case 2: // Cone (Fan)
                      g.bullets.push({ x: cx, y, w: 4, h: 12, owner: 'player', vy: -12, color: '#38bdf8', dmg: 1 });
                      g.bullets.push({ x: cx, y, w: 4, h: 12, owner: 'player', vx: -3, vy: -11, color: '#38bdf8', dmg: 1 });
                      g.bullets.push({ x: cx, y, w: 4, h: 12, owner: 'player', vx: 3, vy: -11, color: '#38bdf8', dmg: 1 });
                      break;
                  case 3: // Bouncing
                      g.bullets.push({ x: cx - 10, y, w: 8, h: 8, owner: 'player', vx: -5, vy: -10, color: '#a3e635', dmg: 1.5, behavior: 'bounce' });
                      g.bullets.push({ x: cx + 10, y, w: 8, h: 8, owner: 'player', vx: 5, vy: -10, color: '#a3e635', dmg: 1.5, behavior: 'bounce' });
                      break;
                  case 4: // Split Shot
                      g.bullets.push({ x: cx, y, w: 6, h: 15, owner: 'player', vx: 0, vy: -12, color: '#f472b6', dmg: 2, behavior: 'split', dist: 0 });
                      break;
                  case 5: // Spiral
                      const offset = Math.sin(g.player.shootAngle) * 10;
                      g.bullets.push({ x: cx + offset, y, w: 6, h: 12, owner: 'player', vy: -15, color: '#c084fc', dmg: 2 });
                      g.bullets.push({ x: cx - offset, y, w: 6, h: 12, owner: 'player', vy: -15, color: '#c084fc', dmg: 2 });
                      break;
                  case 6: // Homing Missiles
                      g.bullets.push({ x: cx - 15, y, w: 6, h: 10, owner: 'player', vx: -4, vy: -6, color: '#ef4444', dmg: 2, behavior: 'homing' });
                      g.bullets.push({ x: cx + 15, y, w: 6, h: 10, owner: 'player', vx: 4, vy: -6, color: '#ef4444', dmg: 2, behavior: 'homing' });
                      break;
                  case 7: // Plasma Fragmented
                      for(let i=0; i<5; i++) {
                           g.bullets.push({ x: cx, y, w: 4, h: 4, owner: 'player', vx: (Math.random()-0.5)*10, vy: -10 - Math.random()*5, color: '#22d3ee', dmg: 1.5 });
                      }
                      break;
                  case 8: // Curved Laser
                      g.bullets.push({ x: cx - 20, y, w: 4, h: 20, owner: 'player', vx: 2, vy: -15, color: '#e879f9', dmg: 2.5, behavior: 'curve' });
                      g.bullets.push({ x: cx + 20, y, w: 4, h: 20, owner: 'player', vx: -2, vy: -15, color: '#e879f9', dmg: 2.5, behavior: 'curve' });
                      g.bullets.push({ x: cx, y, w: 6, h: 25, owner: 'player', vx: 0, vy: -18, color: '#e879f9', dmg: 3 });
                      break;
                  case 9: // 360 Nova
                      const burstCount = 16;
                      for (let i = 0; i < burstCount; i++) {
                           const angle = (i / burstCount) * Math.PI * 2;
                           g.bullets.push({
                               x: cx, y: y, w: 5, h: 5,
                               owner: 'player',
                               vx: Math.cos(angle) * 10,
                               vy: Math.sin(angle) * 10,
                               color: '#fbbf24',
                               dmg: 1.5
                           });
                      }
                      break;
                  case 10: // God Mode: Concentrated Beam
                      g.bullets.push({ x: cx - 8, y: y - 20, w: 16, h: 60, owner: 'player', vy: -25, color: '#ffffff', dmg: 5, behavior: 'beam', glow: true });
                      // Side sprays
                      g.bullets.push({ x: cx - 15, y, w: 4, h: 15, owner: 'player', vx: -2, vy: -15, color: '#60a5fa', dmg: 2 });
                      g.bullets.push({ x: cx + 15, y, w: 4, h: 15, owner: 'player', vx: 2, vy: -15, color: '#60a5fa', dmg: 2 });
                      break;
                  default: // Fallback level > 10
                      g.bullets.push({ x: cx, y, w: 10, h: 40, owner: 'player', vy: -20, color: '#fff', dmg: 4 });
              }
          };

          const draw = useCallback(() => {
              const canvas = canvasRef.current;
              if (!canvas) return;
              const ctx = canvas.getContext('2d');
              const g = game.current;
              
              ctx.clearRect(0, 0, g.width, g.height);
              
              // Stars
              ctx.fillStyle = '#ffffff';
              g.stars.forEach(s => {
                  ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                  ctx.beginPath();
                  ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.globalAlpha = 1.0;
              });

              if (g.gameState !== 'game-over') {
                  const p = g.player;
                  
                  // Special Shield Aura
                  if (p.shieldActive) {
                      const pulse = Math.sin(Date.now() / 100) * 5;
                      ctx.save();
                      ctx.shadowBlur = 30;
                      ctx.shadowColor = '#8b5cf6'; // Violet Neon
                      ctx.strokeStyle = '#a78bfa';
                      ctx.lineWidth = 3;
                      ctx.beginPath();
                      ctx.arc(p.x + p.w/2, p.y + p.h/2, p.w + 10 + pulse, 0, Math.PI * 2);
                      ctx.stroke();
                      
                      // Concentrated Center Glow
                      ctx.fillStyle = 'rgba(139, 92, 246, 0.3)';
                      ctx.beginPath();
                      ctx.arc(p.x + p.w/2, p.y + p.h/2, p.w/2, 0, Math.PI * 2);
                      ctx.fill();
                      ctx.restore();
                  }

                  // Player Ship
                  ctx.fillStyle = '#00ffff'; 
                  ctx.shadowBlur = 15;
                  ctx.shadowColor = '#00ffff';
                  ctx.beginPath();
                  ctx.moveTo(p.x + p.w/2, p.y);
                  ctx.lineTo(p.x + p.w, p.y + p.h);
                  ctx.lineTo(p.x + p.w/2, p.y + p.h - 10);
                  ctx.lineTo(p.x, p.y + p.h);
                  ctx.closePath();
                  ctx.fill();
                  ctx.shadowBlur = 0;
              }

              // Powerups
              g.powerups.forEach(p => {
                  ctx.save();
                  ctx.shadowBlur = 10;
                  ctx.shadowColor = p.type === 'weapon' ? '#22c55e' : '#facc15';
                  ctx.fillStyle = p.type === 'weapon' ? '#22c55e' : '#facc15';
                  ctx.beginPath();
                  ctx.arc(p.x + 10, p.y + 10, 10, 0, Math.PI*2);
                  ctx.fill();
                  ctx.fillStyle = '#000';
                  ctx.font = 'bold 10px Arial';
                  ctx.fillText(p.type === 'weapon' ? 'UP' : 'SP', p.x + 4, p.y + 14);
                  ctx.restore();
              });

              // Bullets
              g.bullets.forEach(b => {
                  ctx.save();
                  if (b.glow) {
                      ctx.shadowBlur = 20;
                      ctx.shadowColor = b.color;
                  } else {
                      ctx.shadowBlur = 5;
                      ctx.shadowColor = b.color;
                  }
                  ctx.fillStyle = b.color || '#fff';
                  
                  if (b.behavior === 'homing') {
                      // Draw Missile Shape
                      ctx.beginPath();
                      ctx.moveTo(b.x, b.y);
                      ctx.lineTo(b.x + b.w, b.y + b.h);
                      ctx.lineTo(b.x - b.w, b.y + b.h);
                      ctx.fill();
                  } else if (b.behavior === 'beam') {
                      // Draw Beam
                      const grad = ctx.createLinearGradient(b.x, b.y, b.x + b.w, b.y);
                      grad.addColorStop(0, 'rgba(255,255,255,0)');
                      grad.addColorStop(0.5, b.color);
                      grad.addColorStop(1, 'rgba(255,255,255,0)');
                      ctx.fillStyle = grad;
                      ctx.fillRect(b.x, b.y, b.w, b.h);
                  } else {
                      ctx.fillRect(b.x, b.y, b.w, b.h);
                  }
                  ctx.restore();
              });

              // Enemies
              g.enemies.forEach(e => {
                  ctx.save();
                  ctx.fillStyle = e.type === 'tank' ? '#ef4444' : (e.type === 'seeker' ? '#f59e0b' : (e.type === 'ufo' ? '#ec4899' : (e.type === 'bomber' ? '#6366f1' : '#a855f7')));
                  ctx.shadowBlur = 10;
                  ctx.shadowColor = ctx.fillStyle;
                  
                  if (e.type === 'seeker') { // Triangle
                      ctx.beginPath(); ctx.moveTo(e.x + e.w/2, e.y + e.h); ctx.lineTo(e.x, e.y); ctx.lineTo(e.x + e.w, e.y); ctx.closePath(); ctx.fill();
                  } else if (e.type === 'ufo') { // Circle
                      ctx.beginPath(); ctx.ellipse(e.x + e.w/2, e.y + e.h/2, e.w/2, e.h/4, 0, 0, Math.PI*2); ctx.fill();
                      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(e.x + e.w/2, e.y + e.h/4, e.w/4, 0, Math.PI*2); ctx.fill();
                  } else if (e.type === 'bomber') { // Hexagon
                      ctx.beginPath(); const cx = e.x + e.w/2, cy = e.y + e.h/2, r = e.w/2; for(let i=0; i<6; i++) { const angle = i * Math.PI / 3; const x = cx + Math.cos(angle) * r; const y = cy + Math.sin(angle) * r; if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); ctx.fill();
                  } else if (e.type === 'swarmer') { // Diamond
                      ctx.beginPath(); ctx.moveTo(e.x + e.w/2, e.y); ctx.lineTo(e.x + e.w, e.y + e.h/2); ctx.lineTo(e.x + e.w/2, e.y + e.h); ctx.lineTo(e.x, e.y + e.h/2); ctx.closePath(); ctx.fill();
                  } else { ctx.fillRect(e.x, e.y, e.w, e.h); }
                  
                  // HP Bar
                  ctx.fillStyle = 'red'; ctx.fillRect(e.x, e.y - 5, e.w, 3);
                  ctx.fillStyle = 'lime'; ctx.fillRect(e.x, e.y - 5, e.w * (e.health/e.maxHealth), 3);
                  ctx.restore();
              });

              // Boss
              if (g.boss) {
                  const boss = g.boss;
                  ctx.save();
                  ctx.fillStyle = '#ff0055';
                  ctx.shadowBlur = 30;
                  ctx.shadowColor = '#ff0055';
                  ctx.beginPath(); ctx.moveTo(boss.x, boss.y); ctx.lineTo(boss.x + boss.w, boss.y); ctx.lineTo(boss.x + boss.w/2, boss.y + boss.h); ctx.closePath(); ctx.fill();
                  ctx.restore();
                  
                  // Boss Health Bar UI
                  ctx.fillStyle = '#330033'; ctx.fillRect(10, 50, g.width - 20, 10);
                  ctx.fillStyle = '#ff00ff'; ctx.fillRect(10, 50, (g.width - 20) * (boss.health / boss.maxHealth), 10);
              }

              // Particles
              g.particles.forEach(p => {
                  ctx.fillStyle = p.color;
                  ctx.globalAlpha = p.life / 20;
                  ctx.fillRect(p.x, p.y, 3, 3);
                  ctx.globalAlpha = 1;
              });

              // UI
              ctx.fillStyle = 'white';
              ctx.font = 'bold 16px "Courier New"';
              ctx.fillText(`SCORE: ${g.score}`, 10, 25);
              ctx.textAlign = 'right';
              ctx.fillText(`LVL: ${g.level} | WPN: ${g.player.weaponLevel}`, g.width - 10, 25);
              ctx.textAlign = 'left';

              const hpPercent = Math.max(0, g.player.health / g.player.maxHealth);
              ctx.fillStyle = '#333'; ctx.fillRect(10, g.height - 30, 150, 15);
              ctx.fillStyle = hpPercent > 0.5 ? '#22c55e' : (hpPercent > 0.2 ? '#eab308' : '#ef4444');
              ctx.fillRect(10, g.height - 30, 150 * hpPercent, 15);
              ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(10, g.height - 30, 150, 15);

              if (g.player.shieldActive) {
                  ctx.fillStyle = '#facc15';
                  ctx.font = 'bold 14px Arial';
                  ctx.textAlign = 'center';
                  ctx.shadowBlur = 10;
                  ctx.shadowColor = '#facc15';
                  ctx.fillText(`SPECIAL ACTIVE: CHAOS BLOSSOM (${Math.ceil(g.player.shieldTimer/1000)}s)`, g.width/2, g.height - 18);
                  ctx.shadowBlur = 0;
                  ctx.textAlign = 'left';
              }

              if (g.gameState === 'game-over') {
                  ctx.fillStyle = 'rgba(0,0,0,0.8)';
                  ctx.fillRect(0,0,g.width,g.height);
                  ctx.fillStyle = '#ff0055';
                  ctx.font = 'bold 40px "Courier New"';
                  ctx.textAlign = 'center';
                  ctx.fillText('GAME OVER', g.width/2, g.height/2 - 20);
                  ctx.fillStyle = 'white';
                  ctx.font = '20px "Courier New"';
                  ctx.fillText('Tap to Restart', g.width/2, g.height/2 + 30);
              }

          }, []);

          useEffect(() => {
              initGame();
              const canvas = canvasRef.current;
              const g = game.current;
              
              const resizeCanvas = () => {
                if(canvas && canvas.parentElement) {
                    canvas.width = canvas.parentElement.clientWidth;
                    canvas.height = canvas.parentElement.clientHeight;
                    g.width = canvas.width;
                    g.height = canvas.height;
                }
              };
              
              resizeCanvas();
              window.addEventListener('resize', resizeCanvas);

              let animationFrameId;
              const gameLoop = () => {
                  update();
                  draw();
                  animationFrameId = window.requestAnimationFrame(gameLoop);
              };
              gameLoop();

              const handleMove = (e) => {
                  if (g.gameState !== 'playing' && g.gameState !== 'boss') return;
                  if(e.cancelable) e.preventDefault();
                  const rect = canvas.getBoundingClientRect();
                  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                  const x = clientX - rect.left;
                  const y = clientY - rect.top;
                  g.player.x = Math.max(0, Math.min(g.width - g.player.w, x - g.player.w / 2));
                  g.player.y = Math.max(0, Math.min(g.height - g.player.h, y - g.player.h / 2));
                  
                  const now = Date.now();
                  // Faster fire rate for high levels
                  const fireRate = g.player.weaponLevel >= 8 ? 100 : 150;
                  if (now - g.player.lastShot > fireRate) { 
                      firePlayerWeapon(g);
                      g.player.lastShot = now;
                  }
              };

              const handleClick = () => {
                  if (g.gameState === 'game-over') {
                      triggerAd();
                      initGame();
                  }
              }

              canvas.addEventListener('mousemove', handleMove);
              canvas.addEventListener('touchmove', handleMove, { passive: false });
              canvas.addEventListener('click', handleClick);

              return () => {
                  window.cancelAnimationFrame(animationFrameId);
                  window.removeEventListener('resize', resizeCanvas);
                  canvas.removeEventListener('mousemove', handleMove);
                  canvas.removeEventListener('touchmove', handleMove);
                  canvas.removeEventListener('click', handleClick);
              };
          }, [draw, update, initGame, triggerAd]);

          return (
              <div className="w-full h-full relative flex flex-col items-center justify-center bg-transparent">
                  <canvas ref={canvasRef} className="w-full h-full block" />
                  
                  <div className="absolute top-4 left-4 z-10">
                      <button onClick={onBack} className="p-3 bg-white/20 backdrop-blur-md rounded-full text-white hover:bg-white/30 transition border border-white/20">
                          <ChevronLeft size={24} />
                      </button>
                  </div>
              </div>
          );
      };

      // --- Main App Component ---
      const App = () => {
          const [currentScreen, setCurrentScreen] = useState('home');
          const [lastAdTime, setLastAdTime] = useState(0);

          const triggerAd = useCallback(() => {
             const now = Date.now();
             if (now - lastAdTime > 120000) {
                 setLastAdTime(now);
             }
          }, [lastAdTime]);

          const startGame = (gameName) => {
              triggerAd();
              setCurrentScreen(gameName);
          };

          const renderScreen = () => {
              switch(currentScreen) {
                  case 'galaxy-invader':
                      return <GalaxyInvader onBack={() => setCurrentScreen('home')} triggerAd={triggerAd} />;
                  case 'neon-racer':
                      return <NeonRacer onBack={() => setCurrentScreen('home')} triggerAd={triggerAd} />;
                  case 'lingua-quest':
                      return <LinguaQuest onBack={() => setCurrentScreen('home')} triggerAd={triggerAd} />;
                  default:
                      return (
                          <div className="w-full h-full flex flex-col items-center justify-center relative overflow-hidden">
                              <div className="z-10 flex flex-col items-center gap-8 w-full max-w-md px-4">
                                  <h1 className="text-5xl md:text-6xl font-bold text-center neon-title tracking-wider">
                                      JoGos<br/>Online
                                  </h1>
                                  
                                  <div className="w-full grid gap-4 mt-8">
                                      <button 
                                          onClick={() => startGame('galaxy-invader')}
                                          className="glass-box group relative w-full h-24 rounded-xl overflow-hidden"
                                      >
                                          <div className="relative z-10 flex items-center justify-between p-6 h-full text-white">
                                              <div className="flex flex-col items-start">
                                                  <span className="text-xl font-bold text-white drop-shadow-md neon-text-small">GALAXY INVADER</span>
                                                  <span className="text-xs text-gray-400">Space Shooter</span>
                                              </div>
                                              <Rocket size={32} className="text-purple-400" />
                                          </div>
                                      </button>

                                      <button 
                                          onClick={() => startGame('neon-racer')}
                                          className="glass-box group relative w-full h-24 rounded-xl overflow-hidden"
                                      >
                                          <div className="relative z-10 flex items-center justify-between p-6 h-full text-white">
                                              <div className="flex flex-col items-start">
                                                  <span className="text-xl font-bold text-white drop-shadow-md neon-text-small">NEON RACER</span>
                                                  <span className="text-xs text-gray-400">High Speed Racing</span>
                                              </div>
                                              <Car size={32} className="text-pink-400" />
                                          </div>
                                      </button>

                                      <button 
                                          onClick={() => startGame('lingua-quest')}
                                          className="glass-box group relative w-full h-24 rounded-xl overflow-hidden"
                                      >
                                          <div className="relative z-10 flex items-center justify-between p-6 h-full text-white">
                                              <div className="flex flex-col items-start">
                                                  <span className="text-xl font-bold text-white drop-shadow-md neon-text-small">LINGUA QUEST</span>
                                                  <span className="text-xs text-gray-400">Learn English</span>
                                              </div>
                                              <Languages size={32} className="text-green-400" />
                                          </div>
                                      </button>
                                  </div>
                              </div>
                              
                              <div className="absolute bottom-4 text-gray-700 text-xs">
                                  v4.1.3
                              </div>
                          </div>
                      );
              }
          };

          return renderScreen();
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>