
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>JosiPuff - Solitaire</title>
    <meta name="description" content="Jogue JosiPuff Solitaire Grátis. O melhor jogo online de cartas. Leve, rápido e funciona offline.">
    <meta name="keywords" content="jogo online, jogo paciencia, jogo paciencia dw, jogo paciencia josiane, solitaire, freecell, cartas, josipuff">
    <meta name="theme-color" content="#0f3526">
    <meta name="monetag" content="90e74a99c3a7b6c2ba03e69c9477a61d">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@700;900&family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    screens: {
                        'xs': '370px',
                    },
                    keyframes: {
                        'gradient-xy': {
                            '0%, 100%': { 'background-position': '0% 50%' },
                            '50%': { 'background-position': '100% 50%' }
                        },
                        'neon-pulse': {
                            '0%, 100%': { boxShadow: '0 0 5px #9333ea, 0 0 10px #9333ea', borderColor: '#9333ea' },
                            '50%': { boxShadow: '0 0 5px #22c55e, 0 0 10px #22c55e', borderColor: '#22c55e' }
                        },
                        shimmer: {
                            '0%': { transform: 'translateX(-150%) skewX(-15deg)' },
                            '100%': { transform: 'translateX(150%) skewX(-15deg)' }
                        }
                    },
                    animation: {
                        'gradient-xy': 'gradient-xy 3s ease infinite',
                        'neon-pulse': 'neon-pulse 2s infinite',
                    }
                }
            }
        }
    </script>
    
    <!-- Babel for React -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Monetag Scripts -->
    <script src="https://fpyf8.com/88/tag.min.js" data-zone="187944" async data-cfasync="false"></script>
    <script>(function(s){s.dataset.zone='10234172',s.src='https://nap5k.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>
    <script>(function(s){s.dataset.zone='10236160',s.src='https://nap5k.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>

    <style>
        /* Base Reset & Mobile Fixes */
        html, body {
            height: 100%;
            overflow: hidden; /* Prevent pull-to-refresh on mobile */
        }
        body { 
            overscroll-behavior: none; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent;
            font-family: 'Inter', sans-serif;
            background-color: #0f3526;
            user-select: none;
            -webkit-user-select: none;
        }
        #root {
            height: 100%;
        }

        /* Safe Areas for iPhone X+ */
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .pt-safe { padding-top: env(safe-area-inset-top); }

        /* Scrollbar Hiding for Horizontal Menus */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* Custom Scrollbar for other areas */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }
        
        /* Hint Animations */
        .hint-source { animation: pulse-yellow 1.5s infinite; filter: brightness(1.2); }
        .hint-target { animation: pulse-green 1.5s infinite; box-shadow: 0 0 15px #4ade80; z-index: 50; }
        @keyframes pulse-yellow { 0%, 100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(250, 204, 21, 0); } }
        @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); } }
        
        /* Victory Text */
        .victory-text {
            font-family: 'Crimson Pro', serif;
            background: linear-gradient(to bottom, #fde047, #ca8a04);
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0px 4px 10px rgba(0,0,0,0.5);
            filter: drop-shadow(0 0 20px rgba(234, 179, 8, 0.6));
            animation: zoom-in-bounce 1s ease-out forwards;
        }
        @keyframes zoom-in-bounce {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            60% { transform: scale(1.2) rotate(5deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes win-wave { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-30px); } }
        .animate-win-wave { animation: win-wave 1s ease-in-out infinite; }
    </style>
    
    <script type="importmap">
    {
      "imports": {
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
        "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
        "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
        "react/": "https://aistudiocdn.com/react@^19.2.0/"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useCallback, useRef, memo } from 'react';
      import { createRoot } from 'react-dom/client';
      import { Heart, Diamond, Club, Spade, Trophy, Clock, RotateCcw, X, LayoutGrid, RefreshCw, Eye, Play, Pause, Volume2, VolumeX, Maximize, Crown, Undo2, Lightbulb, Wand2, CalendarCheck, Moon, Sun, Smartphone, Gift, CheckCircle2, Share, GripHorizontal, BarChart3, Settings, PlusCircle } from 'lucide-react';

      // --- TYPES & UTILS ---
      const Suit = { Hearts: 'hearts', Diamonds: 'diamonds', Clubs: 'clubs', Spades: 'spades' };
      const Rank = { Ace: 1, Two: 2, Three: 3, Four: 4, Five: 5, Six: 6, Seven: 7, Eight: 8, Nine: 9, Ten: 10, Jack: 11, Queen: 12, King: 13 };
      const GameMode = { FreeCell: 'freeCell', Klondike: 'klondike' };
      
      const stopAdEvent = (e) => {
          if (!e) return;
          e.stopPropagation();
          // We allow default on buttons usually, but stopping propagation prevents "clickjacking" listeners on body
          if (e.nativeEvent) e.nativeEvent.stopImmediatePropagation();
      };

      const getCardColor = (suit) => (suit === Suit.Hearts || suit === Suit.Diamonds ? 'red' : 'black');

      // --- SOUND MANAGER ---
      const useSound = (enabled) => {
          const audioCtx = useRef(null);
          
          const initAudio = () => {
              if (!audioCtx.current) {
                  const AudioContext = window.AudioContext || window.webkitAudioContext;
                  if (AudioContext) audioCtx.current = new AudioContext();
              }
              if (audioCtx.current && audioCtx.current.state === 'suspended') {
                  audioCtx.current.resume();
              }
          };

          const play = useCallback((type) => {
              if (!enabled) return;
              initAudio();
              if (!audioCtx.current) return;
              
              const ctx = audioCtx.current;
              const t = ctx.currentTime;
              const gain = ctx.createGain();
              gain.connect(ctx.destination);

              if (type === 'pickup') {
                  const osc = ctx.createOscillator();
                  osc.type = 'triangle';
                  osc.frequency.setValueAtTime(400, t);
                  osc.frequency.exponentialRampToValueAtTime(800, t + 0.05);
                  gain.gain.setValueAtTime(0.05, t);
                  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                  osc.connect(gain);
                  osc.start(t);
                  osc.stop(t + 0.05);
              } else if (type === 'drop') {
                  const osc = ctx.createOscillator();
                  osc.type = 'sine';
                  osc.frequency.setValueAtTime(120, t);
                  osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
                  gain.gain.setValueAtTime(0.15, t);
                  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                  osc.connect(gain);
                  osc.start(t);
                  osc.stop(t + 0.15);
              } else if (type === 'win') {
                  const notes = [523.25, 659.25, 783.99, 1046.50];
                  notes.forEach((freq, i) => {
                      const osc = ctx.createOscillator();
                      const noteGain = ctx.createGain();
                      osc.type = 'sine';
                      osc.frequency.value = freq;
                      noteGain.connect(ctx.destination);
                      osc.connect(noteGain);
                      const st = t + (i * 0.1);
                      noteGain.gain.setValueAtTime(0, st);
                      noteGain.gain.linearRampToValueAtTime(0.1, st + 0.05);
                      noteGain.gain.exponentialRampToValueAtTime(0.001, st + 0.4);
                      osc.start(st);
                      osc.stop(st + 0.4);
                  });
              } else if (type === 'deal') {
                  const bufferSize = ctx.sampleRate * 0.1;
                  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                  const data = buffer.getChannelData(0);
                  for (let i = 0; i < bufferSize; i++) {
                      data[i] = Math.random() * 2 - 1;
                  }
                  const noise = ctx.createBufferSource();
                  noise.buffer = buffer;
                  const noiseFilter = ctx.createBiquadFilter();
                  noiseFilter.type = 'lowpass';
                  noiseFilter.frequency.value = 800;
                  noise.connect(noiseFilter);
                  noiseFilter.connect(gain);
                  gain.gain.setValueAtTime(0.05, t);
                  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                  noise.start(t);
              }
          }, [enabled]);

          return play;
      };

      const createDeck = (faceUp = true) => {
        const deck = [];
        const suits = [Suit.Hearts, Suit.Diamonds, Suit.Clubs, Suit.Spades];
        const ranks = Object.values(Rank);
        suits.forEach((suit) => {
          ranks.forEach((rank) => {
            deck.push({ id: `${suit}-${rank}`, suit, rank, isFaceUp: faceUp });
          });
        });
        return deck;
      };

      const shuffleDeck = (deck) => {
        const newDeck = [...deck];
        for (let i = newDeck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
        }
        return newDeck;
      };

      const isMoveValid = (card, targetCard, targetType, mode, targetSuit) => {
        if (targetType === 'freeCell') return targetCard === null && mode === GameMode.FreeCell;
        
        if (targetType === 'foundation') {
          if (!targetCard) return card.rank === Rank.Ace && card.suit === targetSuit;
          return card.suit === targetCard.suit && card.rank === targetCard.rank + 1;
        }

        if (targetType === 'tableau') {
          if (!targetCard) {
            // Empty Tableau: Klondike needs King, FreeCell allows any
            if (mode === GameMode.Klondike) return card.rank === Rank.King;
            return true;
          }
          const cardColor = getCardColor(card.suit);
          const targetColor = getCardColor(targetCard.suit);
          return cardColor !== targetColor && card.rank === targetCard.rank - 1;
        }
        return false;
      };

      const isStackValid = (cards) => {
        if (cards.length <= 1) return true;
        for (let i = 0; i < cards.length - 1; i++) {
          const current = cards[i];
          const next = cards[i + 1];
          if (!current.isFaceUp || !next.isFaceUp) return false;
          if (getCardColor(current.suit) === getCardColor(next.suit) || current.rank !== next.rank + 1) return false;
        }
        return true;
      };

      const getMaxMovableStack = (emptyFreeCells, emptyTableauCols) => {
        return (1 + emptyFreeCells) * Math.pow(2, emptyTableauCols);
      };

      // --- COMPONENTS ---
      const SuitIcon = ({ suit, className, fill = true }) => {
        const props = { className, strokeWidth: fill ? 0 : 2 };
        switch (suit) {
          case Suit.Hearts: return <Heart {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Diamonds: return <Diamond {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Clubs: return <Club {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Spades: return <Spade {...props} fill={fill ? "currentColor" : "none"} />;
        }
      };

      const RankLabel = ({ rank }) => {
        let label = rank.toString();
        if (rank === 1) label = 'A';
        else if (rank === 11) label = 'J';
        else if (rank === 12) label = 'Q';
        else if (rank === 13) label = 'K';
        return <span className="font-serif tracking-tighter font-black drop-shadow-[0_1px_0_rgba(0,0,0,0.1)]">{label}</span>;
      };

      const PARCHMENT_TEXTURE = `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E")`;
      const BACK_PATTERN = `url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23991b1b' fill-opacity='0.4' fill-rule='evenodd'%3E%3Cpath d='M10 0L20 10L10 20L0 10z'/%3E%3C/g%3E%3C/svg%3E")`;

      const PipLayer = ({ rank, suit }) => {
        const pips = [];
        const L = '20%', C = '50%', R = '80%';
        const T = '15%', M = '50%', B = '85%'; 

        switch (rank) {
          case 2: pips.push({t:T,l:C},{t:B,l:C,i:1}); break;
          case 3: pips.push({t:T,l:C},{t:M,l:C},{t:B,l:C,i:1}); break;
          case 4: pips.push({t:T,l:L},{t:T,l:R},{t:B,l:L,i:1},{t:B,l:R,i:1}); break;
          case 5: pips.push({t:T,l:L},{t:T,l:R},{t:M,l:C},{t:B,l:L,i:1},{t:B,l:R,i:1}); break;
          case 6: pips.push({t:T,l:L},{t:T,l:R},{t:M,l:L},{t:M,l:R},{t:B,l:L,i:1},{t:B,l:R,i:1}); break;
          case 7: pips.push({t:T,l:L},{t:T,l:R},{t:M,l:L},{t:M,l:R},{t:'32.5%',l:C},{t:B,l:L,i:1},{t:B,l:R,i:1}); break;
          case 8: pips.push({t:T,l:L},{t:T,l:R},{t:M,l:L},{t:M,l:R},{t:'32.5%',l:C},{t:'67.5%',l:C,i:1},{t:B,l:L,i:1},{t:B,l:R,i:1}); break;
          case 9: pips.push({t:T,l:L},{t:T,l:R},{t:'37.5%',l:L},{t:'37.5%',l:R},{t:M,l:C},{t:'62.5%',l:L,i:1},{t:'62.5%',l:R,i:1},{t:B,l:L,i:1},{t:B,l:R,i:1}); break;
          case 10: pips.push({t:T,l:L},{t:T,l:R},{t:'37.5%',l:L},{t:'37.5%',l:R},{t:'26.25%',l:C},{t:'73.75%',l:C,i:1},{t:'62.5%',l:L,i:1},{t:'62.5%',l:R,i:1},{t:B,l:L,i:1},{t:B,l:R,i:1}); break;
        }

        return (
          <div className="absolute inset-x-[15%] inset-y-[12%] pointer-events-none">
            {pips.map((pip, i) => (
              <div key={i} className={`absolute w-[20%] h-[20%] flex items-center justify-center ${pip.i ? 'rotate-180' : ''}`} style={{ top: pip.t, left: pip.l, transform: `translate(-50%, -50%) ${pip.i ? 'rotate(180deg)' : ''}` }}>
                <SuitIcon suit={suit} className="w-full h-full" />
              </div>
            ))}
          </div>
        );
      }

      const SolitaireCard = memo(({ card, onPointerDown, isSelected, className = '', style, draggable }) => {
        const isFaceCard = card.rank >= 11;
        const isAce = card.rank === 1;
        const isNumber = card.rank >= 2 && card.rank <= 10;
        const color = getCardColor(card.suit);
        const textColor = color === 'red' ? 'text-[#d40000]' : 'text-[#1a1a1a]';
        
        return (
          <div
            className={`relative w-full aspect-[2.5/3.5] select-none [perspective:1000px] ${draggable ? 'cursor-grab active:cursor-grabbing' : ''} ${className}`}
            onPointerDown={(e) => { 
                if (onPointerDown) {
                    stopAdEvent(e);
                    onPointerDown(e, e.currentTarget); 
                }
            }}
            onClick={stopAdEvent}
            style={{ ...style, zIndex: isSelected ? 100 : style?.zIndex }}
          >
            <div className={`w-full h-full relative transition-transform duration-200 ease-[cubic-bezier(0.25,0.8,0.25,1)] [transform-style:preserve-3d] will-change-transform ${card.isFaceUp ? '[transform:rotateY(0deg)]' : '[transform:rotateY(180deg)]'}`}>
              
              {/* FRONT */}
              <div className={`absolute inset-0 [backface-visibility:hidden] bg-[#fcfaf5] rounded-[6%] overflow-hidden flex items-center justify-center transition-all duration-300 ${isSelected ? 'ring-[3px] ring-yellow-400 ring-offset-2 ring-offset-[#0f3526] -translate-y-2 brightness-105' : 'shadow-[0_2px_4px_rgba(0,0,0,0.15)]'}`}>
                 <div className="absolute inset-0 pointer-events-none mix-blend-multiply opacity-50" style={{ backgroundImage: PARCHMENT_TEXTURE }}></div>
                 <div className="absolute inset-0 bg-gradient-to-br from-white/80 to-transparent pointer-events-none"></div>

                 <div className={`absolute top-[4%] left-[6%] flex flex-col items-center leading-none ${textColor} w-[18%]`}>
                    <span className="text-[min(18px,4.5vw)] sm:text-2xl font-bold font-serif"><RankLabel rank={card.rank} /></span>
                    <SuitIcon suit={card.suit} className="w-[min(14px,3.5vw)] h-[min(14px,3.5vw)] sm:w-4 sm:h-4" />
                 </div>
                 
                 <div className={`absolute inset-[13%] flex items-center justify-center pointer-events-none ${textColor}`}>
                     {isFaceCard && (
                         <div className="w-full h-full border-[1.5px] border-current/20 rounded-sm flex flex-col items-center justify-center relative overflow-hidden bg-current/5 shadow-inner">
                             <div className="absolute inset-0 opacity-10" style={{ backgroundImage: `radial-gradient(circle, currentColor 1px, transparent 1px)`, backgroundSize: '8px 8px' }}></div>
                             <SuitIcon suit={card.suit} className="w-[55%] h-[55%] drop-shadow-md" />
                         </div>
                     )}
                     {isAce && <SuitIcon suit={card.suit} className="w-[60%] h-[60%] drop-shadow-lg" />}
                     {isNumber && <PipLayer rank={card.rank} suit={card.suit} />}
                 </div>

                 <div className={`absolute bottom-[4%] right-[6%] flex flex-col items-center leading-none rotate-180 ${textColor} w-[18%]`}>
                    <span className="text-[min(18px,4.5vw)] sm:text-2xl font-bold font-serif"><RankLabel rank={card.rank} /></span>
                    <SuitIcon suit={card.suit} className="w-[min(14px,3.5vw)] h-[min(14px,3.5vw)] sm:w-4 sm:h-4" />
                 </div>
              </div>

              {/* BACK */}
              <div className="absolute inset-0 [backface-visibility:hidden] [transform:rotateY(180deg)] bg-[#7f1d1d] rounded-[6%] border-[3px] border-[#fcfaf5] shadow-[inset_0_0_4px_rgba(0,0,0,0.3)] flex items-center justify-center">
                 <div className="absolute inset-1.5 border border-[#fbbf24]/20 rounded-[4.5%]" style={{ backgroundImage: BACK_PATTERN }}></div>
                 <div className="relative w-[35%] h-[25%] bg-[#450a0a] rounded-[50%] flex items-center justify-center shadow-inner border-2 border-[#fbbf24]/40 z-10">
                     <Crown className="w-[60%] h-[60%] text-[#fbbf24] drop-shadow-md" strokeWidth={1.5} />
                 </div>
              </div>
            </div>
          </div>
        );
      });

      const AdsterraBanner = ({ width, height, dataKey }) => {
          const containerRef = useRef(null);
          useEffect(() => {
              if (!containerRef.current || !dataKey) return;
              
              // Adsterra uses document.write, so we MUST use an isolated iframe to prevent React crashes
              const iframe = document.createElement('iframe');
              iframe.width = width;
              iframe.height = height;
              iframe.style.border = 'none';
              iframe.style.overflow = 'hidden';
              iframe.scrolling = 'no';
              
              // Clear and append
              containerRef.current.innerHTML = '';
              containerRef.current.appendChild(iframe);
              
              const doc = iframe.contentWindow.document;
              doc.open();
              doc.write(`
                <html>
                <body style="margin:0;padding:0;background:transparent;display:flex;justify-content:center;align-items:center;overflow:hidden;">
                    <script type="text/javascript">
                        atOptions = {
                            'key' : '${dataKey}',
                            'format' : 'iframe',
                            'height' : ${height},
                            'width' : ${width},
                            'params' : {}
                        };
                    <\/script>
                    <script type="text/javascript" src="//www.highperformanceformat.com/${dataKey}/invoke.js"><\/script>
                </body>
                </html>
              `);
              doc.close();
          }, [width, height, dataKey]);
          
          return <div ref={containerRef} style={{ width, height }} className="mx-auto flex justify-center items-center" />;
      };

      const DraggableMenu = ({ children }) => {
         const [pos, setPos] = useState({ x: 0, y: 0 }); 
         const initialized = useRef(false);
         const [isDragging, setIsDragging] = useState(false);
         const offset = useRef({ x: 0, y: 0 });

         useEffect(() => {
             if(!initialized.current) {
                 setPos({ x: window.innerWidth / 2, y: window.innerHeight - 100 });
                 initialized.current = true;
             }
         }, []);

         const handlePointerDown = (e) => {
             if (e.target.closest('button')) return;
             stopAdEvent(e);
             setIsDragging(true);
             offset.current = { x: e.clientX - pos.x, y: e.clientY - pos.y };
             e.target.setPointerCapture(e.pointerId);
         };

         const handlePointerMove = (e) => {
             if (!isDragging) return;
             stopAdEvent(e);
             const newX = Math.min(window.innerWidth - 60, Math.max(60, e.clientX - offset.current.x));
             const newY = Math.min(window.innerHeight - 60, Math.max(60, e.clientY - offset.current.y));
             setPos({ x: newX, y: newY });
         };

         const handlePointerUp = (e) => {
             if(isDragging) {
                setIsDragging(false);
                e.target.releasePointerCapture(e.pointerId);
             }
         };

         if (!initialized.current) return null;

         return (
             <div 
                className="fixed z-[200] touch-none flex flex-col items-center gap-1 cursor-grab active:cursor-grabbing"
                style={{ left: pos.x, top: pos.y, transform: 'translate(-50%, -50%)' }}
                onPointerDown={handlePointerDown}
                onPointerMove={handlePointerMove}
                onPointerUp={handlePointerUp}
             >
                <div className="bg-[#0a1f16]/95 backdrop-blur-xl p-1.5 rounded-2xl border border-yellow-500/30 shadow-[0_10px_30px_rgba(0,0,0,0.5)] flex items-center gap-1.5 pointer-events-auto select-none ring-1 ring-white/10">
                    <div className="text-white/20 mr-0.5"><GripHorizontal size={14} /></div>
                    {children}
                </div>
             </div>
         );
      };

      const InstallModal = ({ onInstall, onClose, isIOS, hasNativePrompt }) => (
        <div className="fixed inset-0 z-[300] bg-black/90 backdrop-blur-md flex items-center justify-center p-4" onClick={stopAdEvent}>
            <div className="bg-[#1e293b] rounded-3xl p-8 max-w-sm w-full text-center border border-yellow-500/50 shadow-2xl relative overflow-hidden">
                <div className="absolute inset-0 bg-gradient-to-tr from-purple-600/20 to-green-500/20 pointer-events-none"></div>
                <button onClick={onClose} className="absolute top-4 right-4 text-white/50 hover:text-white"><X /></button>
                <div className="relative z-10">
                    <div className="mb-6 inline-block relative">
                         <div className="absolute inset-0 bg-gradient-to-r from-purple-500 to-green-500 rounded-full blur-xl opacity-50 animate-pulse"></div>
                         <div className="relative bg-white/10 p-4 rounded-full border border-white/20"><Smartphone className="w-12 h-12 text-white" /></div>
                    </div>
                    <h2 className="text-2xl font-black text-white mb-2 uppercase tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-yellow-600">Criar Atalho?</h2>
                    <p className="text-gray-300 mb-6 text-sm">Adicione à tela inicial para jogar sem travar.</p>
                    {isIOS ? (
                        <div className="text-left bg-white/5 p-4 rounded-xl border border-white/10 mb-6 text-xs text-gray-300 space-y-2">
                             <p>1. Toque em <Share className="w-3 h-3 inline" /> <strong>Compartilhar</strong></p>
                             <p>2. Selecione <strong>Adicionar à Tela de Início</strong></p>
                        </div>
                    ) : (
                        <div className="flex gap-3">
                            <button onClick={onClose} className="flex-1 py-3 rounded-xl font-bold uppercase text-white/70 bg-red-500/10 border border-red-500/20">NÃO</button>
                            <button onClick={onInstall} className="flex-[1.5] py-3 rounded-xl font-bold uppercase text-white bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 animate-pulse">SIM</button>
                        </div>
                    )}
                </div>
            </div>
        </div>
      );

      const StatsModal = ({ onClose, stats }) => (
          <div className="fixed inset-0 z-[250] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4" onClick={stopAdEvent}>
              <div className="bg-[#1e293b] rounded-2xl w-full max-w-md border border-white/10 shadow-2xl overflow-hidden">
                  <div className="bg-black/30 p-4 border-b border-white/10 flex justify-between items-center">
                      <h2 className="text-lg font-bold text-white flex items-center gap-2"><BarChart3 className="text-yellow-400" /> Estatísticas</h2>
                      <button onClick={onClose} className="text-white/50 hover:text-white"><X /></button>
                  </div>
                  <div className="p-6 grid grid-cols-2 gap-4">
                      <div className="bg-white/5 p-4 rounded-xl text-center">
                          <div className="text-2xl font-black text-emerald-400">{stats.wins}</div>
                          <div className="text-xs text-white/50 uppercase tracking-wider">Vitórias</div>
                      </div>
                      <div className="bg-white/5 p-4 rounded-xl text-center">
                          <div className="text-2xl font-black text-yellow-400">{stats.bestScore}</div>
                          <div className="text-xs text-white/50 uppercase tracking-wider">Melhor Pontos</div>
                      </div>
                      <div className="bg-white/5 p-4 rounded-xl text-center">
                          <div className="text-2xl font-black text-blue-400">{stats.bestMoves > 0 ? stats.bestMoves : '-'}</div>
                          <div className="text-xs text-white/50 uppercase tracking-wider">Menor Mov.</div>
                      </div>
                      <div className="bg-white/5 p-4 rounded-xl text-center">
                          <div className="text-2xl font-black text-purple-400">{stats.gamesPlayed}</div>
                          <div className="text-xs text-white/50 uppercase tracking-wider">Partidas</div>
                      </div>
                  </div>
              </div>
          </div>
      );

      // --- MAIN APP ---
      function App() {
        const [gameMode, setGameMode] = useState(GameMode.FreeCell);
        const [gameState, setGameState] = useState({
            mode: GameMode.FreeCell,
            freeCells: [null, null, null, null],
            stock: [], waste: [],
            foundation: { [Suit.Hearts]: [], [Suit.Diamonds]: [], [Suit.Clubs]: [], [Suit.Spades]: [] },
            tableau: [], score: 0, moves: 0, time: 0, gameWon: false
        });
        const [history, setHistory] = useState([]);
        const [selected, setSelected] = useState(null);
        const [hint, setHint] = useState(null);
        const [isNightMode, setIsNightMode] = useState(false);
        const [showInstallButton, setShowInstallButton] = useState(true);
        const [showInstallModal, setShowInstallModal] = useState(false);
        const [deferredPrompt, setDeferredPrompt] = useState(null);
        
        const [showStatsModal, setShowStatsModal] = useState(false);
        const [isSoundEnabled, setIsSoundEnabled] = useState(true);
        const [stats, setStats] = useState({ wins: 0, gamesPlayed: 0, bestScore: 0, bestMoves: 0 });

        const [showWinningBounce, setShowWinningBounce] = useState(false);
        const [onlineCount, setOnlineCount] = useState(150);
        const [visitCount, setVisitCount] = useState(843210);

        const playSound = useSound(isSoundEnabled);

        const activeDragRef = useRef(null);
        const dragRaf = useRef(null);
        const gameStateRef = useRef(gameState);
        useEffect(() => { gameStateRef.current = gameState; }, [gameState]);

        const startNewGame = useCallback(() => {
            const deck = shuffleDeck(createDeck(gameMode === GameMode.FreeCell));
            let newTableau = [], stock = [], waste = [];
            
            if (gameMode === GameMode.FreeCell) {
                newTableau = Array(8).fill().map(() => []);
                let idx = 0;
                for(let col=0; col<8; col++) {
                    const count = col < 4 ? 7 : 6;
                    for(let i=0; i<count; i++) newTableau[col].push(deck[idx++]);
                }
            } else {
                newTableau = Array(7).fill().map(() => []);
                let idx = 0;
                for(let col=0; col<7; col++) {
                    for(let i=0; i<=col; i++) {
                        const card = deck[idx++];
                        card.isFaceUp = (i === col);
                        newTableau[col].push(card);
                    }
                }
                stock = deck.slice(idx).map(c => ({...c, isFaceUp: false}));
            }
            
            setGameState({
                mode: gameMode,
                freeCells: [null,null,null,null],
                stock, waste,
                foundation: { [Suit.Hearts]: [], [Suit.Diamonds]: [], [Suit.Clubs]: [], [Suit.Spades]: [] },
                tableau: newTableau, score: 0, moves: 0, time: 0, gameWon: false
            });
            setHistory([]); setSelected(null); setHint(null);
            setStats(p => ({ ...p, gamesPlayed: p.gamesPlayed + 1 }));
            setShowWinningBounce(false);
            playSound('deal');
        }, [gameMode, playSound]);

        useEffect(() => { startNewGame(); }, [startNewGame]);

        useEffect(() => {
            const handlePrompt = (e) => { e.preventDefault(); setDeferredPrompt(e); setShowInstallButton(true); setTimeout(() => setShowInstallModal(true), 2000); };
            window.addEventListener('beforeinstallprompt', handlePrompt);
            return () => window.removeEventListener('beforeinstallprompt', handlePrompt);
        }, []);

        const handleInstallClick = async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                if (outcome === 'accepted') setDeferredPrompt(null);
            } else {
                setShowInstallModal(true);
            }
        };

        const saveHistory = () => {
            const current = gameStateRef.current;
            setHistory(prev => [...prev.slice(-49), JSON.parse(JSON.stringify(current))]);
        };
        
        const handleUndo = () => {
            if(!history.length) return;
            const previous = history[history.length-1];
            setGameState(previous);
            setHistory(h => h.slice(0, -1));
            gameStateRef.current = previous; 
            playSound('pickup');
        };

        const handleCardMove = (source, targetType, targetIndex, suit) => {
            saveHistory(); // CRITICAL: Save BEFORE mutation
            setGameState(prev => {
                const newState = JSON.parse(JSON.stringify(prev)); // Deep copy
                let cards = [];
                
                // --- EXTRACT FROM SOURCE ---
                if (source.pileType === 'freeCell') { 
                    cards = [newState.freeCells[source.pileIndex]]; 
                    newState.freeCells[source.pileIndex] = null; 
                }
                else if (source.pileType === 'waste') { 
                    cards = [newState.waste.pop()]; 
                }
                else if (source.pileType === 'tableau') {
                    const col = newState.tableau[source.pileIndex];
                    cards = col.slice(source.cardIndex);
                    
                    // FreeCell Super Move Check
                    if (prev.mode === GameMode.FreeCell && cards.length > 1) {
                         const emptyFC = newState.freeCells.filter(c => c === null).length;
                         let emptyTab = newState.tableau.filter(c => c.length === 0).length;
                         // If target is an empty tableau col, don't count it as "helper"
                         if (targetType === 'tableau' && newState.tableau[targetIndex].length === 0) emptyTab = Math.max(0, emptyTab - 1);
                         if (cards.length > getMaxMovableStack(emptyFC, emptyTab)) return prev; // Invalid move
                    }

                    newState.tableau[source.pileIndex] = col.slice(0, source.cardIndex);
                    
                    // Klondike Auto Flip
                    if (prev.mode === GameMode.Klondike && newState.tableau[source.pileIndex].length > 0) {
                        const top = newState.tableau[source.pileIndex][newState.tableau[source.pileIndex].length - 1];
                        if (!top.isFaceUp) { top.isFaceUp = true; newState.score += 5; }
                    }
                }

                // --- ADD TO TARGET ---
                if (targetType === 'freeCell') newState.freeCells[targetIndex] = cards[0];
                else if (targetType === 'tableau') newState.tableau[targetIndex].push(...cards);
                else if (targetType === 'foundation') newState.foundation[suit].push(cards[0]);
                
                newState.moves++;
                newState.score += 10;
                return newState;
            });
            setSelected(null);
            playSound('drop');
        };

        const handleCardClick = (card, pileType, pileIndex, cardIndex) => {
            if (!card && pileType === 'tableau') {
                if(selected && isMoveValid(selected.card, null, 'tableau', gameState.mode)) handleCardMove(selected, 'tableau', pileIndex);
                return;
            }
            if (!card || (!card.isFaceUp && pileType === 'tableau')) return;

            // Smart Move: Tap to Foundation
            if (pileType !== 'foundation') {
                const fPile = gameState.foundation[card.suit];
                const fTarget = fPile.length ? fPile[fPile.length-1] : null;
                // Only if it's the top card of the pile
                let isTop = false;
                if(pileType==='tableau' && cardIndex === gameState.tableau[pileIndex].length-1) isTop = true;
                if(pileType==='freeCell' || pileType==='waste') isTop = true;

                if (isTop) {
                    if(isMoveValid(card, fTarget, 'foundation', gameState.mode, card.suit)) {
                        handleCardMove({card, pileType, pileIndex, cardIndex}, 'foundation', null, card.suit);
                        return;
                    }
                }
            }

            if (selected && selected.card.id === card.id) { setSelected(null); return; }
            
            if(selected) {
                if (pileType === 'tableau') {
                     if (isMoveValid(selected.card, card, 'tableau', gameState.mode)) {
                         handleCardMove(selected, 'tableau', pileIndex);
                         return;
                     }
                }
                setSelected(null);
            } else {
                if (pileType === 'tableau') {
                    if (isStackValid(gameState.tableau[pileIndex].slice(cardIndex))) setSelected({card, pileType, pileIndex, cardIndex});
                } else if (pileType === 'freeCell' || pileType === 'waste') {
                    setSelected({card, pileType, pileIndex, cardIndex: 0});
                }
            }
        };

        const handleDragStart = (e, card, pileType, pileIndex, cardIndex, domEl) => {
             stopAdEvent(e);
             if(!card.isFaceUp) return;
             
             // Check if stack drag is valid
             if(pileType === 'tableau') {
                 const stack = gameState.tableau[pileIndex].slice(cardIndex);
                 if(!isStackValid(stack)) return;
                 // FreeCell Drag Limit Check
                 if(gameState.mode === GameMode.FreeCell && stack.length > 1) {
                     const emptyFC = gameState.freeCells.filter(c => c === null).length;
                     const emptyTab = gameState.tableau.filter(c => c.length === 0).length;
                     if(stack.length > getMaxMovableStack(emptyFC, emptyTab)) return;
                 }
             }
             
             playSound('pickup');

             const rect = domEl.getBoundingClientRect();
             const cardWidth = rect.width;

             let elements = [domEl];
             let stackOffset = 0;
             
             if(pileType === 'tableau') {
                 const siblings = Array.from(domEl.parentElement.children);
                 const idx = siblings.indexOf(domEl);
                 elements = siblings.slice(idx);
                 stackOffset = gameState.mode === GameMode.Klondike ? 15 : 28;
             }
             
             elements.forEach(el => { el.style.transition = 'none'; el.style.zIndex = '9999'; });
             
             activeDragRef.current = {
                 card, pileType, pileIndex, cardIndex,
                 startX: e.clientX, startY: e.clientY,
                 offsetX: e.clientX - rect.left, offsetY: e.clientY - rect.top,
                 elements, stackOffset, width: cardWidth
             };
             
             window.addEventListener('pointermove', handlePointerMove);
             window.addEventListener('pointerup', handlePointerUp);
        };

        const handlePointerMove = (e) => {
            if(!activeDragRef.current) return;
            if(dragRaf.current) cancelAnimationFrame(dragRaf.current);
            dragRaf.current = requestAnimationFrame(() => {
                if(!activeDragRef.current) return;
                const { elements, offsetX, offsetY, stackOffset, width } = activeDragRef.current;
                
                elements.forEach((el, i) => {
                    el.style.position = 'fixed';
                    el.style.width = width + 'px';
                    el.style.left = '0px'; el.style.top = '0px';
                    el.style.zIndex = (9999 + i).toString();
                    el.style.pointerEvents = 'none';
                    el.style.transform = `translate3d(${e.clientX - offsetX}px, ${e.clientY - offsetY + (i * stackOffset)}px, 0) scale(1.05)`;
                    el.style.boxShadow = '0 15px 30px rgba(0,0,0,0.5)';
                });
            });
        };

        const handlePointerUp = (e) => {
            window.removeEventListener('pointermove', handlePointerMove);
            window.removeEventListener('pointerup', handlePointerUp);
            if(!activeDragRef.current) return;
            
            const { card, pileType, pileIndex, cardIndex, elements, startX, startY } = activeDragRef.current;
            elements.forEach(el => { el.style = ''; });
            activeDragRef.current = null;

            if (Math.hypot(e.clientX - startX, e.clientY - startY) < 10) {
                handleCardClick(card, pileType, pileIndex, cardIndex);
            } else {
                const hits = document.elementsFromPoint(e.clientX, e.clientY);
                const dropZone = hits.find(el => el.dataset.dropZone === 'true');
                if (dropZone) {
                    const type = dropZone.dataset.dropType;
                    const idx = parseInt(dropZone.dataset.dropIndex);
                    const suit = dropZone.dataset.dropSuit;
                    
                    let targetCard = null;
                    if(type === 'tableau') {
                        const col = gameState.tableau[idx];
                        if(col.length) targetCard = col[col.length-1];
                    } else if (type === 'foundation') {
                        const pile = gameState.foundation[suit];
                        if(pile.length) targetCard = pile[pile.length-1];
                    } else if (type === 'freeCell') {
                        targetCard = gameState.freeCells[idx];
                    }
                    
                    if (isMoveValid(card, targetCard, type, gameState.mode, suit)) {
                        handleCardMove({card, pileType, pileIndex, cardIndex}, type, idx, suit);
                    }
                }
            }
        };

        const handleStock = () => {
             if(gameState.mode !== GameMode.Klondike) return;
             saveHistory();
             setGameState(prev => {
                 const ns = JSON.parse(JSON.stringify(prev));
                 if(ns.stock.length === 0) {
                     // Recycle waste to stock
                     ns.stock = ns.waste.reverse().map(c => ({...c, isFaceUp: false}));
                     ns.waste = [];
                 } else {
                     const c = ns.stock.pop();
                     c.isFaceUp = true;
                     ns.waste.push(c);
                 }
                 ns.moves++;
                 return ns;
             });
             setSelected(null);
             playSound('pickup');
        };
        
        const handleHint = () => {
              // 1. Check moves to Foundation
              for (let i = 0; i < gameState.tableau.length; i++) {
                  const col = gameState.tableau[i];
                  if(col.length){
                      const card = col[col.length-1];
                      const fTarget = gameState.foundation[card.suit].length ? gameState.foundation[card.suit][gameState.foundation[card.suit].length-1] : null;
                      if(isMoveValid(card, fTarget, 'foundation', gameState.mode, card.suit)){
                           setHint({sourceId: card.id, targetId: `foundation-${card.suit}`});
                           setTimeout(()=>setHint(null), 2000); return;
                      }
                  }
              }
              // 2. Check Tableau Moves
              for(let i=0; i<gameState.tableau.length; i++) {
                  const col = gameState.tableau[i];
                  if(col.length) {
                      const card = col[col.length-1];
                      for(let j=0; j<gameState.tableau.length; j++) {
                          if(i===j) continue;
                          const tCol = gameState.tableau[j];
                          const tCard = tCol.length ? tCol[tCol.length-1] : null;
                          if(isMoveValid(card, tCard, 'tableau', gameState.mode)) {
                               setHint({sourceId: card.id, targetId: `tableau-${j}`});
                               setTimeout(()=>setHint(null), 2000); return;
                          }
                      }
                  }
              }
        };

        const handleAuto = () => {
             let moved = false;
             let ns = JSON.parse(JSON.stringify(gameState));
             
             // Try to move anything to foundation
             const tryMove = (card, fromColIdx) => {
                 const fTarget = ns.foundation[card.suit].length ? ns.foundation[card.suit][ns.foundation[card.suit].length-1] : null;
                 if(isMoveValid(card, fTarget, 'foundation', ns.mode, card.suit)) {
                     ns.foundation[card.suit].push(card);
                     return true;
                 }
                 return false;
             };

             // Scan Tableau
             for(let i=0; i<ns.tableau.length; i++) {
                 const col = ns.tableau[i];
                 if(col.length) {
                     const card = col[col.length-1];
                     if(tryMove(card)) {
                         col.pop();
                         if(ns.mode === GameMode.Klondike && col.length && !col[col.length-1].isFaceUp) col[col.length-1].isFaceUp=true;
                         moved=true; break;
                     }
                 }
             }

             // Scan FreeCells/Waste
             if(!moved) {
                 if(ns.mode === GameMode.FreeCell) {
                     for(let i=0; i<ns.freeCells.length; i++) {
                         const card = ns.freeCells[i];
                         if(card && tryMove(card)) { ns.freeCells[i] = null; moved=true; break; }
                     }
                 } else {
                     if(ns.waste.length) {
                         const card = ns.waste[ns.waste.length-1];
                         if(tryMove(card)) { ns.waste.pop(); moved=true; }
                     }
                 }
             }

             if(moved) {
                 saveHistory();
                 ns.moves++; ns.score+=10;
                 setGameState(ns);
                 playSound('drop');
             }
        };

        // --- Simulated Stats ---
        useEffect(() => {
            setOnlineCount(Math.floor(Math.random() * (350 - 150) + 150));
            setVisitCount(1250000 + Math.floor(Math.random() * 50000));
            const onlineInterval = setInterval(() => { setOnlineCount(prev => Math.max(100, prev + Math.floor(Math.random() * 5) - 2)); }, 3000);
            const visitInterval = setInterval(() => { setVisitCount(prev => prev + 1); }, 8000);
            return () => { clearInterval(onlineInterval); clearInterval(visitInterval); }
        }, []);

        useEffect(() => {
            const total = Object.values(gameState.foundation).reduce((acc, pile) => acc + pile.length, 0);
            if (total === 52 && !gameState.gameWon) {
                setGameState(p => ({...p, gameWon: true}));
                playSound('win');
                setShowWinningBounce(true);
                setStats(p => ({ ...p, wins: p.wins + 1 }));
                setTimeout(() => setShowWinningBounce(false), 6000);
            }
        }, [gameState.foundation, playSound]);

        return (
            <div className={`min-h-[100dvh] flex flex-col ${isNightMode ? 'bg-[#0f172a]' : 'bg-[#0f3526]'} transition-colors duration-500 overflow-hidden`}>
                {/* Header */}
                <header className="px-2 py-2 bg-black/30 backdrop-blur-md sticky top-0 z-50 border-b border-white/5 pt-safe flex flex-wrap items-center justify-between gap-2 max-h-[60px]" onClick={stopAdEvent}>
                    <div className="flex items-center gap-2 shrink-0">
                        <div className="bg-yellow-500/20 p-1.5 rounded-lg"><Crown className="text-yellow-500 w-4 h-4 sm:w-5 sm:h-5" /></div>
                        <h1 className="text-white font-serif font-bold text-base sm:text-lg hidden xs:block">JosiPuff</h1>
                    </div>
                    
                    <div className="flex items-center gap-2 flex-1 justify-end">
                        <div className="flex bg-black/40 rounded-lg p-1 shrink-0 overflow-x-auto no-scrollbar">
                            <button onClick={(e)=>{ stopAdEvent(e); setGameMode(GameMode.FreeCell)}} className={`px-2 sm:px-3 py-1 text-[10px] sm:text-xs rounded whitespace-nowrap ${gameMode===GameMode.FreeCell?'bg-emerald-600 text-white':'text-white/50'}`}>FreeCell</button>
                            <button onClick={(e)=>{ stopAdEvent(e); setGameMode(GameMode.Klondike)}} className={`px-2 sm:px-3 py-1 text-[10px] sm:text-xs rounded whitespace-nowrap ${gameMode===GameMode.Klondike?'bg-emerald-600 text-white':'text-white/50'}`}>Clássico</button>
                        </div>
                        
                        <div className="flex items-center gap-1.5 shrink-0 border-l border-white/10 pl-1.5">
                                {showInstallButton && <button onClick={handleInstallClick} className="group relative px-3 py-1.5 rounded-full overflow-hidden transition-all duration-300 hover:scale-105 active:scale-95 animate-neon-pulse border border-purple-500/50">
                                <div className="absolute inset-0 bg-gradient-to-r from-purple-900 via-green-600 to-purple-900 opacity-90 group-hover:opacity-100 animate-gradient-xy"></div>
                                <div className="relative flex items-center gap-1.5 z-20">
                                    <div className="bg-white text-purple-700 rounded-full p-0.5"><Smartphone className="w-3 h-3 stroke-[3]" /></div>
                                    <span className="text-[10px] font-black uppercase tracking-wider text-white drop-shadow-md hidden sm:inline">Instalar</span>
                                </div>
                            </button>}
                            <button onClick={(e)=>{ stopAdEvent(e); setIsNightMode(!isNightMode)}} className="text-yellow-300 p-1.5 shrink-0 bg-white/5 rounded-full hover:bg-white/10 transition-colors">{isNightMode?<Sun size={16}/>:<Moon size={16}/>}</button>
                        </div>
                    </div>
                </header>
                
                {/* Stats */}
                <div className="flex justify-center py-1 bg-black/20 gap-6 text-xs font-mono text-white/80 border-b border-white/5 shrink-0" onClick={stopAdEvent}>
                    <span>SCORE: {gameState.score}</span>
                    <span>MOVES: {gameState.moves}</span>
                </div>

                {/* Main Game Area */}
                <main className="flex-grow flex flex-col justify-between items-center p-2 sm:p-4 z-10 relative overflow-y-auto pb-safe" onClick={stopAdEvent}>
                    <div className="w-full max-w-[1600px] grid grid-cols-1 lg:grid-cols-[160px_1fr_160px] gap-6">
                        
                        {/* LEFT AD (160x600) */}
                        <div className="hidden lg:flex flex-col gap-4">
                            <AdsterraBanner width={160} height={600} dataKey="3c0cd82368fb680b5d61812c81df31f2" />
                        </div>

                        {/* GAME BOARD */}
                        <div className="flex flex-col gap-1 sm:gap-3">
                            <div className="grid grid-cols-8 gap-1 sm:gap-3 mb-4 sm:mb-8">
                                {gameMode === GameMode.FreeCell ? (
                                    gameState.freeCells.map((c, i) => (
                                        <div key={i} data-drop-zone="true" data-drop-type="freeCell" data-drop-index={i} onClick={()=>handleCardClick(c, 'freeCell', i)} className={`aspect-[2.5/3.5] rounded bg-black/20 border-2 ${selected?.pileType==='freeCell' && selected.pileIndex===i ? 'border-yellow-400':'border-white/10'}`}>
                                            {c && <SolitaireCard card={c} draggable onPointerDown={(e,el)=>handleDragStart(e,c,'freeCell',i,0,el)} isSelected={selected?.card.id===c.id} />}
                                        </div>
                                    ))
                                ) : (
                                    <>
                                        <div className="col-span-1 aspect-[2.5/3.5] bg-black/20 rounded border-2 border-white/10 flex items-center justify-center cursor-pointer hover:bg-white/5 active:scale-95 transition" onClick={(e) => { stopAdEvent(e); handleStock(); }}>
                                            {gameState.stock.length > 0 ? (
                                                <div className="relative w-full h-full"><div className="absolute inset-0.5 bg-[#5c0b0b] rounded-[4%] border border-white/20"></div><RefreshCw className="absolute inset-0 m-auto text-white/20" /></div>
                                            ) : <RefreshCw className="text-white/20" />}
                                        </div>
                                        <div className="col-span-1 aspect-[2.5/3.5]">
                                            {gameState.waste.length>0 && <SolitaireCard card={gameState.waste[gameState.waste.length-1]} draggable onPointerDown={(e,el)=>handleDragStart(e,gameState.waste[gameState.waste.length-1],'waste',0,0,el)} isSelected={selected?.card.id===gameState.waste[gameState.waste.length-1].id} />}
                                        </div>
                                        <div className="col-span-2"></div>
                                    </>
                                )}
                                
                                {[Suit.Hearts, Suit.Diamonds, Suit.Clubs, Suit.Spades].map((s, i) => {
                                    const fPile = gameState.foundation[s];
                                    const top = fPile.length ? fPile[fPile.length-1] : null;
                                    return (
                                        <div key={s} data-drop-zone="true" data-drop-type="foundation" data-drop-suit={s} className={`col-span-1 aspect-[2.5/3.5] rounded bg-black/20 border-2 border-white/10 flex items-center justify-center ${hint?.targetId===`foundation-${s}`?'ring-2 ring-emerald-400':''}`}>
                                            {top ? <SolitaireCard card={top} /> : <SuitIcon suit={s} className="text-white/10 w-8 h-8" />}
                                        </div>
                                    );
                                })}
                            </div>

                            <div className="grid grid-cols-8 gap-1 sm:gap-3 h-full">
                                {gameState.tableau.map((col, i) => (
                                    <div key={i} data-drop-zone="true" data-drop-type="tableau" data-drop-index={i} onClick={()=>col.length===0 && handleCardClick(null, 'tableau', i)} className={`relative h-[60vh] ${hint?.targetId===`tableau-${i}`?'ring-2 ring-yellow-400/50 rounded':''}`}>
                                        {col.map((card, idx) => (
                                            <div key={card.id} className="absolute w-full" style={{top: `${idx * (gameMode===GameMode.Klondike && !card.isFaceUp ? 10 : 25)}px`, zIndex: idx}}>
                                                <SolitaireCard card={card} draggable={card.isFaceUp} onPointerDown={(e,el)=>handleDragStart(e,card,'tableau',i,idx,el)} isSelected={selected?.card.id===card.id} className={hint?.sourceId===card.id?'ring-2 ring-yellow-400':''} />
                                            </div>
                                        ))}
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* RIGHT AD (160x600) */}
                        <div className="hidden lg:flex flex-col gap-4">
                            <AdsterraBanner width={160} height={600} dataKey="3c0cd82368fb680b5d61812c81df31f2" />
                        </div>
                    </div>
                    
                    {/* Bottom Ad Container for Adsterra (320x50 fits here perfectly) */}
                    <div className="w-full max-w-[1000px] mt-8 mb-8 min-h-[60px] bg-black/10 rounded-lg flex items-center justify-center text-white/10 uppercase font-bold text-xs tracking-widest border-t border-white/5 overflow-hidden p-2">
                        <AdsterraBanner width={320} height={50} dataKey="40ea244e14933019fbfcc00a3875f885" />
                    </div>
                </main>

                <DraggableMenu>
                    <button onClick={startNewGame} className="flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 text-blue-400 transition">
                        <PlusCircle size={18} /><span className="text-[8px] uppercase font-bold mt-0.5">Novo</span>
                    </button>
                    <div className="w-px h-6 bg-white/10"></div>
                    <button onClick={(e)=>{ stopAdEvent(e); handleUndo()}} disabled={!history.length} className={`flex flex-col items-center p-1.5 rounded-lg w-11 ${!history.length?'opacity-30 cursor-not-allowed':'hover:bg-white/10'} text-white transition`}>
                        <Undo2 size={18} /><span className="text-[8px] uppercase font-bold mt-0.5">Undo</span>
                    </button>
                    <div className="w-px h-6 bg-white/10"></div>
                    <button onClick={(e)=>{ stopAdEvent(e); handleHint()}} className="flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 text-yellow-300 transition">
                        <Lightbulb size={18} /><span className="text-[8px] uppercase font-bold mt-0.5">Dica</span>
                    </button>
                    <div className="w-px h-6 bg-white/10"></div>
                    <button onClick={(e)=>{ stopAdEvent(e); handleAuto()}} className="flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 text-emerald-400 transition">
                        <Wand2 size={18} /><span className="text-[8px] uppercase font-bold mt-0.5">Auto</span>
                    </button>
                    <div className="w-px h-6 bg-white/10"></div>
                    <button onClick={(e)=>{ stopAdEvent(e); setIsSoundEnabled(!isSoundEnabled)}} className={`flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 transition ${isSoundEnabled?'text-white':'text-white/30'}`}>
                        {isSoundEnabled ? <Volume2 size={18} /> : <VolumeX size={18} />}
                        <span className="text-[8px] uppercase font-bold mt-0.5">Som</span>
                    </button>
                    <div className="w-px h-6 bg-white/10"></div>
                    <button onClick={(e)=>{ stopAdEvent(e); setShowStatsModal(true)}} className="flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 text-orange-400 transition">
                        <BarChart3 size={18} /><span className="text-[8px] uppercase font-bold mt-0.5">Stats</span>
                    </button>
                </DraggableMenu>

                <div className="fixed bottom-28 right-4 z-40 hidden md:flex flex-col gap-2 pointer-events-none">
                    <div className="bg-black/80 backdrop-blur-md text-white/90 text-xs font-mono py-1.5 px-3 rounded-full shadow-lg border border-white/10 flex items-center gap-2 pointer-events-auto">
                        <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse shadow-[0_0_8px_#22c55e]"></div>
                        <span className="font-bold text-white">{onlineCount}</span> online
                    </div>
                    <div className="bg-black/80 backdrop-blur-md text-white/90 text-xs font-mono py-1.5 px-3 rounded-full shadow-lg border border-white/10 flex items-center gap-2 pointer-events-auto">
                        <Eye className="w-3 h-3 text-blue-400" />
                        <span>{visitCount.toLocaleString()}</span> visitas
                    </div>
                </div>
                
                {showInstallModal && <InstallModal onInstall={handleInstallClick} onClose={()=>setShowInstallModal(false)} hasNativePrompt={!!deferredPrompt} isIOS={/iPhone|iPad|iPod/.test(navigator.userAgent)} />}
                {showStatsModal && <StatsModal onClose={()=>setShowStatsModal(false)} stats={stats} />}
                
                {(gameState.gameWon || showWinningBounce) && (
                    <>
                        <div className="fixed inset-0 z-[155] flex items-center justify-center pointer-events-none"><h1 className="text-[12vw] font-black uppercase tracking-tighter victory-text">Vitória!</h1></div>
                        <div className="fixed inset-0 z-[150] flex items-center justify-center pointer-events-auto bg-black/60 backdrop-blur-sm p-4">
                            <div className="bg-white rounded-2xl p-6 md:p-8 max-w-md w-full text-center shadow-2xl transform scale-105 border-4 border-yellow-400 relative overflow-hidden animate-in fade-in zoom-in">
                                  <div className="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-yellow-300 via-yellow-500 to-yellow-300"></div>
                                  <div className="inline-flex p-4 rounded-full bg-yellow-50 mb-4 ring-4 ring-yellow-100 shadow-lg animate-bounce">
                                      <Trophy className="w-16 h-16 text-yellow-600 drop-shadow-sm" />
                                  </div>
                                  <h2 className="text-4xl font-serif font-black text-gray-900 mb-2 uppercase tracking-tight">Vitória!</h2>
                                  <p className="text-gray-600 mb-6 font-medium">
                                      Parabéns! Você completou o jogo em <span className="text-emerald-600 font-bold">{gameState.moves}</span> jogadas.
                                  </p>
                                  <div className="w-full h-[60px] bg-gray-100 mb-6 rounded-lg overflow-hidden border border-gray-200 shadow-inner flex items-center justify-center">
                                      <AdsterraBanner width={320} height={50} dataKey="40ea244e14933019fbfcc00a3875f885" />
                                  </div>
                                  <button onClick={startNewGame} className="w-full bg-gradient-to-r from-emerald-600 to-emerald-500 hover:from-emerald-500 hover:to-emerald-400 text-white font-bold py-3.5 px-6 rounded-xl transition-all transform hover:scale-[1.02] shadow-lg active:scale-95 flex items-center justify-center gap-2">
                                      <RotateCcw className="w-5 h-5" /> Jogar Novamente
                                  </button>
                              </div>
                        </div>
                        <Confetti />
                        <WinningBounce foundation={gameState.foundation} />
                    </>
                )}
            </div>
        );
      }
      
      // --- Winning Bounce & Confetti Components ---
      const Confetti = () => {
         const canvasRef = useRef(null);
         useEffect(() => {
            const canvas = canvasRef.current; if(!canvas) return;
            const ctx = canvas.getContext('2d');
            let w = canvas.width = window.innerWidth; let h = canvas.height = window.innerHeight;
            const particles = Array.from({length: 150}, () => ({
                x: Math.random()*w, y: Math.random()*h - h,
                vx: Math.random()*4-2, vy: Math.random()*5+2,
                color: ['#FFD700','#FF0000','#00FF00','#0000FF','#FF00FF'][Math.floor(Math.random()*5)],
                size: Math.random()*10+5, rot: Math.random()*360, rotS: Math.random()*10-5
            }));
            let anim;
            const loop = () => {
                ctx.clearRect(0,0,w,h);
                particles.forEach(p => {
                    p.x+=p.vx; p.y+=p.vy; p.rot+=p.rotS;
                    if(p.y>h) { p.y=-p.size; p.x=Math.random()*w; }
                    ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot*Math.PI/180);
                    ctx.fillStyle=p.color; ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size); ctx.restore();
                });
                anim = requestAnimationFrame(loop);
            };
            loop();
            return () => cancelAnimationFrame(anim);
         }, []);
         return <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-[150]" />;
      };

      const WinningBounce = ({ foundation }) => {
          const canvasRef = useRef(null);
          useEffect(() => {
              const canvas = canvasRef.current; if(!canvas) return;
              const ctx = canvas.getContext('2d');
              let w = canvas.width = window.innerWidth; let h = canvas.height = window.innerHeight;
              const cards = [];
              const gravity = 0.8;
              let frame = 0, anim;
              
              const spawn = () => {
                  if(frame % 5 === 0 && cards.length < 200) {
                      cards.push({
                          x: Math.random() * w, y: -100,
                          vx: Math.random()*10-5, vy: 0,
                          w: 40, h: 56, color: Math.random()>0.5?'#d40000':'#1a1a1a', bounce: 0.7+Math.random()*0.2
                      });
                  }
              };
              
              const loop = () => {
                  ctx.clearRect(0,0,w,h);
                  spawn();
                  cards.forEach(c => {
                      c.vy += gravity; c.x += c.vx; c.y += c.vy;
                      if(c.y + c.h > h) { c.y = h - c.h; c.vy *= -c.bounce; if(Math.abs(c.vy)<gravity*2) c.vy=0; }
                      ctx.fillStyle = '#fff'; ctx.fillRect(c.x,c.y,c.w,c.h);
                      ctx.fillStyle = c.color; ctx.fillRect(c.x+5,c.y+5,c.w-10,c.h-10);
                  });
                  frame++;
                  anim = requestAnimationFrame(loop);
              };
              loop();
              return () => cancelAnimationFrame(anim);
          }, []);
          return <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-[160]" />;
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>
