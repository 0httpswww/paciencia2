<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>JosiPuff - Jogos</title>
    <meta name="description" content="Jogue JosiPuff: Solitaire, FreeCell e Tetris Grátis. Leve, rápido e funciona offline.">
    <meta name="keywords" content="jogo online, jogo paciencia, jogo paciencia dw, jogo paciencia josiane, solitaire, freecell, tetris, blocos, josipuff">
    <meta name="theme-color" content="#0f3526">
    <meta name="monetag" content="90e74a99c3a7b6c2ba03e69c9477a61d">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@700;900&family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

    <!-- Global PWA Event Capture -->
    <script>
        window.deferredInstallPrompt = null;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            window.deferredInstallPrompt = e;
            window.dispatchEvent(new Event('install-prompt-ready'));
            console.log('Native Install Prompt Captured');
        });
    </script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    screens: { 'xs': '370px' },
                    keyframes: {
                        'gradient-xy': {
                            '0%, 100%': { 'background-position': '0% 50%' },
                            '50%': { 'background-position': '100% 50%' }
                        },
                        'neon-pulse': {
                            '0%, 100%': { boxShadow: '0 0 5px #9333ea, 0 0 10px #9333ea, borderColor: #9333ea' },
                            '50%': { boxShadow: '0 0 5px #22c55e, 0 0 10px #22c55e, borderColor: #22c55e' }
                        },
                        shimmer: {
                            '0%': { transform: 'translateX(-150%) skewX(-15deg)' },
                            '100%': { transform: 'translateX(150%) skewX(-15deg)' }
                        }
                    },
                    animation: {
                        'gradient-xy': 'gradient-xy 3s ease infinite',
                        'neon-pulse': 'neon-pulse 2s infinite',
                    }
                }
            }
        }
    </script>
    
    <!-- Babel for React -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Monetag Scripts -->
    <script src="https://fpyf8.com/88/tag.min.js" data-zone="187944" async data-cfasync="false"></script>
    <script>(function(s){s.dataset.zone='10234172',s.src='https://nap5k.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>
    <script>(function(s){s.dataset.zone='10236160',s.src='https://nap5k.com/tag.min.js'})([document.documentElement, document.body].filter(Boolean).pop().appendChild(document.createElement('script')))</script>

    <style>
        html, body { height: 100%; overflow: hidden; }
        body { 
            overscroll-behavior: none; touch-action: none; -webkit-tap-highlight-color: transparent;
            font-family: 'Inter', sans-serif; background-color: #0f3526; user-select: none; -webkit-user-select: none;
        }
        #root { height: 100%; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .pt-safe { padding-top: env(safe-area-inset-top); }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        
        .hint-source { animation: pulse-yellow 1.5s infinite; filter: brightness(1.2); }
        .hint-target { animation: pulse-green 1.5s infinite; box-shadow: 0 0 15px #4ade80; z-index: 50; }
        @keyframes pulse-yellow { 0%, 100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(250, 204, 21, 0); } }
        @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); } }
        
        .victory-text {
            font-family: 'Crimson Pro', serif;
            background: linear-gradient(to bottom, #fde047, #ca8a04); -webkit-background-clip: text; color: transparent;
            text-shadow: 0px 4px 10px rgba(0,0,0,0.5); filter: drop-shadow(0 0 20px rgba(234, 179, 8, 0.6));
            animation: zoom-in-bounce 1s ease-out forwards;
        }
        @keyframes zoom-in-bounce {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; } 60% { transform: scale(1.2) rotate(5deg); opacity: 1; } 100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes win-wave { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-30px); } }
        .animate-win-wave { animation: win-wave 1s ease-in-out infinite; }

        /* Tetris Grid */
        .tetris-grid { display: grid; grid-template-rows: repeat(20, 1fr); grid-template-columns: repeat(10, 1fr); gap: 1px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.1); }
        .tetris-cell { width: 100%; height: 100%; border-radius: 2px; }
        
        /* Space Shooter Canvas */
        .shooter-canvas { border: 2px solid rgba(255,255,255,0.1); background: black; box-shadow: 0 0 20px rgba(0,0,0,0.8); cursor: crosshair; touch-action: none; }
    </style>
    
    <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useCallback, useRef, memo } from 'react';
      import { createRoot } from 'react-dom/client';
      import { Heart, Diamond, Club, Spade, Trophy, Clock, RotateCcw, X, LayoutGrid, RefreshCw, Eye, Play, Pause, Volume2, VolumeX, Maximize, Crown, Undo2, Lightbulb, Wand2, CalendarCheck, Moon, Sun, Smartphone, Gift, CheckCircle2, Share, GripHorizontal, PlusCircle, ArrowLeft, ArrowRight, ArrowDown, RotateCw, Rocket, Zap, ShieldAlert } from 'lucide-react';

      // --- TYPES & CONSTANTS ---
      const Suit = { Hearts: 'hearts', Diamonds: 'diamonds', Clubs: 'clubs', Spades: 'spades' };
      const Rank = { Ace: 1, Two: 2, Three: 3, Four: 4, Five: 5, Six: 6, Seven: 7, Eight: 8, Nine: 9, Ten: 10, Jack: 11, Queen: 12, King: 13 };
      const GameMode = { FreeCell: 'freeCell', Klondike: 'klondike', Tetris: 'tetris', Shooter: 'shooter' };
      
      const TETROMINOS = {
          0: { shape: [[0]], color: '0, 0, 0' },
          I: { shape: [[0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0], [0, 'I', 0, 0]], color: '6, 182, 212' }, // Cyan
          J: { shape: [[0, 'J', 0], [0, 'J', 0], ['J', 'J', 0]], color: '59, 130, 246' }, // Blue
          L: { shape: [[0, 'L', 0], [0, 'L', 0], [0, 'L', 'L']], color: '249, 115, 22' }, // Orange
          O: { shape: [['O', 'O'], ['O', 'O']], color: '234, 179, 8' }, // Yellow
          S: { shape: [[0, 'S', 'S'], ['S', 'S', 0], [0, 0, 0]], color: '34, 197, 94' }, // Green
          T: { shape: [[0, 0, 0], ['T', 'T', 'T'], [0, 'T', 0]], color: '168, 85, 247' }, // Purple
          Z: { shape: [['Z', 'Z', 0], [0, 'Z', 'Z'], [0, 0, 0]], color: '239, 68, 68' }, // Red
      };

      const randomTetromino = () => {
          const tetrominos = 'IJLOSTZ';
          const rand = tetrominos[Math.floor(Math.random() * tetrominos.length)];
          return TETROMINOS[rand];
      };

      const stopAdEvent = (e) => {
          if (!e) return;
          e.stopPropagation();
          if (e.nativeEvent) e.nativeEvent.stopImmediatePropagation();
      };

      const getCardColor = (suit) => (suit === Suit.Hearts || suit === Suit.Diamonds ? 'red' : 'black');

      // --- SOUND MANAGER ---
      const useSound = (enabled) => {
          const audioCtx = useRef(null);
          
          const initAudio = () => {
              if (!audioCtx.current) {
                  const AudioContext = window.AudioContext || window.webkitAudioContext;
                  if (AudioContext) audioCtx.current = new AudioContext();
              }
              if (audioCtx.current && audioCtx.current.state === 'suspended') audioCtx.current.resume();
          };

          const play = useCallback((type) => {
              if (!enabled) return;
              initAudio();
              if (!audioCtx.current) return;
              
              const ctx = audioCtx.current;
              const t = ctx.currentTime;
              const gain = ctx.createGain();
              gain.connect(ctx.destination);

              if (type === 'pickup' || type === 'rotate') {
                  const osc = ctx.createOscillator();
                  osc.type = 'triangle';
                  osc.frequency.setValueAtTime(400, t);
                  osc.frequency.exponentialRampToValueAtTime(800, t + 0.05);
                  gain.gain.setValueAtTime(0.05, t);
                  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                  osc.connect(gain);
                  osc.start(t);
                  osc.stop(t + 0.05);
              } else if (type === 'drop' || type === 'softdrop') {
                  const osc = ctx.createOscillator();
                  osc.type = 'sine';
                  osc.frequency.setValueAtTime(type==='drop'?120:100, t);
                  osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
                  gain.gain.setValueAtTime(0.1, t);
                  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                  osc.connect(gain);
                  osc.start(t);
                  osc.stop(t + 0.1);
              } else if (type === 'win' || type === 'line') {
                  const notes = type === 'win' ? [523, 659, 783, 1046] : [440, 554, 659];
                  notes.forEach((freq, i) => {
                      const osc = ctx.createOscillator();
                      const g = ctx.createGain();
                      osc.type = 'square';
                      osc.frequency.value = freq;
                      g.connect(ctx.destination);
                      osc.connect(g);
                      const st = t + (i * 0.08);
                      g.gain.setValueAtTime(0.02, st);
                      g.gain.exponentialRampToValueAtTime(0.001, st + 0.3);
                      osc.start(st);
                      osc.stop(st + 0.3);
                  });
              } else if (type === 'deal') {
                  const bufferSize = ctx.sampleRate * 0.1;
                  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                  const data = buffer.getChannelData(0);
                  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                  const noise = ctx.createBufferSource();
                  noise.buffer = buffer;
                  const filter = ctx.createBiquadFilter();
                  filter.type = 'lowpass';
                  filter.frequency.value = 800;
                  noise.connect(filter);
                  filter.connect(gain);
                  gain.gain.setValueAtTime(0.05, t);
                  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                  noise.start(t);
              } else if (type === 'shoot') {
                  const osc = ctx.createOscillator();
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(800, t);
                  osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
                  gain.gain.setValueAtTime(0.05, t);
                  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                  osc.connect(gain);
                  osc.start(t);
                  osc.stop(t + 0.15);
              } else if (type === 'powerup' || type === 'heal') {
                   const osc = ctx.createOscillator();
                   osc.type = 'sine';
                   osc.frequency.setValueAtTime(type==='heal'?300:440, t);
                   osc.frequency.linearRampToValueAtTime(type==='heal'?600:880, t + 0.2);
                   gain.gain.setValueAtTime(0.1, t);
                   gain.gain.linearRampToValueAtTime(0.001, t + 0.2);
                   osc.connect(gain);
                   osc.start(t);
                   osc.stop(t + 0.2);
              } else if (type === 'explosion') {
                  const bufferSize = ctx.sampleRate * 0.3;
                  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                  const data = buffer.getChannelData(0);
                  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                  const noise = ctx.createBufferSource();
                  noise.buffer = buffer;
                  const filter = ctx.createBiquadFilter();
                  filter.type = 'lowpass';
                  filter.frequency.value = 1000;
                  filter.frequency.exponentialRampToValueAtTime(100, t + 0.2);
                  noise.connect(filter);
                  filter.connect(gain);
                  gain.gain.setValueAtTime(0.1, t);
                  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                  noise.start(t);
              } else if (type === 'boss_roar') {
                   const osc = ctx.createOscillator();
                   osc.type = 'sawtooth';
                   osc.frequency.setValueAtTime(100, t);
                   osc.frequency.exponentialRampToValueAtTime(50, t + 1.0);
                   gain.gain.setValueAtTime(0.3, t);
                   gain.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
                   osc.connect(gain);
                   osc.start(t);
                   osc.stop(t + 1.0);
              }
          }, [enabled]);
          return play;
      };

      // --- SOLITAIRE HELPERS ---
      const createDeck = (faceUp = true) => {
        const deck = [];
        const suits = [Suit.Hearts, Suit.Diamonds, Suit.Clubs, Suit.Spades];
        Object.values(Rank).forEach(rank => suits.forEach(suit => deck.push({ id: `${suit}-${rank}`, suit, rank, isFaceUp: faceUp })));
        return deck;
      };
      const shuffleDeck = (deck) => {
        const newDeck = [...deck];
        for (let i = newDeck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
        }
        return newDeck;
      };
      const isMoveValid = (card, targetCard, targetType, mode, targetSuit) => {
        if (targetType === 'freeCell') return targetCard === null && mode === GameMode.FreeCell;
        if (targetType === 'foundation') {
          if (!targetCard) return card.rank === Rank.Ace && card.suit === targetSuit;
          return card.suit === targetCard.suit && card.rank === targetCard.rank + 1;
        }
        if (targetType === 'tableau') {
          if (!targetCard) {
            if (mode === GameMode.Klondike) return card.rank === Rank.King;
            return true;
          }
          return getCardColor(card.suit) !== getCardColor(targetCard.suit) && card.rank === targetCard.rank - 1;
        }
        return false;
      };
      const isStackValid = (cards) => {
        if (cards.length <= 1) return true;
        for (let i = 0; i < cards.length - 1; i++) {
          const current = cards[i], next = cards[i + 1];
          if (!current.isFaceUp || !next.isFaceUp) return false;
          if (getCardColor(current.suit) === getCardColor(next.suit) || current.rank !== next.rank + 1) return false;
        }
        return true;
      };
      const getMaxMovableStack = (emptyFreeCells, emptyTableauCols) => (1 + emptyFreeCells) * Math.pow(2, emptyTableauCols);

      // --- COMPONENTS ---
      const SuitIcon = ({ suit, className, fill = true }) => {
        const props = { className, strokeWidth: fill ? 0 : 2 };
        switch (suit) {
          case Suit.Hearts: return <Heart {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Diamonds: return <Diamond {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Clubs: return <Club {...props} fill={fill ? "currentColor" : "none"} />;
          case Suit.Spades: return <Spade {...props} fill={fill ? "currentColor" : "none"} />;
        }
      };

      const RankLabel = ({ rank }) => {
        let label = rank.toString();
        if (rank === 1) label = 'A'; else if (rank === 11) label = 'J'; else if (rank === 12) label = 'Q'; else if (rank === 13) label = 'K';
        return <span className="font-serif tracking-tighter font-black drop-shadow-[0_1px_0_rgba(0,0,0,0.1)]">{label}</span>;
      };

      const SolitaireCard = memo(({ card, onPointerDown, isSelected, className = '', style, draggable }) => {
        const isFaceCard = card.rank >= 11;
        const isAce = card.rank === 1;
        const color = getCardColor(card.suit);
        const textColor = color === 'red' ? 'text-[#d40000]' : 'text-[#1a1a1a]';
        
        return (
          <div className={`relative w-full aspect-[2.5/3.5] select-none [perspective:1000px] ${draggable ? 'cursor-grab active:cursor-grabbing' : ''} ${className}`}
            onPointerDown={(e) => { if (onPointerDown) { stopAdEvent(e); onPointerDown(e, e.currentTarget); }}} onClick={stopAdEvent} style={{ ...style, zIndex: isSelected ? 100 : style?.zIndex }}>
            <div className={`w-full h-full relative transition-transform duration-200 ease-[cubic-bezier(0.25,0.8,0.25,1)] [transform-style:preserve-3d] will-change-transform ${card.isFaceUp ? '[transform:rotateY(0deg)]' : '[transform:rotateY(180deg)]'}`}>
              <div className={`absolute inset-0 [backface-visibility:hidden] bg-[#fcfaf5] rounded-[6%] overflow-hidden flex items-center justify-center transition-all duration-300 ${isSelected ? 'ring-[3px] ring-yellow-400 -translate-y-2 brightness-105' : 'shadow-md'}`}>
                 <div className={`absolute top-[4%] left-[6%] flex flex-col items-center leading-none ${textColor} w-[18%]`}>
                    <span className="text-[min(18px,4.5vw)] sm:text-2xl font-bold font-serif"><RankLabel rank={card.rank} /></span>
                    <SuitIcon suit={card.suit} className="w-[min(14px,3.5vw)] h-[min(14px,3.5vw)] sm:w-4 sm:h-4" />
                 </div>
                 <div className={`absolute inset-[13%] flex items-center justify-center pointer-events-none ${textColor}`}>
                     {isFaceCard || isAce ? <SuitIcon suit={card.suit} className="w-[60%] h-[60%] drop-shadow-lg" /> : <div className="text-xl font-black">{card.rank}</div>}
                 </div>
                 <div className={`absolute bottom-[4%] right-[6%] flex flex-col items-center leading-none rotate-180 ${textColor} w-[18%]`}>
                    <span className="text-[min(18px,4.5vw)] sm:text-2xl font-bold font-serif"><RankLabel rank={card.rank} /></span>
                    <SuitIcon suit={card.suit} className="w-[min(14px,3.5vw)] h-[min(14px,3.5vw)] sm:w-4 sm:h-4" />
                 </div>
              </div>
              <div className="absolute inset-0 [backface-visibility:hidden] [transform:rotateY(180deg)] bg-[#7f1d1d] rounded-[6%] border-[3px] border-[#fcfaf5] shadow-inner flex items-center justify-center">
                 <Crown className="w-[60%] h-[60%] text-[#fbbf24] drop-shadow-md" />
              </div>
            </div>
          </div>
        );
      });

      const AdsterraBanner = ({ width, height, dataKey }) => {
          const containerRef = useRef(null);
          useEffect(() => {
              if (!containerRef.current || !dataKey) return;
              const iframe = document.createElement('iframe');
              iframe.width = width; iframe.height = height; iframe.style.border = 'none'; iframe.scrolling = 'no';
              containerRef.current.innerHTML = ''; containerRef.current.appendChild(iframe);
              const doc = iframe.contentWindow.document;
              doc.open();
              doc.write(`<html><body style="margin:0;padding:0;background:transparent;display:flex;justify-content:center;overflow:hidden;"><script type="text/javascript">atOptions={'key':'${dataKey}','format':'iframe','height':${height},'width':${width},'params':{}};<\/script><script type="text/javascript" src="//www.highperformanceformat.com/${dataKey}/invoke.js"><\/script></body></html>`);
              doc.close();
          }, [width, height, dataKey]);
          return <div ref={containerRef} style={{ width, height }} className="mx-auto flex justify-center items-center" />;
      };

      const DraggableMenu = ({ children }) => {
         const [pos, setPos] = useState({ x: 0, y: 0 }); const initialized = useRef(false); const [isDragging, setIsDragging] = useState(false); const offset = useRef({ x: 0, y: 0 });
         useEffect(() => { if(!initialized.current) { setPos({ x: window.innerWidth / 2, y: window.innerHeight - 100 }); initialized.current = true; } }, []);
         const handlePointerDown = (e) => { if (e.target.closest('button')) return; stopAdEvent(e); setIsDragging(true); offset.current = { x: e.clientX - pos.x, y: e.clientY - pos.y }; e.target.setPointerCapture(e.pointerId); };
         const handlePointerMove = (e) => { if (!isDragging) return; stopAdEvent(e); setPos({ x: Math.min(window.innerWidth - 60, Math.max(60, e.clientX - offset.current.x)), y: Math.min(window.innerHeight - 60, Math.max(60, e.clientY - offset.current.y)) }); };
         const handlePointerUp = (e) => { if(isDragging) { setIsDragging(false); e.target.releasePointerCapture(e.pointerId); } };
         if (!initialized.current) return null;
         return (
             <div className="fixed z-[200] touch-none flex flex-col items-center gap-1 cursor-grab active:cursor-grabbing" style={{ left: pos.x, top: pos.y, transform: 'translate(-50%, -50%)' }} onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp}>
                <div className="bg-[#0a1f16]/95 backdrop-blur-xl p-1.5 rounded-2xl border border-yellow-500/30 shadow-2xl flex items-center gap-1.5 pointer-events-auto select-none ring-1 ring-white/10">
                    <div className="text-white/20 mr-0.5"><GripHorizontal size={14} /></div>
                    {children}
                </div>
             </div>
         );
      };

      const InstallModal = ({ onInstall, onClose, isIOS, deferredPrompt }) => {
        const handleSimClick = () => {
             if (deferredPrompt) onInstall();
             else {
                 const content = document.getElementById('modal-content-area');
                 if(content) content.innerHTML = `<div class="text-left bg-white/5 p-4 rounded-xl border border-white/10 mb-6 text-xs text-gray-300 space-y-2 animate-in slide-in-from-bottom-2"><p class="font-bold text-yellow-400">Instalação Manual:</p><p>1. Abra o menu do navegador (três pontos)</p><p>2. Toque em <strong>"Adicionar à Tela Inicial"</strong></p><div class="text-center mt-4"><button id="close-btn-inner" class="py-2 px-6 bg-white/10 rounded-lg w-full">OK</button></div></div>`;
                 document.getElementById('close-btn-inner').onclick = onClose;
             }
        };
        return (
            <div className="fixed inset-0 z-[300] bg-black/90 backdrop-blur-md flex items-center justify-center p-4" onClick={stopAdEvent}>
                <div className="bg-[#1e293b] rounded-3xl p-8 max-w-sm w-full text-center border border-yellow-500/50 shadow-2xl relative overflow-hidden animate-in fade-in zoom-in">
                    <div className="relative z-10" id="modal-content-area">
                        <div className="mb-6 inline-block relative"><div className="absolute inset-0 bg-gradient-to-r from-purple-500 to-green-500 rounded-full blur-xl opacity-50 animate-pulse"></div><div className="relative bg-white/10 p-2 rounded-xl border border-white/20"><img src="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png" className="w-20 h-20 object-contain drop-shadow-lg" /></div></div>
                        <h2 className="text-2xl font-black text-white mb-2 uppercase tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-yellow-600">INSTALAR O APP?</h2>
                        <p className="text-gray-300 mb-8 text-sm leading-relaxed">Deseja adicionar o atalho à sua área de trabalho para jogar em tela cheia?</p>
                        {isIOS ? ( <div className="text-left bg-white/5 p-4 rounded-xl border border-white/10 mb-6 text-xs text-gray-300 space-y-2"><p><strong>Instalação Manual:</strong></p><p>1. Toque em <Share className="w-3 h-3 inline" /> <strong>Compartilhar</strong></p><p>2. Selecione <strong>Adicionar à Tela de Início</strong></p><button onClick={onClose} className="mt-4 w-full py-2.5 rounded-lg bg-white/10">Entendi</button></div> ) : ( <div className="flex gap-4"><button onClick={onClose} className="flex-1 py-4 rounded-xl font-bold uppercase text-white/70 bg-red-500/10 border border-red-500/20">NÃO</button><button onClick={handleSimClick} className="flex-[1.5] py-4 rounded-xl font-bold uppercase text-white bg-gradient-to-r from-green-600 to-emerald-600 animate-pulse shadow-lg">SIM</button></div> )}
                    </div>
                </div>
            </div>
        );
      };

      // --- SPACE SHOOTER GAME ---
      const ENEMY_TYPES = [
          { type: 'kamikaze', color: '#ef4444', hp: 1, speed: 2, score: 100, shape: 'triangle' },
          { type: 'shooter', color: '#a855f7', hp: 3, speed: 1.5, score: 300, shape: 'square', shoots: true },
          { type: 'tank', color: '#f97316', hp: 6, speed: 0.8, score: 500, shape: 'circle' },
          { type: 'speedster', color: '#eab308', hp: 2, speed: 4, score: 200, shape: 'dart' }
      ];

      const SpaceShooterGame = ({ playSound, onGameOver, resetTrigger }) => {
         const canvasRef = useRef(null);
         const [score, setScore] = useState(0);
         const [gameOver, setGameOver] = useState(false);
         const gameOverRef = useRef(false);
         const [playerHp, setPlayerHp] = useState(100);
         const [powerLevel, setPowerLevel] = useState(1);
         const [bossActive, setBossActive] = useState(false);
         
         const state = useRef({
             player: { x: 0, y: 0, w: 30, h: 40, speed: 5, maxHp: 100 },
             bullets: [],
             enemyBullets: [],
             enemies: [],
             particles: [],
             items: [],
             keys: {},
             lastShot: 0,
             enemyTimer: 0,
             frameCount: 0,
             stars: [],
             difficulty: 1,
             score: 0,
             powerLevel: 1,
             nextBossThreshold: 5000,
             boss: null,
             bossLevel: 0
         });
         const animationRef = useRef(null);

         useEffect(() => {
             gameOverRef.current = gameOver;
         }, [gameOver]);

         const restart = useCallback(() => {
             state.current = {
                 player: { x: 300, y: 700, w: 30, h: 40, speed: 5, maxHp: 100 },
                 bullets: [], enemyBullets: [], items: [], enemies: [], particles: [], keys: {}, lastShot: 0, enemyTimer: 0, frameCount: 0, stars: state.current.stars, difficulty: 1,
                 score: 0, powerLevel: 1, nextBossThreshold: 5000, boss: null, bossLevel: 0
             };
             setScore(0);
             setPlayerHp(100);
             setPowerLevel(1);
             setBossActive(false);
             setGameOver(false);
             gameOverRef.current = false;
         }, []);

         useEffect(() => {
             if (resetTrigger > 0) {
                 restart();
             }
         }, [resetTrigger, restart]);

         useEffect(() => {
             const canvas = canvasRef.current;
             if(!canvas) return;
             const ctx = canvas.getContext('2d');
             
             // Resize logic
             const resize = () => {
                 const parentWidth = canvas.parentElement ? canvas.parentElement.clientWidth : window.innerWidth;
                 canvas.width = Math.min(parentWidth, 600);
                 canvas.height = Math.min(window.innerHeight - 200, 800);
                 
                 // Initial position or reset if needed
                 if(state.current.player.x === 0 && state.current.player.y === 0) {
                     state.current.player.x = canvas.width / 2;
                     state.current.player.y = canvas.height - 100;
                 } else {
                     // Clamp current pos
                     state.current.player.x = Math.max(15, Math.min(canvas.width - 15, state.current.player.x));
                     state.current.player.y = Math.max(20, Math.min(canvas.height - 20, state.current.player.y));
                 }
                 
                 if(state.current.stars.length === 0) {
                     state.current.stars = Array.from({length: 50}, () => ({
                         x: Math.random() * canvas.width,
                         y: Math.random() * canvas.height,
                         s: Math.random() * 2 + 1,
                         v: Math.random() * 3 + 1
                     }));
                 }
             };
             resize();
             window.addEventListener('resize', resize);
             
             // Controls
             const handleDown = (e) => state.current.keys[e.code] = true;
             const handleUp = (e) => state.current.keys[e.code] = false;
             window.addEventListener('keydown', handleDown);
             window.addEventListener('keyup', handleUp);
             
             // Touch Controls
             let isTouching = false;
             const handleTouchStart = (e) => {
                 isTouching = true;
                 state.current.keys['Space'] = true; 
             };
             const handleTouchMove = (e) => {
                 if (!isTouching) return;
                 if(e.cancelable) e.preventDefault(); 
                 
                 const t = e.touches[0];
                 const rect = canvas.getBoundingClientRect();
                 const touchX = t.clientX - rect.left;
                 const touchY = t.clientY - rect.top;

                 const dx = touchX - state.current.player.x;
                 const dy = touchY - state.current.player.y;
                 
                 state.current.player.x += dx * 0.2; 
                 state.current.player.y += dy * 0.2;

                 state.current.player.x = Math.max(15, Math.min(canvas.width - 15, state.current.player.x));
                 state.current.player.y = Math.max(20, Math.min(canvas.height - 20, state.current.player.y));
             };
             const handleTouchEnd = () => { isTouching = false; state.current.keys['Space'] = false; };
             
             canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
             canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
             canvas.addEventListener('touchend', handleTouchEnd);

             // Game Loop
             const loop = () => {
                 if(gameOverRef.current) return;
                 
                 const st = state.current;
                 st.frameCount++;
                 
                 // Update Difficulty
                 if (!st.boss) {
                    st.difficulty = 1 + Math.min(5, Math.floor(st.score / 2000) * 0.5);
                 }

                 // BOSS TRIGGER
                 if (st.score >= st.nextBossThreshold && !st.boss) {
                     // SPAWN BOSS
                     st.bossLevel++; // Increment Boss Level
                     
                     // Increase size by 20% each level
                     const sizeMult = 1 + (st.bossLevel * 0.2);
                     
                     st.boss = {
                         x: canvas.width / 2, y: -150,
                         w: Math.min(canvas.width - 40, 120 * sizeMult), // Cap width slightly
                         h: 80 * sizeMult,
                         // Exponential HP Growth: Base * 1.5 ^ Level
                         hp: 1000 * Math.pow(1.5, st.bossLevel), 
                         maxHp: 1000 * Math.pow(1.5, st.bossLevel),
                         vx: 2, state: 'entering',
                         timer: 0
                     };
                     st.enemies = []; // Clear existing enemies
                     setBossActive(true);
                     playSound('boss_roar');
                 }
                 
                 // Update Background
                 ctx.fillStyle = '#000';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                 
                 ctx.fillStyle = '#fff';
                 st.stars.forEach(s => {
                     s.y += s.v;
                     if(s.y > canvas.height) { s.y = 0; s.x = Math.random() * canvas.width; }
                     ctx.fillRect(s.x, s.y, s.s, s.s);
                 });
                 
                 // Update Player (Keyboard)
                 if(st.keys['ArrowLeft']) st.player.x -= st.player.speed;
                 if(st.keys['ArrowRight']) st.player.x += st.player.speed;
                 if(st.keys['ArrowUp']) st.player.y -= st.player.speed;
                 if(st.keys['ArrowDown']) st.player.y += st.player.speed;
                 
                 st.player.x = Math.max(15, Math.min(canvas.width - 15, st.player.x));
                 st.player.y = Math.max(20, Math.min(canvas.height - 20, st.player.y));
                 
                 // Shoot
                 if(st.keys['Space'] || st.frameCount % 10 === 0) { 
                    if(st.frameCount - st.lastShot > 15) {
                        const shotColor = st.powerLevel === 1 ? '#fbbf24' : st.powerLevel === 2 ? '#3b82f6' : st.powerLevel === 3 ? '#22c55e' : st.powerLevel === 4 ? '#f472b6' : st.powerLevel === 5 ? '#a855f7' : '#22d3ee';
                        
                        // Center shot (Always)
                        if (st.powerLevel <= 5) {
                            st.bullets.push({ x: st.player.x, y: st.player.y - 20, v: 8, color: shotColor });
                        }
                        
                        // Level 2+
                        if (st.powerLevel >= 2 && st.powerLevel <= 5) {
                             st.bullets.push({ x: st.player.x - 10, y: st.player.y - 15, v: 7, vx: -0.5, color: shotColor });
                             st.bullets.push({ x: st.player.x + 10, y: st.player.y - 15, v: 7, vx: 0.5, color: shotColor });
                        }
                        // Level 3+
                        if (st.powerLevel >= 3 && st.powerLevel <= 5) {
                             st.bullets.push({ x: st.player.x - 15, y: st.player.y - 10, v: 6, vx: -1.5, color: shotColor });
                             st.bullets.push({ x: st.player.x + 15, y: st.player.y - 10, v: 6, vx: 1.5, color: shotColor });
                        }
                        // Level 4 (Omni-Directional)
                        if (st.powerLevel >= 4) {
                            for(let i=0; i<8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                st.bullets.push({ 
                                    x: st.player.x, y: st.player.y, 
                                    vx: Math.cos(angle) * 6, vy: Math.sin(angle) * 6, v: 0, // Manual movement
                                    color: '#f472b6' 
                                });
                            }
                        }
                        // Level 5 (Plasma - Fast Vertical)
                        if (st.powerLevel >= 5) {
                            st.bullets.push({ x: st.player.x - 20, y: st.player.y, v: 12, color: '#a855f7' });
                            st.bullets.push({ x: st.player.x + 20, y: st.player.y, v: 12, color: '#a855f7' });
                        }

                         // Level 6 (Beam/Wall)
                         if (st.powerLevel >= 6) {
                            st.bullets.push({ x: st.player.x, y: st.player.y - 20, v: 10, color: '#22d3ee', w: 6 });
                            st.bullets.push({ x: st.player.x - 10, y: st.player.y, v: 10, color: '#4ade80' });
                            st.bullets.push({ x: st.player.x + 10, y: st.player.y, v: 10, color: '#4ade80' });
                            st.bullets.push({ x: st.player.x - 25, y: st.player.y + 10, v: 10, color: '#22d3ee' });
                            st.bullets.push({ x: st.player.x + 25, y: st.player.y + 10, v: 10, color: '#22d3ee' });
                        }

                        st.lastShot = st.frameCount;
                        playSound('shoot');
                    }
                 }
                 
                 // Spawn Enemies (Only if no boss)
                 if(!st.boss && st.enemyTimer++ > 60 / st.difficulty) {
                     st.enemyTimer = 0;
                     const type = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
                     if (type) {
                         st.enemies.push({
                             x: Math.random() * (canvas.width - 30) + 15,
                             y: -20,
                             w: 30, h: 30,
                             v: type.speed * (0.8 + Math.random() * 0.4),
                             hp: type.hp * st.difficulty,
                             ...type
                         });
                     }
                 }

                 // Spawn Items (Power or Heal)
                 if (Math.random() < 0.003) {
                     const isHeal = Math.random() > 0.65; // 35% chance for heart
                     st.items.push({ x: Math.random() * (canvas.width - 20) + 10, y: -20, v: 2, type: isHeal ? 'heal' : 'power' });
                 }
                 
                 // Update Bullets
                 for(let i = st.bullets.length - 1; i >= 0; i--) {
                     const b = st.bullets[i];
                     if(b.v) b.y -= b.v;
                     if(b.vx) b.x += b.vx;
                     if(b.vy) b.y += b.vy;
                     
                     ctx.fillStyle = b.color;
                     ctx.fillRect(b.x - 2, b.y - 2, b.w || 4, 10);
                     if(b.y < 0 || b.y > canvas.height || b.x < 0 || b.x > canvas.width) st.bullets.splice(i, 1);
                 }
                 
                 // BOSS LOGIC
                 if (st.boss) {
                     const b = st.boss;
                     if (b.state === 'entering') {
                         b.y += 2;
                         if (b.y >= 100) b.state = 'fighting';
                     } else {
                         b.x += b.vx;
                         if (b.x < (b.w/2) || b.x > canvas.width - (b.w/2)) b.vx *= -1;
                         
                         // Boss Shoot
                         if (st.frameCount % 40 === 0) {
                             const angle = Math.atan2(st.player.y - b.y, st.player.x - b.x);
                             st.enemyBullets.push({ x: b.x, y: b.y + b.h/2, vx: Math.cos(angle)*4, vy: Math.sin(angle)*4 });
                             st.enemyBullets.push({ x: b.x - b.w/3, y: b.y + b.h/4, vx: 0, vy: 5 });
                             st.enemyBullets.push({ x: b.x + b.w/3, y: b.y + b.h/4, vx: 0, vy: 5 });
                         }
                     }
                     
                     // Draw Boss (Dynamic Size)
                     ctx.fillStyle = '#ef4444';
                     ctx.beginPath();
                     ctx.moveTo(b.x, b.y + b.h/2);
                     ctx.lineTo(b.x - b.w/2, b.y - b.h/4);
                     ctx.lineTo(b.x + b.w/2, b.y - b.h/4);
                     ctx.fill();
                     
                     // Boss HP Bar (on Boss)
                     ctx.fillStyle = 'red';
                     ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, 10);
                     ctx.fillStyle = 'green';
                     ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w * (b.hp / b.maxHp), 10);

                     // Collision Boss vs Player Bullets
                     for(let i = st.bullets.length - 1; i >= 0; i--) {
                         const bul = st.bullets[i];
                         // Simple AABB approximation for hit
                         if (Math.abs(bul.x - b.x) < b.w/2 && Math.abs(bul.y - b.y) < b.h/2) {
                             b.hp -= 2; // Damage
                             st.bullets.splice(i, 1);
                             if (b.hp <= 0) {
                                 st.boss = null;
                                 st.score += 5000 * st.bossLevel; // Bonus increases with level
                                 
                                 // EXPONENTIAL THRESHOLD LOGIC
                                 // 1st: 5000 (Defeated) -> Next is 10000
                                 // 2nd: 10000 (Defeated) -> Next is 30000
                                 // 3rd: 30000 (Defeated) -> Next is previous * 2.5
                                 if (st.bossLevel === 1) st.nextBossThreshold = 10000;
                                 else if (st.bossLevel === 2) st.nextBossThreshold = 30000;
                                 else st.nextBossThreshold = Math.floor(st.nextBossThreshold * 2.5);

                                 setBossActive(false);
                                 setScore(st.score);
                                 playSound('explosion');
                                 // Explosion particles
                                 for(let k=0; k<20; k++) {
                                     st.particles.push({x: b.x, y: b.y, vx: Math.random()*10-5, vy: Math.random()*10-5, life: 60, color: '#ef4444'});
                                 }
                             }
                         }
                     }
                 }

                 // Update Enemy Bullets
                 for(let i = st.enemyBullets.length - 1; i >= 0; i--) {
                     const eb = st.enemyBullets[i];
                     eb.x += eb.vx;
                     eb.y += eb.vy;
                     ctx.fillStyle = '#ef4444';
                     ctx.beginPath(); ctx.arc(eb.x, eb.y, 4, 0, Math.PI*2); ctx.fill();
                     
                     const dx = eb.x - st.player.x;
                     const dy = eb.y - st.player.y;
                     if (Math.hypot(dx, dy) < 10) { 
                         setPlayerHp(h => {
                             const nh = h - 10;
                             if(nh <= 0 && !gameOverRef.current) { 
                                 setGameOver(true); 
                                 gameOverRef.current = true;
                                 playSound('explosion'); 
                             }
                             return nh;
                         });
                         st.enemyBullets.splice(i, 1);
                         playSound('explosion');
                     }
                     if(eb.y > canvas.height) st.enemyBullets.splice(i, 1);
                 }

                 // Update Items
                 for(let i = st.items.length - 1; i >= 0; i--) {
                     const item = st.items[i];
                     item.y += item.v;
                     
                     if (item.type === 'power') {
                        ctx.fillStyle = '#fbbf24';
                        ctx.beginPath(); ctx.arc(item.x, item.y, 10, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#000'; ctx.font = '12px monospace'; ctx.fillText('⚡', item.x-4, item.y+4);
                     } else if (item.type === 'heal') {
                        ctx.fillStyle = '#ef4444';
                        ctx.beginPath(); ctx.arc(item.x, item.y, 10, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#fff'; ctx.font = '12px monospace'; ctx.fillText('❤️', item.x-6, item.y+4);
                     }

                     const dx = item.x - st.player.x;
                     const dy = item.y - st.player.y;
                     if (Math.hypot(dx, dy) < 25) {
                         if (item.type === 'power') {
                             st.powerLevel = Math.min(6, st.powerLevel + 1); // Max level 6
                             setPowerLevel(st.powerLevel);
                             st.score += 50;
                             playSound('powerup');
                         } else if (item.type === 'heal') {
                             setPlayerHp(h => Math.min(100, h + 30));
                             playSound('heal');
                         }
                         st.items.splice(i, 1);
                         setScore(st.score);
                     }
                     if (item.y > canvas.height) st.items.splice(i, 1);
                 }
                 
                 // Update Enemies
                 for(let i = st.enemies.length - 1; i >= 0; i--) {
                     const e = st.enemies[i];
                     e.y += e.v;
                     
                     if (e.shoots && st.frameCount % 100 === 0 && e.y > 0 && e.y < canvas.height - 100) {
                         const angle = Math.atan2(st.player.y - e.y, st.player.x - e.x);
                         st.enemyBullets.push({
                             x: e.x, y: e.y,
                             vx: Math.cos(angle) * 3,
                             vy: Math.sin(angle) * 3
                         });
                     }
                     
                     ctx.fillStyle = e.color;
                     ctx.beginPath();
                     if (e.shape === 'square') { ctx.rect(e.x - 15, e.y - 15, 30, 30); }
                     else if (e.shape === 'circle') { ctx.arc(e.x, e.y, 15, 0, Math.PI*2); }
                     else if (e.shape === 'dart') { ctx.moveTo(e.x, e.y+15); ctx.lineTo(e.x-10, e.y-15); ctx.lineTo(e.x, e.y-5); ctx.lineTo(e.x+10, e.y-15); }
                     else { ctx.moveTo(e.x, e.y + 15); ctx.lineTo(e.x - 15, e.y - 15); ctx.lineTo(e.x + 15, e.y - 15); }
                     ctx.fill();
                     
                     const dx = e.x - st.player.x;
                     const dy = e.y - st.player.y;
                     const dist = Math.hypot(dx, dy);
                     if(dist < 20) { 
                         setPlayerHp(h => {
                             const nh = h - 20;
                             if(nh <= 0 && !gameOverRef.current) { 
                                 setGameOver(true); 
                                 gameOverRef.current = true;
                                 playSound('explosion'); 
                             }
                             return nh;
                         });
                         e.hp -= 5;
                         if (e.hp <= 0) {
                             st.enemies.splice(i, 1);
                             playSound('explosion');
                         } else {
                             e.y -= 30; 
                         }
                         continue;
                     }
                     
                     for(let j = st.bullets.length - 1; j >= 0; j--) {
                         const b = st.bullets[j];
                         if(Math.abs(b.x - e.x) < e.w/2 + 5 && Math.abs(b.y - e.y) < e.h/2 + 5) {
                             st.bullets.splice(j, 1);
                             e.hp--;
                             if(e.hp <= 0) {
                                 for(let k=0; k<8; k++) {
                                     st.particles.push({
                                         x: e.x, y: e.y,
                                         vx: Math.random()*6-3, vy: Math.random()*6-3,
                                         life: 30, color: e.color
                                     });
                                 }
                                 st.enemies.splice(i, 1);
                                 st.score += e.score;
                                 setScore(st.score); // Sync UI
                                 playSound('explosion');
                                 break;
                             }
                         }
                     }
                     
                     if(e.y > canvas.height) st.enemies.splice(i, 1);
                 }
                 
                 // Draw Player
                 ctx.fillStyle = st.powerLevel >= 6 ? '#22d3ee' : st.powerLevel >= 5 ? '#a855f7' : st.powerLevel >= 4 ? '#f472b6' : '#3b82f6';
                 ctx.beginPath();
                 ctx.moveTo(st.player.x, st.player.y - 20);
                 ctx.lineTo(st.player.x - 15, st.player.y + 15);
                 ctx.lineTo(st.player.x, st.player.y + 10);
                 ctx.lineTo(st.player.x + 15, st.player.y + 15);
                 ctx.fill();
                 
                 for(let i=st.particles.length-1; i>=0; i--) {
                     const p = st.particles[i];
                     p.x += p.vx; p.y += p.vy; p.life--;
                     ctx.fillStyle = p.color;
                     ctx.globalAlpha = p.life / 30;
                     ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
                     ctx.globalAlpha = 1;
                     if(p.life <= 0) st.particles.splice(i, 1);
                 }
                 
                 animationRef.current = requestAnimationFrame(loop);
             };
             
             loop();
             return () => {
                 window.removeEventListener('keydown', handleDown);
                 window.removeEventListener('keyup', handleUp);
                 window.removeEventListener('resize', resize);
                 canvas.removeEventListener('touchstart', handleTouchStart);
                 canvas.removeEventListener('touchmove', handleTouchMove);
                 canvas.removeEventListener('touchend', handleTouchEnd);
                 cancelAnimationFrame(animationRef.current);
             };
         }, [playSound, resetTrigger, restart]);

         return (
             <div className="flex flex-col items-center justify-center w-full h-full relative" onClick={stopAdEvent}>
                {/* HUD */}
                <div className="absolute top-4 left-4 right-4 z-10 flex justify-between items-start pointer-events-none">
                     <div className="text-white font-mono text-xl drop-shadow-md bg-black/40 px-2 rounded">
                        SCORE: <span className="text-yellow-400">{score}</span>
                     </div>
                     <div className="flex flex-col items-end gap-1">
                         <div className="w-32 h-4 bg-gray-800 rounded-full border border-white/20 overflow-hidden">
                             <div className={`h-full transition-all duration-300 ${playerHp > 50 ? 'bg-green-500' : playerHp > 20 ? 'bg-yellow-500' : 'bg-red-500'}`} style={{ width: `${Math.max(0, playerHp)}%` }}></div>
                         </div>
                         <div className="text-xs text-white/70 font-mono">VIDA: {playerHp}%</div>
                         {powerLevel > 1 && <div className="text-xs text-blue-400 font-bold uppercase animate-pulse">Arma Lvl {powerLevel} {powerLevel >= 6 && '(MAX)'}</div>}
                         {bossActive && <div className="text-sm text-red-500 font-black animate-pulse">⚠️ BOSS FIGHT ⚠️</div>}
                     </div>
                </div>

                <canvas ref={canvasRef} className="shooter-canvas rounded-lg max-w-full" style={{ touchAction: 'none' }} />
                {gameOver && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/70 backdrop-blur-sm z-20">
                        <div className="bg-[#1e293b] p-8 rounded-2xl border border-white/20 text-center shadow-2xl animate-in zoom-in">
                            <h2 className="text-red-500 font-black text-4xl mb-2">GAME OVER</h2>
                            <p className="text-gray-300 mb-6 text-lg">Score Final: <span className="text-white font-bold">{score}</span></p>
                            <button onClick={restart} className="bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-transform active:scale-95">Jogar Novamente</button>
                        </div>
                    </div>
                )}
             </div>
         );
      };

      // --- TETRIS GAME COMPONENT ---
      const TetrisGame = ({ playSound, onGameOver }) => {
          const [grid, setGrid] = useState(Array(20).fill(Array(10).fill([0, 'clear'])));
          const [player, setPlayer] = useState({ pos: { x: 0, y: 0 }, tetromino: TETROMINOS[0].shape, collided: false });
          const [score, setScore] = useState(0);
          const [rows, setRows] = useState(0);
          const [level, setLevel] = useState(0);
          const [gameOver, setGameOver] = useState(false);
          const [dropTime, setDropTime] = useState(null);
          
          const createStage = () => Array.from(Array(20), () => new Array(10).fill([0, 'clear']));
          
          useEffect(() => {
              const resetGame = () => {
                  setGrid(createStage());
                  setScore(0); setRows(0); setLevel(0); setGameOver(false);
                  setDropTime(1000);
                  updatePlayerPos({ x: 4, y: 0 });
                  setPlayer(prev => ({ ...prev, tetromino: randomTetromino().shape, collided: false }));
              };
              resetGame();
          }, []);

          const movePlayer = (dir) => {
              if (!checkCollision(player, grid, { x: dir, y: 0 })) {
                  updatePlayerPos({ x: dir, y: 0, collided: false });
              }
          };

          const startGame = () => {
             setGrid(createStage());
             setScore(0); setRows(0); setLevel(0); setGameOver(false); setDropTime(1000);
             setPlayer({ pos: { x: 4, y: 0 }, tetromino: randomTetromino().shape, collided: false });
             playSound('deal');
          };

          const drop = () => {
              if (rows > (level + 1) * 10) {
                  setLevel(prev => prev + 1);
                  setDropTime(1000 / (level + 1) + 200);
              }
              if (!checkCollision(player, grid, { x: 0, y: 1 })) {
                  updatePlayerPos({ x: 0, y: 1, collided: false });
              } else {
                  if (player.pos.y < 1) {
                      setGameOver(true);
                      setDropTime(null);
                      onGameOver(score);
                  }
                  updatePlayerPos({ x: 0, y: 0, collided: true });
              }
          };

          const keyUp = ({ keyCode }) => {
              if (!gameOver) {
                  if (keyCode === 40) { // Down
                      setDropTime(1000 / (level + 1) + 200);
                  }
              }
          };

          const dropPlayer = () => {
              setDropTime(null);
              drop();
          };

          const move = ({ keyCode }) => {
              if (!gameOver) {
                  if (keyCode === 37) movePlayer(-1); // Left
                  else if (keyCode === 39) movePlayer(1); // Right
                  else if (keyCode === 40) dropPlayer(); // Down
                  else if (keyCode === 38) playerRotate(grid, 1); // Up (Rotate)
              }
          };

          const checkCollision = (player, stage, { x: moveX, y: moveY }) => {
            for (let y = 0; y < player.tetromino.length; y += 1) {
                for (let x = 0; x < player.tetromino[y].length; x += 1) {
                    if (player.tetromino[y][x] !== 0) {
                        if (
                        !stage[y + player.pos.y + moveY] || 
                        !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||
                        stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== 'clear'
                        ) { return true; }
                    }
                }
            }
            return false;
          };

          const updatePlayerPos = ({ x, y, collided }) => {
              setPlayer(prev => ({
                  ...prev,
                  pos: { x: (prev.pos.x += x), y: (prev.pos.y += y) },
                  collided,
              }));
          };
          
          const playerRotate = (stage, dir) => {
              const clonedPlayer = JSON.parse(JSON.stringify(player));
              clonedPlayer.tetromino = rotate(clonedPlayer.tetromino, dir);
              const pos = clonedPlayer.pos.x;
              let offset = 1;
              while(checkCollision(clonedPlayer, stage, {x:0, y:0})) {
                  clonedPlayer.pos.x += offset;
                  offset = -(offset + (offset > 0 ? 1 : -1));
                  if(offset > clonedPlayer.tetromino[0].length) {
                      rotate(clonedPlayer.tetromino, -dir);
                      clonedPlayer.pos.x = pos;
                      return;
                  }
              }
              setPlayer(clonedPlayer);
              playSound('rotate');
          };

          const rotate = (matrix, dir) => {
              const rotated = matrix.map((_, index) => matrix.map(col => col[index]));
              return dir > 0 ? rotated.map(row => row.reverse()) : rotated.reverse();
          };

          useInterval(() => { drop(); }, dropTime);

          function useInterval(callback, delay) {
            const savedCallback = useRef();
            useEffect(() => { savedCallback.current = callback; }, [callback]);
            useEffect(() => {
                if (delay !== null) {
                    const id = setInterval(() => savedCallback.current(), delay);
                    return () => clearInterval(id);
                }
            }, [delay]);
          }

          useEffect(() => {
              const sweepRows = (newStage) => {
                  return newStage.reduce((ack, row) => {
                      if (row.findIndex(cell => cell[0] === 0) === -1) {
                          setRows(prev => prev + 1);
                          setScore(prev => prev + 100);
                          playSound('line');
                          ack.unshift(new Array(newStage[0].length).fill([0, 'clear']));
                          return ack;
                      }
                      ack.push(row);
                      return ack;
                  }, []);
              };

              const updateStage = prevStage => {
                  const newStage = prevStage.map(row => row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell)));
                  player.tetromino.forEach((row, y) => {
                      row.forEach((value, x) => {
                          if (value !== 0) {
                              if(newStage[y + player.pos.y] && newStage[y + player.pos.y][x + player.pos.x]) {
                                newStage[y + player.pos.y][x + player.pos.x] = [value, `${player.collided ? 'merged' : 'clear'}`];
                              }
                          }
                      });
                  });
                  if (player.collided) {
                      setPlayer({ pos: { x: 4, y: 0 }, tetromino: randomTetromino().shape, collided: false });
                      playSound('drop');
                      return sweepRows(newStage);
                  }
                  return newStage;
              };

              setGrid(prev => updateStage(prev));
          }, [player, player.collided, playSound]);
          
          useEffect(() => {
            const handler = (e) => { if(!gameOver) move(e); };
            const upHandler = (e) => { if(!gameOver) keyUp(e); };
            window.addEventListener('keydown', handler);
            window.addEventListener('keyup', upHandler);
            return () => { window.removeEventListener('keydown', handler); window.removeEventListener('keyup', upHandler); };
          }, [player, gameOver]);

          return (
             <div className="flex flex-col items-center w-full max-w-[320px] mx-auto select-none" onClick={stopAdEvent}>
                <div className="flex w-full justify-between bg-black/40 p-2 rounded-t-lg border-x border-t border-white/10 text-white font-mono text-xs">
                    <div>SCORE: <span className="text-yellow-400 font-bold">{score}</span></div>
                    <div>LEVEL: <span className="text-emerald-400 font-bold">{level}</span></div>
                </div>
                <div className="relative border-2 border-white/20 bg-black/80 shadow-[0_0_20px_rgba(0,0,0,0.5)]">
                    <div className="tetris-grid" style={{ width: '250px', height: '500px' }}>
                        {grid.map((row, y) => row.map((cell, x) => (
                            <div key={`${y}-${x}`} className="tetris-cell" style={{ 
                                backgroundColor: cell[0] === 0 ? 'transparent' : `rgba(${TETROMINOS[cell[0]]?.color || '255,255,255'}, 0.8)`,
                                border: cell[0] === 0 ? 'none' : `1px solid rgba(255,255,255,0.3)`,
                                boxShadow: cell[0] === 0 ? 'none' : `inset 0 0 5px rgba(0,0,0,0.2)`
                            }} />
                        )))}
                    </div>
                    {gameOver && (
                        <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center animate-in fade-in">
                            <div className="text-red-500 font-black text-3xl mb-4">GAME OVER</div>
                            <button onClick={startGame} className="bg-white text-black font-bold py-2 px-6 rounded-full hover:bg-yellow-400 transition-colors">Tentar Novamente</button>
                        </div>
                    )}
                </div>
                <div className="mt-6 grid grid-cols-3 gap-4 w-full px-4">
                    <div className="col-span-1 flex justify-center"><button className="w-14 h-14 bg-white/10 rounded-full flex items-center justify-center active:bg-white/30 active:scale-95" onPointerDown={(e)=>{ stopAdEvent(e); move({keyCode: 37})}}><ArrowLeft className="text-white" /></button></div>
                    <div className="col-span-1 flex flex-col items-center gap-2">
                        <button className="w-14 h-14 bg-purple-600/50 rounded-full flex items-center justify-center active:bg-purple-500 active:scale-95 border border-white/20" onPointerDown={(e)=>{ stopAdEvent(e); move({keyCode: 38})}}><RotateCw className="text-white" /></button>
                        <button className="w-14 h-14 bg-white/10 rounded-full flex items-center justify-center active:bg-white/30 active:scale-95" onPointerDown={(e)=>{ stopAdEvent(e); move({keyCode: 40})}}><ArrowDown className="text-white" /></button>
                    </div>
                    <div className="col-span-1 flex justify-center"><button className="w-14 h-14 bg-white/10 rounded-full flex items-center justify-center active:bg-white/30 active:scale-95" onPointerDown={(e)=>{ stopAdEvent(e); move({keyCode: 39})}}><ArrowRight className="text-white" /></button></div>
                </div>
             </div>
          );
      };

      // --- MAIN APP ---
      function App() {
        const [gameMode, setGameMode] = useState(GameMode.FreeCell);
        const [gameState, setGameState] = useState({
            mode: GameMode.FreeCell,
            freeCells: [null,null,null,null], stock: [], waste: [], foundation: { [Suit.Hearts]: [], [Suit.Diamonds]: [], [Suit.Clubs]: [], [Suit.Spades]: [] },
            tableau: [], score: 0, moves: 0, time: 0, gameWon: false
        });
        const [history, setHistory] = useState([]);
        const [selected, setSelected] = useState(null);
        const [hint, setHint] = useState(null);
        const [isNightMode, setIsNightMode] = useState(false);
        const [showInstallModal, setShowInstallModal] = useState(false);
        const [deferredPrompt, setDeferredPrompt] = useState(null);
        const [isStandalone, setIsStandalone] = useState(false);
        const [isSoundEnabled, setIsSoundEnabled] = useState(true);
        const [showWinningBounce, setShowWinningBounce] = useState(false);
        const [onlineCount, setOnlineCount] = useState(150);
        const [visitCount, setVisitCount] = useState(843210);
        
        // Reset trigger specifically for non-react-state games (Shooter)
        const [gameResetTrigger, setGameResetTrigger] = useState(0);

        const playSound = useSound(isSoundEnabled);
        const activeDragRef = useRef(null); const dragRaf = useRef(null); const gameStateRef = useRef(gameState);
        useEffect(() => { gameStateRef.current = gameState; }, [gameState]);

        const startNewGame = useCallback(() => {
            if (gameMode === GameMode.Tetris || gameMode === GameMode.Shooter) return;
            const deck = shuffleDeck(createDeck(gameMode === GameMode.FreeCell));
            let newTableau = [], stock = [], waste = [];
            if (gameMode === GameMode.FreeCell) {
                newTableau = Array(8).fill().map(() => []);
                let idx = 0;
                for(let col=0; col<8; col++) {
                    const count = col < 4 ? 7 : 6;
                    for(let i=0; i<count; i++) newTableau[col].push(deck[idx++]);
                }
            } else {
                newTableau = Array(7).fill().map(() => []);
                let idx = 0;
                for(let col=0; col<7; col++) {
                    for(let i=0; i<=col; i++) {
                        const card = deck[idx++]; card.isFaceUp = (i === col); newTableau[col].push(card);
                    }
                }
                stock = deck.slice(idx).map(c => ({...c, isFaceUp: false}));
            }
            setGameState({
                mode: gameMode, freeCells: [null,null,null,null], stock, waste, foundation: { [Suit.Hearts]: [], [Suit.Diamonds]: [], [Suit.Clubs]: [], [Suit.Spades]: [] },
                tableau: newTableau, score: 0, moves: 0, time: 0, gameWon: false
            });
            setHistory([]); setSelected(null); setHint(null); setShowWinningBounce(false); playSound('deal');
        }, [gameMode, playSound]);

        useEffect(() => { startNewGame(); }, [startNewGame]);

        useEffect(() => {
            if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js');
            const installed = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
            setIsStandalone(installed);
            if (installed) return;
            
            // GLOBAL CAPTURE HANDLER
            if (window.deferredInstallPrompt) { 
                setDeferredPrompt(window.deferredInstallPrompt); 
                setShowInstallModal(true); 
            }
            const handleReady = () => { 
                setDeferredPrompt(window.deferredInstallPrompt); 
                setShowInstallModal(true); 
            };
            window.addEventListener('install-prompt-ready', handleReady);
            
            // iOS Fallback (always show after delay)
            if (/iPhone|iPad|iPod/.test(navigator.userAgent)) setTimeout(() => setShowInstallModal(true), 2000);
            
            return () => window.removeEventListener('install-prompt-ready', handleReady);
        }, []);

        const handleInstallClick = async () => {
            if (deferredPrompt) { deferredPrompt.prompt(); const { outcome } = await deferredPrompt.userChoice; if (outcome === 'accepted') { setDeferredPrompt(null); setShowInstallModal(false); } }
            else setShowInstallModal(true);
        };
        const saveHistory = () => { setHistory(prev => [...prev.slice(-49), JSON.parse(JSON.stringify(gameStateRef.current))]); };
        const handleUndo = () => { if(!history.length) return; const previous = history[history.length-1]; setGameState(previous); setHistory(h => h.slice(0, -1)); gameStateRef.current = previous; playSound('pickup'); };
        const handleCardMove = (source, targetType, targetIndex, suit) => {
            saveHistory(); 
            setGameState(prev => {
                const newState = JSON.parse(JSON.stringify(prev)); 
                let cards = [];
                if (source.pileType === 'freeCell') { cards = [newState.freeCells[source.pileIndex]]; newState.freeCells[source.pileIndex] = null; }
                else if (source.pileType === 'waste') { cards = [newState.waste.pop()]; }
                else if (source.pileType === 'tableau') {
                    const col = newState.tableau[source.pileIndex]; cards = col.slice(source.cardIndex);
                    if (prev.mode === GameMode.FreeCell && cards.length > 1) {
                         const emptyFC = newState.freeCells.filter(c => c === null).length;
                         let emptyTab = newState.tableau.filter(c => c.length === 0).length;
                         if (targetType === 'tableau' && newState.tableau[targetIndex].length === 0) emptyTab = Math.max(0, emptyTab - 1);
                         if (cards.length > getMaxMovableStack(emptyFC, emptyTab)) return prev; 
                    }
                    newState.tableau[source.pileIndex] = col.slice(0, source.cardIndex);
                    if (prev.mode === GameMode.Klondike && newState.tableau[source.pileIndex].length > 0) {
                        const top = newState.tableau[source.pileIndex][newState.tableau[source.pileIndex].length - 1];
                        if (!top.isFaceUp) { top.isFaceUp = true; newState.score += 5; }
                    }
                }
                if (targetType === 'freeCell') newState.freeCells[targetIndex] = cards[0];
                else if (targetType === 'tableau') newState.tableau[targetIndex].push(...cards);
                else if (targetType === 'foundation') newState.foundation[suit].push(cards[0]);
                newState.moves++; newState.score += 10; return newState;
            });
            setSelected(null); playSound('drop');
        };

        const handleCardClick = (card, pileType, pileIndex, cardIndex) => {
            if (!card && pileType === 'tableau') { if(selected && isMoveValid(selected.card, null, 'tableau', gameState.mode)) handleCardMove(selected, 'tableau', pileIndex); return; }
            if (!card || (!card.isFaceUp && pileType === 'tableau')) return;
            if (pileType !== 'foundation') {
                const fPile = gameState.foundation[card.suit];
                const fTarget = fPile.length ? fPile[fPile.length-1] : null;
                let isTop = (pileType==='tableau' && cardIndex === gameState.tableau[pileIndex].length-1) || pileType==='freeCell' || pileType==='waste';
                if (isTop && isMoveValid(card, fTarget, 'foundation', gameState.mode, card.suit)) { handleCardMove({card, pileType, pileIndex, cardIndex}, 'foundation', null, card.suit); return; }
            }
            if (selected && selected.card.id === card.id) { setSelected(null); return; }
            if(selected) {
                if (pileType === 'tableau' && isMoveValid(selected.card, card, 'tableau', gameState.mode)) { handleCardMove(selected, 'tableau', pileIndex); return; }
                setSelected(null);
            } else {
                if (pileType === 'tableau') { if (isStackValid(gameState.tableau[pileIndex].slice(cardIndex))) setSelected({card, pileType, pileIndex, cardIndex}); }
                else if (pileType === 'freeCell' || pileType === 'waste') setSelected({card, pileType, pileIndex, cardIndex: 0});
            }
        };

        const handleDragStart = (e, card, pileType, pileIndex, cardIndex, domEl) => {
             stopAdEvent(e); if(!card.isFaceUp) return;
             if(pileType === 'tableau') {
                 const stack = gameState.tableau[pileIndex].slice(cardIndex);
                 if(!isStackValid(stack)) return;
                 if(gameState.mode === GameMode.FreeCell && stack.length > 1) {
                     const emptyFC = gameState.freeCells.filter(c => c === null).length;
                     const emptyTab = gameState.tableau.filter(c => c.length === 0).length;
                     if(stack.length > getMaxMovableStack(emptyFC, emptyTab)) return;
                 }
             }
             playSound('pickup');
             const rect = domEl.getBoundingClientRect(); const cardWidth = rect.width;
             let elements = [domEl]; let stackOffset = 0;
             if(pileType === 'tableau') {
                 const siblings = Array.from(domEl.parentElement.children); const idx = siblings.indexOf(domEl);
                 elements = siblings.slice(idx); stackOffset = gameState.mode === GameMode.Klondike ? 15 : 28;
             }
             elements.forEach(el => { el.style.transition = 'none'; el.style.zIndex = '9999'; });
             activeDragRef.current = { card, pileType, pileIndex, cardIndex, startX: e.clientX, startY: e.clientY, offsetX: e.clientX - rect.left, offsetY: e.clientY - rect.top, elements, stackOffset, width: cardWidth };
             window.addEventListener('pointermove', handlePointerMove); window.addEventListener('pointerup', handlePointerUp);
        };

        const handlePointerMove = (e) => {
            if(!activeDragRef.current) return;
            if(dragRaf.current) cancelAnimationFrame(dragRaf.current);
            dragRaf.current = requestAnimationFrame(() => {
                if(!activeDragRef.current) return;
                const { elements, offsetX, offsetY, stackOffset, width } = activeDragRef.current;
                elements.forEach((el, i) => {
                    el.style.position = 'fixed'; el.style.width = width + 'px'; el.style.left = '0px'; el.style.top = '0px'; el.style.zIndex = (9999 + i).toString(); el.style.pointerEvents = 'none';
                    el.style.transform = `translate3d(${e.clientX - offsetX}px, ${e.clientY - offsetY + (i * stackOffset)}px, 0) scale(1.05)`;
                    el.style.boxShadow = '0 15px 30px rgba(0,0,0,0.5)';
                });
            });
        };

        const handlePointerUp = (e) => {
            window.removeEventListener('pointermove', handlePointerMove); window.removeEventListener('pointerup', handlePointerUp);
            if(!activeDragRef.current) return;
            const { card, pileType, pileIndex, cardIndex, elements, startX, startY } = activeDragRef.current;
            elements.forEach(el => { el.style = ''; }); activeDragRef.current = null;
            if (Math.hypot(e.clientX - startX, e.clientY - startY) < 10) { handleCardClick(card, pileType, pileIndex, cardIndex); }
            else {
                const hits = document.elementsFromPoint(e.clientX, e.clientY);
                const dropZone = hits.find(el => el.dataset.dropZone === 'true');
                if (dropZone) {
                    const type = dropZone.dataset.dropType; const idx = parseInt(dropZone.dataset.dropIndex); const suit = dropZone.dataset.dropSuit;
                    let targetCard = null;
                    if(type === 'tableau') { const col = gameState.tableau[idx]; if(col.length) targetCard = col[col.length-1]; }
                    else if (type === 'foundation') { const pile = gameState.foundation[suit]; if(pile.length) targetCard = pile[pile.length-1]; }
                    else if (type === 'freeCell') targetCard = gameState.freeCells[idx];
                    if (isMoveValid(card, targetCard, type, gameState.mode, suit)) handleCardMove({card, pileType, pileIndex, cardIndex}, type, idx, suit);
                }
            }
        };

        const handleStock = () => {
             if(gameState.mode !== GameMode.Klondike) return; saveHistory();
             setGameState(prev => {
                 const ns = JSON.parse(JSON.stringify(prev));
                 if(ns.stock.length === 0) { ns.stock = ns.waste.reverse().map(c => ({...c, isFaceUp: false})); ns.waste = []; }
                 else { const c = ns.stock.pop(); c.isFaceUp = true; ns.waste.push(c); }
                 ns.moves++; return ns;
             }); setSelected(null); playSound('pickup');
        };
        const handleHint = () => {
              if (gameMode === GameMode.Tetris || gameMode === GameMode.Shooter) return;
              for (let i = 0; i < gameState.tableau.length; i++) {
                  const col = gameState.tableau[i]; if(col.length){ const card = col[col.length-1]; const fTarget = gameState.foundation[card.suit].length ? gameState.foundation[card.suit][gameState.foundation[card.suit].length-1] : null; if(isMoveValid(card, fTarget, 'foundation', gameState.mode, card.suit)){ setHint({sourceId: card.id, targetId: `foundation-${card.suit}`}); setTimeout(()=>setHint(null), 2000); return; } }
              }
              for(let i=0; i<gameState.tableau.length; i++) {
                  const col = gameState.tableau[i]; if(col.length) { const card = col[col.length-1]; for(let j=0; j<gameState.tableau.length; j++) { if(i===j) continue; const tCol = gameState.tableau[j]; const tCard = tCol.length ? tCol[tCol.length-1] : null; if(isMoveValid(card, tCard, 'tableau', gameState.mode)) { setHint({sourceId: card.id, targetId: `tableau-${j}`}); setTimeout(()=>setHint(null), 2000); return; } } }
              }
        };
        const handleAuto = () => {
             if (gameMode === GameMode.Tetris || gameMode === GameMode.Shooter) return;
             let moved = false; let ns = JSON.parse(JSON.stringify(gameState));
             const tryMove = (card) => {
                 const fTarget = ns.foundation[card.suit].length ? ns.foundation[card.suit][ns.foundation[card.suit].length-1] : null;
                 if(isMoveValid(card, fTarget, 'foundation', ns.mode, card.suit)) { ns.foundation[card.suit].push(card); return true; } return false;
             };
             for(let i=0; i<ns.tableau.length; i++) {
                 const col = ns.tableau[i]; if(col.length) { const card = col[col.length-1]; if(tryMove(card)) { col.pop(); if(ns.mode === GameMode.Klondike && col.length && !col[col.length-1].isFaceUp) col[col.length-1].isFaceUp=true; moved=true; break; } }
             }
             if(!moved) {
                 if(ns.mode === GameMode.FreeCell) { for(let i=0; i<ns.freeCells.length; i++) { const card = ns.freeCells[i]; if(card && tryMove(card)) { ns.freeCells[i] = null; moved=true; break; } } }
                 else { if(ns.waste.length) { const card = ns.waste[ns.waste.length-1]; if(tryMove(card)) { ns.waste.pop(); moved=true; } } }
             }
             if(moved) { saveHistory(); ns.moves++; ns.score+=10; setGameState(ns); playSound('drop'); }
        };

        useEffect(() => {
            setOnlineCount(Math.floor(Math.random() * (350 - 150) + 150)); setVisitCount(1250000 + Math.floor(Math.random() * 50000));
            const onlineInterval = setInterval(() => { setOnlineCount(prev => Math.max(100, prev + Math.floor(Math.random() * 5) - 2)); }, 3000);
            const visitInterval = setInterval(() => { setVisitCount(prev => prev + 1); }, 8000);
            return () => { clearInterval(onlineInterval); clearInterval(visitInterval); }
        }, []);
        useEffect(() => {
            if (gameMode === GameMode.Tetris || gameMode === GameMode.Shooter) return;
            const total = Object.values(gameState.foundation).reduce((acc, pile) => acc + pile.length, 0);
            if (total === 52 && !gameState.gameWon) { setGameState(p => ({...p, gameWon: true})); playSound('win'); setShowWinningBounce(true); setTimeout(() => setShowWinningBounce(false), 6000); }
        }, [gameState.foundation, playSound, gameMode]);

        return (
            <div className={`min-h-[100dvh] flex flex-col ${isNightMode ? 'bg-[#0f172a]' : 'bg-[#0f3526]'} transition-colors duration-500 overflow-hidden`}>
                <header className="px-2 py-2 bg-black/30 backdrop-blur-md sticky top-0 z-50 border-b border-white/5 pt-safe flex flex-wrap items-center justify-between gap-2 max-h-[60px]" onClick={stopAdEvent}>
                    <div className="flex items-center gap-2 shrink-0">
                        <div className="bg-yellow-500/20 p-1.5 rounded-lg"><Crown className="text-yellow-500 w-4 h-4 sm:w-5 sm:h-5" /></div>
                        <h1 className="text-white font-serif font-bold text-base sm:text-lg hidden xs:block">JosiPuff</h1>
                    </div>
                    <div className="flex items-center gap-2 flex-1 justify-end">
                        <div className="hidden md:flex bg-black/40 rounded-lg p-1 mr-4 border border-white/5">
                            <AdsterraBanner width={320} height={50} dataKey="40ea244e14933019fbfcc00a3875f885" />
                        </div>
                        <div className="flex bg-black/40 rounded-lg p-1 shrink-0 overflow-x-auto no-scrollbar">
                            <button onClick={(e)=>{ stopAdEvent(e); setGameMode(GameMode.FreeCell)}} className={`px-2 sm:px-3 py-1 text-[10px] sm:text-xs rounded whitespace-nowrap ${gameMode===GameMode.FreeCell?'bg-emerald-600 text-white':'text-white/50'}`}>FreeCell</button>
                            <button onClick={(e)=>{ stopAdEvent(e); setGameMode(GameMode.Klondike)}} className={`px-2 sm:px-3 py-1 text-[10px] sm:text-xs rounded whitespace-nowrap ${gameMode===GameMode.Klondike?'bg-emerald-600 text-white':'text-white/50'}`}>Clássico</button>
                            <button onClick={(e)=>{ stopAdEvent(e); setGameMode(GameMode.Tetris)}} className={`px-2 sm:px-3 py-1 text-[10px] sm:text-xs rounded whitespace-nowrap ${gameMode===GameMode.Tetris?'bg-emerald-600 text-white':'text-white/50'}`}>Blocos</button>
                            <button onClick={(e)=>{ stopAdEvent(e); setGameMode(GameMode.Shooter)}} className={`px-2 sm:px-3 py-1 text-[10px] sm:text-xs rounded whitespace-nowrap flex items-center gap-1 ${gameMode===GameMode.Shooter?'bg-emerald-600 text-white':'text-white/50'}`}><Rocket size={10} /> Nave</button>
                        </div>
                        <div className="flex items-center gap-1.5 shrink-0 border-l border-white/10 pl-1.5">
                            {!isStandalone && (
                                <button onClick={handleInstallClick} className="group relative px-3 py-1.5 rounded-full overflow-hidden transition-all duration-300 hover:scale-105 active:scale-95 animate-neon-pulse border border-purple-500/50">
                                    <div className="absolute inset-0 bg-gradient-to-r from-purple-900 via-green-600 to-purple-900 opacity-90 group-hover:opacity-100 animate-gradient-xy"></div>
                                    <div className="relative flex items-center gap-1.5 z-20"><div className="bg-white text-purple-700 rounded-full p-0.5"><Smartphone className="w-3 h-3 stroke-[3]" /></div><span className="text-[10px] font-black uppercase tracking-wider text-white drop-shadow-md hidden sm:inline">Instalar</span></div>
                                </button>
                            )}
                            <button onClick={(e)=>{ stopAdEvent(e); setIsNightMode(!isNightMode)}} className="text-yellow-300 p-1.5 shrink-0 bg-white/5 rounded-full hover:bg-white/10 transition-colors">{isNightMode?<Sun size={16}/>:<Moon size={16}/>}</button>
                        </div>
                    </div>
                </header>
                
                {gameMode !== GameMode.Tetris && gameMode !== GameMode.Shooter && (
                <div className="flex justify-center py-1 bg-black/20 gap-6 text-xs font-mono text-white/80 border-b border-white/5 shrink-0" onClick={stopAdEvent}>
                    <span>SCORE: {gameState.score}</span><span>MOVES: {gameState.moves}</span>
                </div>
                )}

                <main className="flex-grow flex flex-col justify-between items-center p-2 sm:p-4 z-10 relative overflow-y-auto pb-safe" onClick={stopAdEvent}>
                    <div className="w-full max-w-[1600px] grid grid-cols-1 lg:grid-cols-[160px_1fr_160px] gap-6">
                        <div className="hidden lg:flex flex-col gap-4">
                            <AdsterraBanner width={160} height={600} dataKey="3c0cd82368fb680b5d61812c81df31f2" />
                        </div>

                        {/* GAME BOARD AREA */}
                        <div className="flex flex-col gap-1 sm:gap-3 items-center w-full">
                            {gameMode === GameMode.Tetris ? (
                                <TetrisGame playSound={playSound} onGameOver={(score) => { /* Handle Game Over */ }} />
                            ) : gameMode === GameMode.Shooter ? (
                                <SpaceShooterGame playSound={playSound} onGameOver={(score) => { /* Handle Game Over */ }} resetTrigger={gameResetTrigger} />
                            ) : (
                                <>
                                <div className="grid grid-cols-8 gap-1 sm:gap-3 mb-4 sm:mb-8 w-full">
                                    {gameMode === GameMode.FreeCell ? (
                                        gameState.freeCells.map((c, i) => (
                                            <div key={i} data-drop-zone="true" data-drop-type="freeCell" data-drop-index={i} onClick={()=>handleCardClick(c, 'freeCell', i)} className={`aspect-[2.5/3.5] rounded bg-black/20 border-2 ${selected?.pileType==='freeCell' && selected.pileIndex===i ? 'border-yellow-400':'border-white/10'}`}>
                                                {c && <SolitaireCard card={c} draggable onPointerDown={(e,el)=>handleDragStart(e,c,'freeCell',i,0,el)} isSelected={selected?.card.id===c.id} />}
                                            </div>
                                        ))
                                    ) : (
                                        <>
                                            <div className="col-span-1 aspect-[2.5/3.5] bg-black/20 rounded border-2 border-white/10 flex items-center justify-center cursor-pointer hover:bg-white/5 active:scale-95 transition" onClick={(e) => { stopAdEvent(e); handleStock(); }}>
                                                {gameState.stock.length > 0 ? (
                                                    <div className="relative w-full h-full"><div className="absolute inset-0.5 bg-[#5c0b0b] rounded-[4%] border border-white/20"></div><RefreshCw className="absolute inset-0 m-auto text-white/20" /></div>
                                                ) : <RefreshCw className="text-white/20" />}
                                            </div>
                                            <div className="col-span-1 aspect-[2.5/3.5]">
                                                {gameState.waste.length>0 && <SolitaireCard card={gameState.waste[gameState.waste.length-1]} draggable onPointerDown={(e,el)=>handleDragStart(e,gameState.waste[gameState.waste.length-1],'waste',0,0,el)} isSelected={selected?.card.id===gameState.waste[gameState.waste.length-1].id} />}
                                            </div>
                                            <div className="col-span-2"></div>
                                        </>
                                    )}
                                    {[Suit.Hearts, Suit.Diamonds, Suit.Clubs, Suit.Spades].map((s, i) => {
                                        const fPile = gameState.foundation[s]; const top = fPile.length ? fPile[fPile.length-1] : null;
                                        return (
                                            <div key={s} data-drop-zone="true" data-drop-type="foundation" data-drop-suit={s} className={`col-span-1 aspect-[2.5/3.5] rounded bg-black/20 border-2 border-white/10 flex items-center justify-center ${hint?.targetId===`foundation-${s}`?'ring-2 ring-emerald-400':''}`}>
                                                {top ? <SolitaireCard card={top} /> : <SuitIcon suit={s} className="text-white/10 w-8 h-8" />}
                                            </div>
                                        );
                                    })}
                                </div>
                                <div className="grid grid-cols-8 gap-1 sm:gap-3 h-full w-full">
                                    {gameState.tableau.map((col, i) => (
                                        <div key={i} data-drop-zone="true" data-drop-type="tableau" data-drop-index={i} onClick={()=>col.length===0 && handleCardClick(null, 'tableau', i)} className={`relative h-[60vh] ${hint?.targetId===`tableau-${i}`?'ring-2 ring-yellow-400/50 rounded':''}`}>
                                            {col.map((card, idx) => (
                                                <div key={card.id} className="absolute w-full" style={{top: `${idx * (gameMode===GameMode.Klondike && !card.isFaceUp ? 10 : 25)}px`, zIndex: idx}}>
                                                    <SolitaireCard card={card} draggable={card.isFaceUp} onPointerDown={(e,el)=>handleDragStart(e,card,'tableau',i,idx,el)} isSelected={selected?.card.id===card.id} className={hint?.sourceId===card.id?'ring-2 ring-yellow-400':''} />
                                                </div>
                                            ))}
                                        </div>
                                    ))}
                                </div>
                                </>
                            )}
                        </div>

                        <div className="hidden lg:flex flex-col gap-4">
                            <AdsterraBanner width={160} height={600} dataKey="3c0cd82368fb680b5d61812c81df31f2" />
                        </div>
                    </div>
                    
                    <div className="w-full max-w-[1000px] mt-8 mb-8 min-h-[60px] bg-black/10 rounded-lg flex items-center justify-center text-white/10 uppercase font-bold text-xs tracking-widest border-t border-white/5 overflow-hidden p-2">
                        <AdsterraBanner width={320} height={50} dataKey="40ea244e14933019fbfcc00a3875f885" />
                    </div>
                </main>

                <DraggableMenu>
                    <button onClick={() => { if(gameMode === GameMode.Shooter) { setGameResetTrigger(prev => prev+1); } else if (gameMode === GameMode.Tetris) { setGameMode(gameMode); } else { startNewGame(); } }} className="flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 text-blue-400 transition">
                        {gameMode === GameMode.Shooter || gameMode === GameMode.Tetris ? <RotateCcw size={18} /> : <PlusCircle size={18} />}
                        <span className="text-[8px] uppercase font-bold mt-0.5">{gameMode === GameMode.Shooter || gameMode === GameMode.Tetris ? 'Reset' : 'Novo'}</span>
                    </button>
                    {gameMode !== GameMode.Tetris && gameMode !== GameMode.Shooter && (
                        <>
                        <div className="w-px h-6 bg-white/10"></div>
                        <button onClick={(e)=>{ stopAdEvent(e); handleUndo()}} disabled={!history.length} className={`flex flex-col items-center p-1.5 rounded-lg w-11 ${!history.length?'opacity-30 cursor-not-allowed':'hover:bg-white/10'} text-white transition`}>
                            <Undo2 size={18} /><span className="text-[8px] uppercase font-bold mt-0.5">Undo</span>
                        </button>
                        <div className="w-px h-6 bg-white/10"></div>
                        <button onClick={(e)=>{ stopAdEvent(e); handleHint()}} className="flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 text-yellow-300 transition">
                            <Lightbulb size={18} /><span className="text-[8px] uppercase font-bold mt-0.5">Dica</span>
                        </button>
                        <div className="w-px h-6 bg-white/10"></div>
                        <button onClick={(e)=>{ stopAdEvent(e); handleAuto()}} className="flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 text-emerald-400 transition">
                            <Wand2 size={18} /><span className="text-[8px] uppercase font-bold mt-0.5">Auto</span>
                        </button>
                        </>
                    )}
                    <div className="w-px h-6 bg-white/10"></div>
                    <button onClick={(e)=>{ stopAdEvent(e); setIsSoundEnabled(!isSoundEnabled)}} className={`flex flex-col items-center p-1.5 rounded-lg w-11 hover:bg-white/10 transition ${isSoundEnabled?'text-white':'text-white/30'}`}>
                        {isSoundEnabled ? <Volume2 size={18} /> : <VolumeX size={18} />}<span className="text-[8px] uppercase font-bold mt-0.5">Som</span>
                    </button>
                </DraggableMenu>

                <div className="fixed bottom-28 right-4 z-40 hidden md:flex flex-col gap-2 pointer-events-none">
                    <div className="bg-black/80 backdrop-blur-md text-white/90 text-xs font-mono py-1.5 px-3 rounded-full shadow-lg border border-white/10 flex items-center gap-2 pointer-events-auto">
                        <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse shadow-[0_0_8px_#22c55e]"></div><span className="font-bold text-white">{onlineCount}</span> online
                    </div>
                    <div className="bg-black/80 backdrop-blur-md text-white/90 text-xs font-mono py-1.5 px-3 rounded-full shadow-lg border border-white/10 flex items-center gap-2 pointer-events-auto">
                        <Eye className="w-3 h-3 text-blue-400" /><span>{visitCount.toLocaleString()}</span> visitas
                    </div>
                </div>
                
                {showInstallModal && <InstallModal onInstall={handleInstallClick} onClose={()=>setShowInstallModal(false)} deferredPrompt={deferredPrompt} isIOS={/iPhone|iPad|iPod/.test(navigator.userAgent)} />}
                
                {(gameState.gameWon || showWinningBounce) && (
                    <>
                        <div className="fixed inset-0 z-[155] flex items-center justify-center pointer-events-none"><h1 className="text-[12vw] font-black uppercase tracking-tighter victory-text">Vitória!</h1></div>
                        <div className="fixed inset-0 z-[150] flex items-center justify-center pointer-events-auto bg-black/60 backdrop-blur-sm p-4">
                            <div className="bg-white rounded-2xl p-6 md:p-8 max-w-md w-full text-center shadow-2xl transform scale-105 border-4 border-yellow-400 relative overflow-hidden animate-in fade-in zoom-in">
                                  <div className="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-yellow-300 via-yellow-500 to-yellow-300"></div>
                                  <div className="inline-flex p-4 rounded-full bg-yellow-50 mb-4 ring-4 ring-yellow-100 shadow-lg animate-bounce"><Trophy className="w-16 h-16 text-yellow-600 drop-shadow-sm" /></div>
                                  <h2 className="text-4xl font-serif font-black text-gray-900 mb-2 uppercase tracking-tight">Vitória!</h2>
                                  <p className="text-gray-600 mb-6 font-medium">Parabéns! Você completou o jogo em <span className="text-emerald-600 font-bold">{gameState.moves}</span> jogadas.</p>
                                  <div className="w-full h-[60px] bg-gray-100 mb-6 rounded-lg overflow-hidden border border-gray-200 shadow-inner flex items-center justify-center"><AdsterraBanner width={320} height={50} dataKey="40ea244e14933019fbfcc00a3875f885" /></div>
                                  <button onClick={startNewGame} className="w-full bg-gradient-to-r from-emerald-600 to-emerald-500 hover:from-emerald-500 hover:to-emerald-400 text-white font-bold py-3.5 px-6 rounded-xl transition-all transform hover:scale-[1.02] shadow-lg active:scale-95 flex items-center justify-center gap-2"><RotateCcw className="w-5 h-5" /> Jogar Novamente</button>
                              </div>
                        </div>
                        <Confetti />
                        <WinningBounce foundation={gameState.foundation} />
                    </>
                )}
            </div>
        );
      }
      
      const Confetti = () => {
         const canvasRef = useRef(null);
         useEffect(() => {
            const canvas = canvasRef.current; if(!canvas) return;
            const ctx = canvas.getContext('2d');
            let w = canvas.width = window.innerWidth; let h = canvas.height = window.innerHeight;
            const particles = Array.from({length: 150}, () => ({ x: Math.random()*w, y: Math.random()*h - h, vx: Math.random()*4-2, vy: Math.random()*5+2, color: ['#FFD700','#FF0000','#00FF00','#0000FF','#FF00FF'][Math.floor(Math.random()*5)], size: Math.random()*10+5, rot: Math.random()*360, rotS: Math.random()*10-5 }));
            let anim;
            const loop = () => {
                ctx.clearRect(0,0,w,h);
                particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.rot+=p.rotS; if(p.y>h) { p.y=-p.size; p.x=Math.random()*w; } ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot*Math.PI/180); ctx.fillStyle=p.color; ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size); ctx.restore(); });
                anim = requestAnimationFrame(loop);
            };
            loop(); return () => cancelAnimationFrame(anim);
         }, []);
         return <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-[150]" />;
      };

      const WinningBounce = ({ foundation }) => {
          const canvasRef = useRef(null);
          useEffect(() => {
              const canvas = canvasRef.current; if(!canvas) return; const ctx = canvas.getContext('2d');
              let w = canvas.width = window.innerWidth; let h = canvas.height = window.innerHeight;
              const cards = []; const gravity = 0.8; let frame = 0, anim;
              const spawn = () => { if(frame % 5 === 0 && cards.length < 200) { cards.push({ x: Math.random() * w, y: -100, vx: Math.random()*10-5, vy: 0, w: 40, h: 56, color: Math.random()>0.5?'#d40000':'#1a1a1a', bounce: 0.7+Math.random()*0.2 }); } };
              const loop = () => {
                  ctx.clearRect(0,0,w,h); spawn();
                  cards.forEach(c => { c.vy += gravity; c.x += c.vx; c.y += c.vy; if(c.y + c.h > h) { c.y = h - c.h; c.vy *= -c.bounce; if(Math.abs(c.vy)<gravity*2) c.vy=0; } ctx.fillStyle = '#fff'; ctx.fillRect(c.x,c.y,c.w,c.h); ctx.fillStyle = c.color; ctx.fillRect(c.x+5,c.y+5,c.w-10,c.h-10); });
                  frame++; anim = requestAnimationFrame(loop);
              };
              loop(); return () => cancelAnimationFrame(anim);
          }, []);
          return <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-[160]" />;
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>