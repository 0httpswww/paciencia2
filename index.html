<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>JoGos Online</title>
    <meta name="description" content="JoGos Online - Arcade, Racing & Learning.">
    <meta name="theme-color" content="#050505">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://r2.erweima.ai/img/compressed/47748805f42289196b6134a65b3c58e4.png">
    
    <!-- Monetag Popunder Script -->
    <script src="https://quge5.com/88/tag.min.js" data-zone="187944" async data-cfasync="false"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { 
            overscroll-behavior: none; 
            touch-action: none; 
            -webkit-tap-highlight-color: transparent; 
            font-family: 'Courier New', Courier, monospace;
            background-color: #050505;
            /* Grid Background */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            color: white; 
            user-select: none; 
            -webkit-user-select: none; 
            overflow: hidden;
        }

        /* Dark Futuristic Professional Title */
        .neon-title {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            font-weight: 900;
            background: linear-gradient(180deg, #e2e8f0 0%, #94a3b8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 
                0 0 20px rgba(148, 163, 184, 0.3);
            filter: drop-shadow(0 0 2px rgba(148, 163, 184, 0.5));
            letter-spacing: -2px;
            text-transform: uppercase;
        }

        .neon-text-small {
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        /* White Glow for Menu Items */
        .glass-box {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }
        .glass-box:hover {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.02);
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
        "lucide-react": "https://aistudiocdn.com/lucide-react@^0.554.0"
      }
    }
    </script>
    
    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js').then(function(registration) {
                    console.log('ServiceWorker registration successful');
                }, function(err) {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</head>
<body>
    <div id="root" class="h-[100dvh] w-full overflow-hidden flex flex-col"></div>

    <script type="text/babel" data-type="module" data-presets="typescript,react">
      import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
      import { createRoot } from 'react-dom/client';
      import { Expand, Shrink, RefreshCw, Rocket, ChevronLeft, Shield, Zap, Car, Languages, Heart, Star, CheckCircle, XCircle, Volume2 } from 'lucide-react';

      // --- Sound System (Synthesized & Safe) ---
      let audioContext = null;

      const getAudioContext = () => {
          if (!audioContext) {
              const AudioCtx = window.AudioContext || window.webkitAudioContext;
              if (AudioCtx) {
                  audioContext = new AudioCtx();
              }
          }
          return audioContext;
      };

      const playSound = (type, pitchMod = 0) => {
          const ctx = getAudioContext();
          if (!ctx) return;
          if (ctx.state === 'suspended') ctx.resume().catch(() => {});

          const osc = ctx.createOscillator();
          const gainNode = ctx.createGain();
          osc.connect(gainNode);
          gainNode.connect(ctx.destination);

          const now = ctx.currentTime;

          switch(type) {
              case 'shoot':
                  osc.type = 'square';
                  osc.frequency.setValueAtTime(880, now);
                  osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'laser':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(1200, now);
                  osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
                  osc.start(now);
                  osc.stop(now + 0.15);
                  break;
              case 'enemy_shoot':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(400, now);
                  osc.frequency.linearRampToValueAtTime(200, now + 0.1);
                  gainNode.gain.setValueAtTime(0.03, now);
                  gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'explosion':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(100, now);
                  osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                  osc.start(now);
                  osc.stop(now + 0.5);
                  break;
              case 'engine':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(100 + pitchMod, now);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                  osc.start(now);
                  osc.stop(now + 0.1);
                  break;
              case 'drift':
                  osc.type = 'triangle';
                  osc.frequency.setValueAtTime(800, now);
                  osc.frequency.linearRampToValueAtTime(600, now + 0.2);
                  gainNode.gain.setValueAtTime(0.05, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                  osc.start(now);
                  osc.stop(now + 0.2);
                  break;
              case 'correct':
                  osc.type = 'sine';
                  osc.frequency.setValueAtTime(600, now);
                  osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                  osc.start(now);
                  osc.stop(now + 0.2);
                  break;
              case 'wrong':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(200, now);
                  osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                  osc.start(now);
                  osc.stop(now + 0.3);
                  break;
              case 'powerup':
                  osc.type = 'sine';
                  osc.frequency.setValueAtTime(400, now);
                  osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                  osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
                  gainNode.gain.setValueAtTime(0.1, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                  osc.start(now);
                  osc.stop(now + 0.2);
                  break;
              case 'boss_spawn':
                  osc.type = 'sawtooth';
                  osc.frequency.setValueAtTime(100, now);
                  osc.frequency.linearRampToValueAtTime(50, now + 1.0);
                  gainNode.gain.setValueAtTime(0.3, now);
                  gainNode.gain.linearRampToValueAtTime(0, now + 1.0);
                  osc.start(now);
                  osc.stop(now + 1.0);
                  break;
          }
      };

      const speakText = (text) => {
          if ('speechSynthesis' in window) {
               window.speechSynthesis.cancel();
               const utterance = new SpeechSynthesisUtterance(text);
               utterance.lang = 'en-US';
               utterance.rate = 0.9;
               window.speechSynthesis.speak(utterance);
          }
      };

      // --- LinguaQuest ---
      const LinguaQuest = ({ onBack, triggerAd }) => {
          const lessonsData = useMemo(() => [
              { id: 1, type: 'translate', q: 'The cat eats fish', a: ['O gato come peixe', 'O cachorro bebe agua', 'O passaro voa'], correct: 0 },
              { id: 2, type: 'listen', q: 'Hello, how are you?', a: ['Ola, como vai voce?', 'Adeus, ate logo', 'Bom dia, amigo'], correct: 0, text: 'Hello, how are you?' },
              { id: 3, type: 'translate', q: 'Where is the library?', a: ['Onde fica a biblioteca?', 'Onde esta o livro?', 'Eu gosto de ler'], correct: 0 },
              { id: 4, type: 'translate', q: 'I like to play soccer', a: ['Eu gosto de jogar futebol', 'Eu gosto de comer', 'Eu nao gosto de esporte'], correct: 0 },
              { id: 5, type: 'listen', q: 'Good morning', a: ['Bom dia', 'Boa noite', 'Boa tarde'], correct: 0, text: 'Good morning' },
              { id: 6, type: 'translate', q: 'My car is blue', a: ['Meu carro e azul', 'Minha casa e azul', 'O ceu e azul'], correct: 0 },
          ], []);

          const [currentLesson, setCurrentLesson] = useState(0);
          const [hearts, setHearts] = useState(5);
          const [xp, setXp] = useState(0);
          const [status, setStatus] = useState('playing'); 
          const [selectedOption, setSelectedOption] = useState(null);

          const handleCheck = () => {
              if (selectedOption === null) return;
              const lesson = lessonsData[currentLesson];
              if (selectedOption === lesson.correct) {
                  setStatus('correct');
                  playSound('correct');
                  setXp(p => p + 10);
              } else {
                  setStatus('wrong');
                  playSound('wrong');
                  setHearts(h => h - 1);
              }
          };

          const handleNext = () => {
              if (hearts <= 0) { setStatus('failed'); return; }
              if (currentLesson < lessonsData.length - 1) {
                  setCurrentLesson(p => p + 1);
                  setStatus('playing');
                  setSelectedOption(null);
              } else {
                  setStatus('completed');
                  triggerAd();
              }
          };

          const restart = () => {
              setCurrentLesson(0);
              setHearts(5);
              setStatus('playing');
              setSelectedOption(null);
              triggerAd();
          };

          const lesson = lessonsData[currentLesson];

          if (status === 'completed') {
              return (
                  <div className="w-full h-full flex flex-col items-center justify-center bg-[#111] text-white p-6">
                      <Star size={64} className="text-yellow-400 mb-4 animate-bounce" />
                      <h2 className="text-3xl font-bold mb-2 neon-text-small">Lesson Complete!</h2>
                      <p className="text-gray-400 mb-8">+50 XP Earned</p>
                      <button onClick={restart} className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transform transition hover:scale-105">Continue</button>
                  </div>
              );
          }
          if (status === 'failed') {
               return (
                  <div className="w-full h-full flex flex-col items-center justify-center bg-[#111] text-white p-6">
                      <Heart size={64} className="text-red-500 mb-4 animate-pulse" />
                      <h2 className="text-3xl font-bold mb-2">Out of Hearts!</h2>
                      <button onClick={restart} className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full shadow-lg">Try Again</button>
                  </div>
              );
          }

          return (
              <div className="w-full h-full flex flex-col bg-[#111] text-white">
                  <div className="flex items-center justify-between p-4 border-b border-gray-800">
                      <button onClick={onBack}><XCircle className="text-gray-400" /></button>
                      <div className="flex-1 mx-4 bg-gray-700 h-3 rounded-full overflow-hidden">
                          <div className="bg-green-500 h-full transition-all duration-500" style={{ width: `${((currentLesson) / lessonsData.length) * 100}%` }}></div>
                      </div>
                      <div className="flex items-center gap-1 text-red-500"><Heart fill="currentColor" size={20} /><span className="font-bold">{hearts}</span></div>
                  </div>
                  <div className="flex-1 flex flex-col items-center justify-center p-6 max-w-lg mx-auto w-full">
                      <h2 className="text-2xl font-bold mb-8 text-center">{lesson.type === 'translate' ? 'Translate this sentence' : 'Listen and select'}</h2>
                      {lesson.type === 'listen' && (
                          <button onClick={() => speakText(lesson.text)} className="mb-8 p-6 bg-blue-500/20 border-2 border-blue-500 rounded-2xl hover:bg-blue-500/30 transition">
                              <Volume2 size={48} className="text-blue-400" />
                          </button>
                      )}
                      {lesson.type === 'translate' && (
                          <div className="mb-8 p-4 border border-gray-600 rounded-xl flex items-center gap-3">
                              <div className="w-12 h-12 bg-green-500 rounded-full flex items-center justify-center font-bold text-2xl text-black">D</div>
                              <div className="bg-gray-800 p-3 rounded-xl rounded-tl-none border border-gray-700">{lesson.q}</div>
                          </div>
                      )}
                      <div className="w-full grid gap-3">
                          {lesson.a.map((option, idx) => (
                              <button key={idx} onClick={() => status === 'playing' && setSelectedOption(idx)} disabled={status !== 'playing'}
                                  className={`p-4 rounded-xl border-2 text-left transition-all transform ${selectedOption === idx ? 'border-blue-500 bg-blue-500/20' : 'border-gray-700 hover:bg-gray-800'}`}>
                                  {option}
                              </button>
                          ))}
                      </div>
                  </div>
                  <div className={`p-4 border-t ${status === 'correct' ? 'bg-green-900/30 border-green-500' : (status === 'wrong' ? 'bg-red-900/30 border-red-500' : 'border-gray-800')}`}>
                      <div className="max-w-lg mx-auto flex items-center justify-between">
                          {status === 'correct' && (<div className="flex items-center gap-2 text-green-400 font-bold"><CheckCircle size={32} /><span>Correct!</span></div>)}
                          {status === 'wrong' && (<div className="flex items-center gap-2 text-red-400 font-bold"><XCircle size={32} /><div><span>Correct answer:</span><span className="text-sm font-normal text-white ml-2">{lesson.a[lesson.correct]}</span></div></div>)}
                          {status === 'playing' ? (
                              <button onClick={handleCheck} disabled={selectedOption === null} className={`w-full py-3 rounded-xl font-bold transition ${selectedOption !== null ? 'bg-green-500 text-white hover:bg-green-600' : 'bg-gray-700 text-gray-500'}`}>CHECK</button>
                          ) : (
                              <button onClick={handleNext} className={`ml-auto px-8 py-3 rounded-xl font-bold text-white transition ${status === 'correct' ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'}`}>CONTINUE</button>
                          )}
                      </div>
                  </div>
              </div>
          );
      };

      // --- Neon Racer ---
      const NeonRacer = ({ onBack, triggerAd }) => {
          const canvasRef = useRef(null);
          const requestRef = useRef();
          const gameState = useRef({
              speed: 0, maxSpeed: 250, position: 0, playerX: 0, score: 0, segments: [], roadWidth: 2000, segmentLength: 200, trackLength: 0, fov: 100, cameraHeight: 1000, cameraDepth: 0.84,
              colors: { light: { road: '#333', grass: '#111', rumble: '#555', lane: '#CCCCCC' }, dark: { road: '#222', grass: '#050505', rumble: '#BBBBBB', lane: '#000000' } },
              keys: { left: false, right: false, up: false, down: false }, bgOffset: 0, lap: 1, totalLaps: 3
          });

          useEffect(() => {
              const g = gameState.current;
              g.segments = [];
              const addSegment = (curve) => {
                  const n = g.segments.length;
                  g.segments.push({
                      index: n,
                      p1: { world: { y: 0, z: n * g.segmentLength }, camera: {}, screen: {} },
                      p2: { world: { y: 0, z: (n + 1) * g.segmentLength }, camera: {}, screen: {} },
                      curve: curve, color: Math.floor(n / 3) % 2 ? g.colors.dark : g.colors.light
                  });
              };
              for(let i=0; i<500; i++) addSegment(0);
              for(let i=0; i<400; i++) addSegment(i < 200 ? 2 : -2);
              for(let i=0; i<400; i++) addSegment(i < 200 ? -2 : 2);
              for(let i=0; i<200; i++) addSegment(0);
              for(let i=0; i<600; i++) addSegment(i < 300 ? -3 : 3);
              for(let i=0; i<200; i++) addSegment(0);
              g.trackLength = g.segments.length * g.segmentLength;
          }, []);

          const project = (p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) => {
              p.camera.x = (p.world.x || 0) - cameraX; p.camera.y = (p.world.y || 0) - cameraY; p.camera.z = (p.world.z || 0) - cameraZ;
              if (p.camera.z <= 0) return;
              p.screen.scale = cameraDepth / p.camera.z;
              p.screen.x = Math.round((width / 2) + (p.screen.scale * p.camera.x * width / 2));
              p.screen.y = Math.round((height / 2) - (p.screen.scale * p.camera.y * height / 2));
              p.screen.w = Math.round(p.screen.scale * roadWidth * width / 2);
          };

          const renderPolygon = (ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) => {
              ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4); ctx.closePath(); ctx.fill();
          };

          const update = (dt) => {
              const g = gameState.current;
              const playerSegment = g.segments[Math.floor(g.position / g.segmentLength) % g.segments.length];
              const speedPercent = g.speed / g.maxSpeed;
              const dx = dt * 2 * speedPercent; 
              g.position = (g.position + dt * g.speed) % g.trackLength;
              if (g.keys.left) g.playerX -= dx; else if (g.keys.right) g.playerX += dx;
              g.playerX -= (dx * speedPercent * playerSegment.curve * 2);
              if (g.keys.up) g.speed += 100 * dt; else if (g.keys.down) g.speed -= 300 * dt; else g.speed -= 50 * dt;
              g.playerX = Math.max(-2, Math.min(2, g.playerX)); g.speed = Math.max(0, Math.min(g.maxSpeed, g.speed));
              if (g.speed > 10 && Math.random() < 0.1) playSound('engine', g.speed / 2);
              if (Math.abs(playerSegment.curve) > 1 && g.speed > 150 && Math.random() < 0.1) playSound('drift');
              g.bgOffset = (g.bgOffset + playerSegment.curve * speedPercent) % 1000;
          };

          const draw = (ctx, width, height) => {
              const g = gameState.current;
              ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);
              ctx.fillStyle = '#1a0b2e'; ctx.beginPath(); ctx.moveTo(0, height/2);
              for(let i=0; i<=width; i+=50) ctx.lineTo(i, (height/2) - 50 - Math.sin((i + g.bgOffset)/100)*30);
              ctx.lineTo(width, height/2); ctx.fill();

              let baseSegment = g.segments[Math.floor(g.position / g.segmentLength) % g.segments.length];
              let basePercent = (g.position % g.segmentLength) / g.segmentLength;
              let playerX = g.playerX * g.roadWidth;
              let dx = -(baseSegment.curve * basePercent);
              let x = 0; let maxY = height;

              for(let n=0; n<300; n++) {
                  let id = (baseSegment.index + n) % g.segments.length; let segment = g.segments[id];
                  let loop = Math.floor((baseSegment.index + n) / g.segments.length);
                  segment.p1.world.x = x - playerX - dx; segment.p1.world.z = (n * g.segmentLength) + (loop * g.trackLength) - (g.position % g.segmentLength);
                  project(segment.p1, 0, g.cameraHeight, 0, g.cameraDepth, width, height, g.roadWidth);
                  x += dx; dx += segment.curve;
                  segment.p2.world.x = x - playerX - dx; segment.p2.world.z = ((n+1) * g.segmentLength) + (loop * g.trackLength) - (g.position % g.segmentLength);
                  project(segment.p2, 0, g.cameraHeight, 0, g.cameraDepth, width, height, g.roadWidth);

                  if (segment.p1.camera.z <= 0 || segment.p2.screen.y >= maxY || segment.p2.screen.y >= segment.p1.screen.y) continue;
                  renderPolygon(ctx, segment.p1.screen.x - segment.p1.screen.w, segment.p1.screen.y, segment.p1.screen.x + segment.p1.screen.w, segment.p1.screen.y, segment.p2.screen.x + segment.p2.screen.w, segment.p2.screen.y, segment.p2.screen.x - segment.p2.screen.w, segment.p2.screen.y, segment.color.grass);
                  renderPolygon(ctx, segment.p1.screen.x - segment.p1.screen.w * 0.8, segment.p1.screen.y, segment.p1.screen.x + segment.p1.screen.w * 0.8, segment.p1.screen.y, segment.p2.screen.x + segment.p2.screen.w * 0.8, segment.p2.screen.y, segment.p2.screen.x - segment.p2.screen.w * 0.8, segment.p2.screen.y, segment.color.rumble);
                  renderPolygon(ctx, segment.p1.screen.x - segment.p1.screen.w * 0.7, segment.p1.screen.y, segment.p1.screen.x + segment.p1.screen.w * 0.7, segment.p1.screen.y, segment.p2.screen.x + segment.p2.screen.w * 0.7, segment.p2.screen.y, segment.p2.screen.x - segment.p2.screen.w * 0.7, segment.p2.screen.y, segment.color.road);
                  maxY = segment.p1.screen.y;
              }

              const carW = width * 0.3; const carH = carW * 0.5; const carX = width / 2 - carW / 2; const carY = height - carH - 20;
              ctx.fillStyle = '#ff0055'; ctx.shadowColor = '#ff0055'; ctx.shadowBlur = 20; ctx.fillRect(carX, carY + carH/2, carW, carH/2);
              ctx.beginPath(); ctx.moveTo(carX + carW*0.1, carY + carH/2); ctx.lineTo(carX + carW*0.2, carY); ctx.lineTo(carX + carW*0.8, carY); ctx.lineTo(carX + carW*0.9, carY + carH/2); ctx.fill();
              ctx.fillStyle = '#ffaaaa'; ctx.shadowBlur = 10; ctx.fillRect(carX + carW*0.1, carY + carH*0.6, carW*0.15, carH*0.15); ctx.fillRect(carX + carW*0.75, carY + carH*0.6, carW*0.15, carH*0.15); ctx.shadowBlur = 0;
              ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(10, 10, 120, 40); ctx.fillStyle = '#0ff'; ctx.font = '20px Courier'; ctx.fillText(`${Math.floor(g.speed)} km/h`, 20, 35);
          };

          useEffect(() => {
              const canvas = canvasRef.current;
              let lastTime = Date.now();
              const down = (e) => { switch(e.key) { case 'ArrowLeft': gameState.current.keys.left = true; break; case 'ArrowRight': gameState.current.keys.right = true; break; case 'ArrowUp': gameState.current.keys.up = true; break; case 'ArrowDown': gameState.current.keys.down = true; break; } };
              const up = (e) => { switch(e.key) { case 'ArrowLeft': gameState.current.keys.left = false; break; case 'ArrowRight': gameState.current.keys.right = false; break; case 'ArrowUp': gameState.current.keys.up = false; break; case 'ArrowDown': gameState.current.keys.down = false; break; } };
              const tStart = (e) => { e.preventDefault(); const x = e.touches[0].clientX; const w = window.innerWidth; if (x < w/3) gameState.current.keys.left = true; else if (x > w*2/3) gameState.current.keys.right = true; else gameState.current.keys.up = true; };
              const tEnd = () => { gameState.current.keys.left = false; gameState.current.keys.right = false; gameState.current.keys.up = false; };
              window.addEventListener('keydown', down); window.addEventListener('keyup', up); canvas.addEventListener('touchstart', tStart, {passive: false}); canvas.addEventListener('touchend', tEnd);
              const handleResize = () => { if (canvas && canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; } };
              window.addEventListener('resize', handleResize); handleResize();
              const loop = () => { const now = Date.now(); const dt = Math.min(1, (now - lastTime) / 1000); lastTime = now; update(dt); if (canvas) draw(canvas.getContext('2d'), canvas.width, canvas.height); requestRef.current = requestAnimationFrame(loop); };
              requestRef.current = requestAnimationFrame(loop);
              return () => { window.removeEventListener('keydown', down); window.removeEventListener('keyup', up); window.removeEventListener('resize', handleResize); cancelAnimationFrame(requestRef.current); };
          }, []);

          return (
              <div className="w-full h-full relative">
                  <canvas ref={canvasRef} className="block w-full h-full" />
                  <div className="absolute top-4 left-4"><button onClick={onBack} className="p-3 bg-black/50 text-white rounded-full"><ChevronLeft /></button></div>
                  <div className="absolute bottom-10 w-full text-center text-white/50 text-sm pointer-events-none">Tap Sides to Turn â€¢ Center to Accel</div>
              </div>
          );
      };

      // --- Galaxy Invader ---
      const GalaxyInvader = ({ onBack, triggerAd }) => {
          const canvasRef = useRef(null);
          const game = useRef({
              player: { x: 0, y: 0, w: 40, h: 40, health: 100, maxHealth: 100, weaponLevel: 1, shieldActive: false, shieldTimer: 0, damageMultiplier: 1, lastShot: 0, shootAngle: 0 },
              bullets: [], enemies: [], powerups: [], boss: null, particles: [], stars: [],
              score: 0, level: 1, nextBossThreshold: 5000, gameState: 'menu', width: 0, height: 0,
          });
          const [gameOver, setGameOver] = useState(false);

          const initGame = useCallback(() => {
              const canvas = canvasRef.current;
              const g = game.current;
              g.width = canvas.width;
              g.height = canvas.height;
              g.player.x = g.width / 2 - g.player.w / 2;
              g.player.y = g.height - 100;
              g.player.health = 100;
              g.player.weaponLevel = 1;
              g.player.shieldActive = false;
              g.score = 0; g.level = 1; g.nextBossThreshold = 5000;
              g.bullets = []; g.enemies = []; g.powerups = []; g.boss = null; g.particles = [];
              g.gameState = 'playing';
              setGameOver(false);
              g.stars = [];
              for(let i=0; i<80; i++) g.stars.push({ x: Math.random() * g.width, y: Math.random() * g.height, size: Math.random() * 2, speed: Math.random() * 3 + 0.5 });
          }, []);

          const spawnPowerup = (x, y) => {
              if (Math.random() < 0.35) { 
                  const type = Math.random() < 0.8 ? 'weapon' : 'shield';
                  game.current.powerups.push({ x, y, w: 20, h: 20, type, vy: 2 });
              }
          };

          const getClosestEnemy = (x, y) => {
              const g = game.current;
              let closest = null; let minDist = Infinity;
              const targets = g.boss ? [g.boss] : g.enemies;
              targets.forEach(e => {
                  const dx = e.x - x; const dy = e.y - y; const dist = Math.sqrt(dx*dx + dy*dy);
                  if (dist < minDist) { minDist = dist; closest = e; }
              });
              return closest;
          };

          const spawnEnemy = useCallback(() => {
              const g = game.current;
              if (g.gameState !== 'playing' || g.boss) return;

              if (Math.random() < 0.02 + g.level * 0.003) {
                  const rand = Math.random();
                  let type = 'drone'; 
                  
                  if (rand > 0.96) type = 'hive';
                  else if (rand > 0.92) type = 'cube';
                  else if (rand > 0.88) type = 'disc';
                  else if (rand > 0.84) type = 'specter';
                  else if (rand > 0.75) type = 'kamikaze';
                  else if (rand > 0.65) type = 'spider';
                  else if (rand > 0.55) type = 'satellite';
                  else if (rand > 0.45) type = 'tower';
                  else if (rand > 0.30) type = 'snake';
                  else type = 'drone';

                  let w=30, h=30, health=g.level, vx=0, vy=2, points=100;
                  const e = { type, x: Math.random() * (g.width - 40), y: -50, lastShot: Date.now() + Math.random()*1000, tick: 0, trail: [] };

                  switch(type) {
                      case 'drone': w=30; h=30; health=2*g.level; vy=4; points=100; break;
                      case 'snake': w=25; h=25; health=3*g.level; vy=2; points=150; e.trail = []; break;
                      case 'tower': w=40; h=40; health=5*g.level; vy=0.5; points=200; e.angle = 0; break;
                      case 'spider': w=35; h=35; health=3*g.level; vy=2; points=150; e.baseX = e.x; break;
                      case 'satellite': w=35; h=35; health=6*g.level; vy=1; points=250; e.angle = 0; break;
                      case 'cube': w=35; h=35; health=5*g.level; vy=1.5; points=300; break;
                      case 'specter': w=30; h=30; health=2*g.level; vy=2; points=150; e.opacity = 0.5; break;
                      case 'kamikaze': w=25; h=30; health=1; vy=6; points=50; break;
                      case 'disc': w=40; h=20; health=4*g.level; vy=2; points=200; e.baseX = e.x; break;
                      case 'hive': w=60; h=50; health=12*g.level; vy=0.5; points=500; e.lastSpawn = Date.now(); break;
                  }

                  e.w = w; e.h = h; e.health = health; e.maxHealth = health; e.vx = vx; e.vy = vy; e.points = points;
                  g.enemies.push(e);
              }
          }, []);

          // --- 10 Unique Boss Types ---
          const spawnBoss = useCallback(() => {
              const g = game.current;
              g.gameState = 'boss';
              g.enemies = []; 
              playSound('boss_spawn');

              const bossTypes = [
                  'pyramid', 'hydra', 'orb', 'dragon', 'spider', 
                  'cube', 'parasite', 'star', 'tank', 'clock'
              ];
              const type = bossTypes[(g.level - 1) % bossTypes.length];
              let w=120, h=120, hp=200 * g.level;

              // Boss specific stats
              if (type === 'hydra') { w=150; h=100; hp*=1.2; }
              if (type === 'dragon') { w=80; h=200; hp*=1.1; }
              if (type === 'spider') { w=180; h=120; hp*=1.3; }
              if (type === 'tank') { w=140; h=160; hp*=1.5; }
              if (type === 'clock') { w=130; h=130; hp*=1.2; }

              g.boss = {
                  type,
                  x: g.width / 2 - w/2, y: -150, w, h,
                  health: hp, maxHealth: hp,
                  phase: 1, lastShot: Date.now(), moveDir: 1, attackType: 0, tick: 0,
                  subComponents: [] 
              };
          }, []);

          const updateBoss = (g) => {
              if (!g.boss) return;
              const boss = g.boss;
              const now = Date.now();
              boss.tick += 0.05;

              // Movement
              if (boss.y < 50) boss.y += 1;
              
              if (boss.type === 'dragon') {
                  boss.x += Math.sin(boss.tick * 0.5) * 3;
              } else if (boss.type === 'spider') {
                   boss.x = (g.width/2 - boss.w/2) + Math.sin(boss.tick) * 100;
              } else {
                  boss.x += boss.moveDir * (1 + g.level * 0.1);
                  if (boss.x <= 20 || boss.x + boss.w >= g.width - 20) boss.moveDir *= -1;
              }

              // Attack Logic
              let fireRate = 800;
              if (boss.type === 'hydra') fireRate = 600;
              if (boss.type === 'tank') fireRate = 400;

              if (now - boss.lastShot > fireRate) {
                  boss.attackType = (boss.attackType + 1) % 3;
                  const cx = boss.x + boss.w/2;
                  const cy = boss.y + boss.h/2;

                  if (boss.type === 'pyramid') {
                      if (boss.attackType === 0) { // Triangle Spread
                          for(let i=-1; i<=1; i++) g.bullets.push({x: cx, y: boss.y+boss.h, w:8, h:15, owner:'enemy', vx:i*3, vy:6, color:'#facc15'});
                      } else if (boss.attackType === 1) { // Homing Pyramids
                           g.bullets.push({x: cx, y: boss.y+boss.h, w:10, h:10, owner:'enemy', vx:0, vy:4, color:'#facc15', behavior:'homing'});
                      } else { // Center Beam
                           g.bullets.push({x: cx-10, y: boss.y+boss.h, w:20, h:50, owner:'enemy', vx:0, vy:10, color:'#fbbf24'});
                      }
                  } else if (boss.type === 'hydra') {
                       // 3 Heads firing
                       const heads = [boss.x + 20, cx, boss.x + boss.w - 20];
                       heads.forEach((hx, i) => {
                           if (i === boss.attackType) return; // Alternate heads
                           g.bullets.push({x: hx, y: boss.y+boss.h, w:8, h:8, owner:'enemy', vx:(Math.random()-0.5)*2, vy:5, color: i===0?'#60a5fa':(i===1?'#34d399':'#f87171')});
                       });
                  } else if (boss.type === 'orb') {
                      if (boss.attackType === 0) { // 360 wave
                          for(let i=0; i<12; i++) {
                              const a = (i/12)*Math.PI*2 + boss.tick;
                              g.bullets.push({x: cx, y: cy, w:6, h:6, owner:'enemy', vx:Math.cos(a)*4, vy:Math.sin(a)*4, color:'#3b82f6'});
                          }
                      } else { // Gravity shots
                          g.bullets.push({x: cx, y: cy, w:10, h:10, owner:'enemy', vx:(g.player.x-cx)*0.01, vy:4, color:'#60a5fa', behavior:'curve'});
                      }
                  } else if (boss.type === 'dragon') {
                       g.bullets.push({x: cx, y: boss.y+boss.h, w:12, h:20, owner:'enemy', vx:0, vy:7, color:'#ef4444'}); // Fire breath
                       if (boss.attackType === 2) {
                           g.bullets.push({x: boss.x, y: boss.y+boss.h/2, w:6, h:12, owner:'enemy', vx:-2, vy:4, color:'#f87171', behavior:'homing'});
                           g.bullets.push({x: boss.x+boss.w, y: boss.y+boss.h/2, w:6, h:12, owner:'enemy', vx:2, vy:4, color:'#f87171', behavior:'homing'});
                       }
                  } else if (boss.type === 'spider') {
                       // Web shot (Slow, wide)
                       if (boss.attackType === 0) {
                           for(let i=-2; i<=2; i++) g.bullets.push({x: cx, y: cy, w:4, h:4, owner:'enemy', vx:i*2, vy:3, color:'#22c55e'});
                       } else { // Rain
                           g.bullets.push({x: Math.random()*g.width, y: 0, w:5, h:15, owner:'enemy', vx:0, vy:8, color:'#4ade80'});
                           g.bullets.push({x: Math.random()*g.width, y: 0, w:5, h:15, owner:'enemy', vx:0, vy:8, color:'#4ade80'});
                       }
                  } else if (boss.type === 'cube') {
                       // 6 Directions from faces (Simulated)
                       [0, Math.PI/2, Math.PI, 3*Math.PI/2].forEach(a => {
                           g.bullets.push({x: cx, y: cy, w:8, h:8, owner:'enemy', vx:Math.cos(a+boss.tick)*4, vy:Math.sin(a+boss.tick)*4, color:'#d8b4fe'});
                       });
                  } else if (boss.type === 'parasite') {
                       // Spores
                       for(let i=0; i<3; i++) g.bullets.push({x: cx + (Math.random()-0.5)*40, y: cy + (Math.random()-0.5)*40, w:6, h:6, owner:'enemy', vx:(Math.random()-0.5)*3, vy:2+Math.random()*2, color:'#f472b6'});
                  } else if (boss.type === 'star') {
                       // Radial Explosion
                       if (boss.attackType === 2) {
                           for(let i=0; i<8; i++) {
                              const a = (i/8)*Math.PI*2;
                              g.bullets.push({x: cx, y: cy, w:8, h:8, owner:'enemy', vx:Math.cos(a)*6, vy:Math.sin(a)*6, color:'#fbbf24'});
                           }
                       } else {
                           g.bullets.push({x: cx, y: cy, w:5, h:20, owner:'enemy', vx:0, vy:8, color:'#f59e0b'});
                       }
                  } else if (boss.type === 'tank') {
                       // Heavy Machine Gun
                       g.bullets.push({x: boss.x+20, y: boss.y+boss.h, w:4, h:10, owner:'enemy', vx:0, vy:8, color:'#9ca3af'});
                       g.bullets.push({x: boss.x+boss.w-20, y: boss.y+boss.h, w:4, h:10, owner:'enemy', vx:0, vy:8, color:'#9ca3af'});
                       if (boss.attackType === 2) g.bullets.push({x: cx, y: boss.y+boss.h, w:20, h:20, owner:'enemy', vx:0, vy:4, color:'#ef4444'}); // Main Cannon
                  } else if (boss.type === 'clock') {
                       // Rhythmic bursts
                       const angle = (Date.now() / 1000) % (Math.PI*2);
                       g.bullets.push({x: cx, y: cy, w:6, h:6, owner:'enemy', vx:Math.cos(angle)*5, vy:Math.sin(angle)*5, color:'#06b6d4'});
                       g.bullets.push({x: cx, y: cy, w:6, h:6, owner:'enemy', vx:Math.cos(angle+Math.PI)*5, vy:Math.sin(angle+Math.PI)*5, color:'#06b6d4'});
                  }
                  
                  boss.lastShot = now;
                  playSound('enemy_shoot');
              }
          };

          const update = useCallback(() => {
              const g = game.current;
              const now = Date.now();
              const p = g.player;

              g.stars.forEach(s => { s.y += s.speed; if (s.y > g.height) { s.y = 0; s.x = Math.random() * g.width; } });

              if (p.shieldActive) {
                  p.shieldTimer -= 16;
                  if (p.shieldTimer <= 0) { p.shieldActive = false; p.damageMultiplier = 1; }
              }

              if (g.gameState === 'playing' || g.gameState === 'boss') {
                  updateBoss(g);

                  // Player Bullets
                  g.bullets.forEach(b => {
                      if (b.behavior === 'homing') {
                          const target = getClosestEnemy(b.x, b.y);
                          if (target) {
                              const angle = Math.atan2((target.y + target.h/2) - b.y, (target.x + target.w/2) - b.x);
                              b.vx = b.vx * 0.95 + Math.cos(angle) * 1; b.vy = b.vy * 0.95 + Math.sin(angle) * 1;
                          }
                          b.x += b.vx * 8; b.y += b.vy * 8;
                      } else if (b.behavior === 'bounce') {
                          b.x += b.vx; b.y += b.vy; if (b.x <= 0 || b.x >= g.width) b.vx *= -1;
                      } else if (b.behavior === 'curve') {
                           b.vx += Math.sin(now / 100) * 0.5; b.x += b.vx; b.y += b.vy;
                      } else if (b.behavior === 'split') {
                          b.x += b.vx; b.y += b.vy; b.dist += Math.abs(b.vy);
                          if (b.dist > 200 && !b.split) {
                              b.hit = true; 
                              for(let i=-1; i<=1; i++) g.bullets.push({x: b.x, y: b.y, w: 6, h: 6, owner: 'player', vx: i*3, vy: -10, color: '#f0f', dmg: 1});
                          }
                      } else {
                          if (b.vx !== undefined) b.x += b.vx; if (b.vy !== undefined) b.y += b.vy;
                      }
                  });
                  g.bullets = g.bullets.filter(b => b.y > -100 && b.y < g.height + 50 && b.x > -50 && b.x < g.width + 50 && !b.hit);

                  // Update Enemies
                  g.enemies.forEach(e => {
                      e.tick += 0.05;
                      
                      // AI Movement
                      if (e.type === 'snake') {
                          e.trail.unshift({x: e.x, y: e.y});
                          if (e.trail.length > 5) e.trail.pop();
                          e.x += Math.sin(e.tick) * 3;
                          e.y += e.vy;
                      } else if (e.type === 'spider') {
                          e.x = e.baseX + Math.sin(e.tick * 2) * 40;
                          e.y += e.vy;
                      } else if (e.type === 'cube') {
                          // Gravity pull
                          const dx = (p.x + p.w/2) - (e.x + e.w/2);
                          const dy = (p.y + p.h/2) - (e.y + e.h/2);
                          const dist = Math.sqrt(dx*dx + dy*dy);
                          if (dist < 300) {
                              p.x -= dx * 0.005; // Pull player
                          }
                          e.y += e.vy;
                      } else if (e.type === 'kamikaze') {
                          if (e.y < p.y) e.vy += 0.1; // Accelerate down
                          const dx = p.x - e.x;
                          e.x += dx * 0.02; // Steer towards player
                          e.y += e.vy;
                      } else if (e.type === 'disc') {
                          e.x = e.baseX + Math.cos(e.tick) * 50;
                          e.y += e.vy;
                      } else if (e.type === 'hive') {
                          // Spawns minidrones
                          if (now - e.lastSpawn > 3000) {
                              g.enemies.push({ type: 'swarmer', x: e.x + e.w/2, y: e.y + e.h, w: 15, h: 15, health: 1, vx: (Math.random()-0.5)*4, vy: 3, points: 20 });
                              e.lastSpawn = now;
                          }
                          e.y += e.vy;
                      } else {
                          // Standard movement (Drone, Tower, Satellite, Specter)
                          e.y += e.vy;
                      }

                      // AI Shooting
                      if (now - e.lastShot > (e.type === 'tower' ? 50 : 1500)) {
                          if (e.type === 'drone') {
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 4, h: 10, owner: 'enemy', vx: 0, vy: 5, color: '#f00'});
                          } else if (e.type === 'snake') {
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 10, h: 10, owner: 'enemy', vx: 0, vy: 3, color: '#0ff'});
                          } else if (e.type === 'tower') {
                               // Continuous Laser
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 2, h: 15, owner: 'enemy', vx: 0, vy: 10, color: '#ff0'});
                          } else if (e.type === 'spider') {
                               // Exploding shot
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 8, h: 8, owner: 'enemy', vx: 0, vy: 4, color: '#0f0', behavior: 'split'});
                          } else if (e.type === 'satellite') {
                               // 8-way shot
                               for(let i=0; i<8; i++) {
                                   const a = (i/8)*Math.PI*2 + e.tick;
                                   g.bullets.push({x: e.x + e.w/2, y: e.y + e.h/2, w: 4, h: 4, owner: 'enemy', vx: Math.cos(a)*3, vy: Math.sin(a)*3, color: '#aaf'});
                               }
                          } else if (e.type === 'specter') {
                               // Plasma burst
                               for(let i=0; i<3; i++) {
                                   g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 6, h: 6, owner: 'enemy', vx: (Math.random()-0.5)*4, vy: 3, color: '#f0f'});
                               }
                          } else if (e.type === 'disc') {
                               // Circular pattern
                               const a = Math.sin(e.tick)*2;
                               g.bullets.push({x: e.x + e.w/2, y: e.y + e.h, w: 6, h: 6, owner: 'enemy', vx: Math.sin(a)*2, vy: 3, color: '#f0f'});
                          }
                          
                          if (e.type !== 'kamikaze') e.lastShot = now; // Kamikaze doesn't shoot
                      }
                  });
                  g.enemies = g.enemies.filter(e => e.y < g.height + 50 && e.health > 0);

                  // Powerups
                  g.powerups.forEach(p => p.y += p.vy);
                  g.powerups = g.powerups.filter(p => p.y < g.height && !p.collected);

                  // Collisions
                  g.bullets.forEach(b => {
                      if (b.owner === 'player') {
                          g.enemies.forEach(e => {
                              if (!b.hit && rectIntersect(b, e)) {
                                  if (b.behavior !== 'beam') b.hit = true;
                                  e.health -= (b.dmg || 1) * p.damageMultiplier;
                                  createExplosion(b.x, b.y, '#fb923c', 3);
                                  if(e.health <= 0) {
                                      g.score += e.points || 100;
                                      createExplosion(e.x + e.w/2, e.y + e.h/2, '#fdba74', 10);
                                      playSound('explosion');
                                      spawnPowerup(e.x, e.y);
                                      if (e.type === 'cube') {
                                           createExplosion(e.x+e.w/2, e.y+e.h/2, '#a855f7', 30);
                                           for(let i=0; i<6; i++) {
                                              const a = (i/6)*Math.PI*2;
                                              g.bullets.push({x: e.x+e.w/2, y: e.y+e.h/2, w:6, h:6, owner:'player', vx: Math.cos(a)*5, vy: Math.sin(a)*5, color: '#a855f7', dmg:5});
                                           }
                                      }
                                  }
                              }
                          });
                          if (g.boss && !b.hit && rectIntersect(b, g.boss)) {
                              if (b.behavior !== 'beam') b.hit = true;
                              g.boss.health -= (b.dmg || 1) * p.damageMultiplier;
                              createExplosion(b.x, b.y, '#f87171', 5);
                              if (g.boss.health <= 0) {
                                  playSound('explosion');
                                  g.score += 5000;
                                  g.gameState = 'level-up';
                                  g.boss = null;
                                  g.nextBossThreshold += 5000;
                                  setTimeout(() => { g.level++; g.gameState = 'playing'; }, 3000);
                              }
                          }
                      } else { 
                          if (!b.hit && rectIntersect(b, p)) {
                              b.hit = true;
                              if (!p.shieldActive) {
                                  p.health -= 10;
                                  playSound('hit');
                                  createExplosion(p.x, p.y, '#ef4444', 10);
                                  if (p.health <= 0) {
                                      g.gameState = 'game-over';
                                      playSound('explosion');
                                      setGameOver(true);
                                  }
                              }
                          }
                      }
                  });

                  // Kamikaze Collision
                  g.enemies.forEach(e => {
                      if (rectIntersect(e, p)) {
                          e.health = 0; // Enemy dies
                          createExplosion(e.x + e.w/2, e.y + e.h/2, '#f00', 20);
                          if (!p.shieldActive) {
                              p.health -= 20;
                              playSound('explosion');
                              if (p.health <= 0) { g.gameState = 'game-over'; setGameOver(true); }
                          }
                      }
                  });

                  g.powerups.forEach(p => {
                      if (!p.collected && rectIntersect(p, g.player)) {
                          p.collected = true;
                          playSound('powerup');
                          if (p.type === 'weapon') g.player.weaponLevel = Math.min(10, g.player.weaponLevel + 1);
                          else if (p.type === 'shield') { g.player.shieldActive = true; g.player.shieldTimer = 10000; g.player.damageMultiplier = 5; }
                      }
                  });

                  if (g.score >= g.nextBossThreshold && !g.boss && g.gameState === 'playing') spawnBoss();
              }

              g.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
              g.particles = g.particles.filter(p => p.life > 0);
              spawnEnemy();
          }, [spawnEnemy, spawnBoss, initGame]);

          const rectIntersect = (r1, r2) => !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x || r2.y > r1.y + r1.h || r2.y + r2.h < r1.y);
          const createExplosion = (x, y, color, count = 20) => { for (let i = 0; i < count; i++) game.current.particles.push({ x, y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: Math.random() * 20 + 10, color }); };

          const firePlayerWeapon = (g) => {
              const { x, y, w, weaponLevel, shieldActive } = g.player;
              const cx = x + w / 2;
              
              if (shieldActive) {
                  playSound('laser', 0.5); 
                  g.bullets.push({ x: cx - 6, y: y, w: 12, h: 50, owner: 'player', vy: -25, color: '#facc15', dmg: 5, behavior: 'beam', glow: true });
                  const numBullets = 20;
                  for (let i = 0; i < numBullets; i++) {
                     const angle = (i / numBullets) * Math.PI * 2;
                     g.bullets.push({ x: cx, y: y + 20, w: 6, h: 6, owner: 'player', vx: Math.cos(angle) * 12, vy: Math.sin(angle) * 12, color: '#ffff00', dmg: 3 });
                  }
                  return;
              }

              g.player.shootAngle += 0.2;
              playSound('shoot');

              switch(weaponLevel) {
                  case 1: g.bullets.push({ x: cx - 2, y, w: 4, h: 12, owner: 'player', vy: -12, color: '#67e8f9', dmg: 1 }); break;
                  case 2: g.bullets.push({ x: cx, y, w: 4, h: 12, owner: 'player', vy: -12, color: '#38bdf8', dmg: 1 }); g.bullets.push({ x: cx, y, w: 4, h: 12, owner: 'player', vx: -3, vy: -11, color: '#38bdf8', dmg: 1 }); g.bullets.push({ x: cx, y, w: 4, h: 12, owner: 'player', vx: 3, vy: -11, color: '#38bdf8', dmg: 1 }); break;
                  case 3: g.bullets.push({ x: cx - 10, y, w: 8, h: 8, owner: 'player', vx: -5, vy: -10, color: '#a3e635', dmg: 1.5, behavior: 'bounce' }); g.bullets.push({ x: cx + 10, y, w: 8, h: 8, owner: 'player', vx: 5, vy: -10, color: '#a3e635', dmg: 1.5, behavior: 'bounce' }); break;
                  case 4: g.bullets.push({ x: cx, y, w: 6, h: 15, owner: 'player', vx: 0, vy: -12, color: '#f472b6', dmg: 2, behavior: 'split', dist: 0 }); break;
                  case 5: const offset = Math.sin(g.player.shootAngle) * 10; g.bullets.push({ x: cx + offset, y, w: 6, h: 12, owner: 'player', vy: -15, color: '#c084fc', dmg: 2 }); g.bullets.push({ x: cx - offset, y, w: 6, h: 12, owner: 'player', vy: -15, color: '#c084fc', dmg: 2 }); break;
                  case 6: g.bullets.push({ x: cx - 15, y, w: 6, h: 10, owner: 'player', vx: -4, vy: -6, color: '#ef4444', dmg: 2, behavior: 'homing' }); g.bullets.push({ x: cx + 15, y, w: 6, h: 10, owner: 'player', vx: 4, vy: -6, color: '#ef4444', dmg: 2, behavior: 'homing' }); break;
                  case 7: for(let i=0; i<5; i++) g.bullets.push({ x: cx, y, w: 4, h: 4, owner: 'player', vx: (Math.random()-0.5)*10, vy: -10 - Math.random()*5, color: '#22d3ee', dmg: 1.5 }); break;
                  case 8: g.bullets.push({ x: cx - 20, y, w: 4, h: 20, owner: 'player', vx: 2, vy: -15, color: '#e879f9', dmg: 2.5, behavior: 'curve' }); g.bullets.push({ x: cx + 20, y, w: 4, h: 20, owner: 'player', vx: -2, vy: -15, color: '#e879f9', dmg: 2.5, behavior: 'curve' }); g.bullets.push({ x: cx, y, w: 6, h: 25, owner: 'player', vx: 0, vy: -18, color: '#e879f9', dmg: 3 }); break;
                  case 9: const burstCount = 16; for (let i = 0; i < burstCount; i++) { const angle = (i / burstCount) * Math.PI * 2; g.bullets.push({ x: cx, y: y, w: 5, h: 5, owner: 'player', vx: Math.cos(angle) * 10, vy: Math.sin(angle) * 10, color: '#fbbf24', dmg: 1.5 }); } break;
                  case 10: g.bullets.push({ x: cx - 8, y: y - 20, w: 16, h: 60, owner: 'player', vy: -25, color: '#ffffff', dmg: 5, behavior: 'beam', glow: true }); g.bullets.push({ x: cx - 15, y, w: 4, h: 15, owner: 'player', vx: -2, vy: -15, color: '#60a5fa', dmg: 2 }); g.bullets.push({ x: cx + 15, y, w: 4, h: 15, owner: 'player', vx: 2, vy: -15, color: '#60a5fa', dmg: 2 }); break;
                  default: g.bullets.push({ x: cx, y, w: 10, h: 40, owner: 'player', vy: -20, color: '#fff', dmg: 4 });
              }
          };

          const draw = useCallback(() => {
              const canvas = canvasRef.current;
              if (!canvas) return;
              const ctx = canvas.getContext('2d');
              const g = game.current;
              
              ctx.clearRect(0, 0, g.width, g.height);
              
              ctx.fillStyle = '#ffffff';
              g.stars.forEach(s => { ctx.globalAlpha = Math.random() * 0.5 + 0.3; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; });

              if (g.gameState !== 'game-over') {
                  const p = g.player;
                  if (p.shieldActive) {
                      const pulse = Math.sin(Date.now() / 100) * 5;
                      ctx.save(); ctx.shadowBlur = 30; ctx.shadowColor = '#8b5cf6'; ctx.strokeStyle = '#a78bfa'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y + p.h/2, p.w + 10 + pulse, 0, Math.PI * 2); ctx.stroke();
                      ctx.fillStyle = 'rgba(139, 92, 246, 0.3)'; ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y + p.h/2, p.w/2, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                  }

                  ctx.fillStyle = '#00ffff'; ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';
                  ctx.beginPath(); ctx.moveTo(p.x + p.w/2, p.y); ctx.lineTo(p.x + p.w, p.y + p.h); ctx.lineTo(p.x + p.w/2, p.y + p.h - 10); ctx.lineTo(p.x, p.y + p.h); ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0;
              }

              g.powerups.forEach(p => {
                  ctx.save(); ctx.shadowBlur = 10; ctx.shadowColor = p.type === 'weapon' ? '#22c55e' : '#facc15'; ctx.fillStyle = p.type === 'weapon' ? '#22c55e' : '#facc15'; ctx.beginPath(); ctx.arc(p.x + 10, p.y + 10, 10, 0, Math.PI*2); ctx.fill();
                  ctx.fillStyle = '#000'; ctx.font = 'bold 10px Arial'; ctx.fillText(p.type === 'weapon' ? 'UP' : 'SP', p.x + 4, p.y + 14); ctx.restore();
              });

              g.bullets.forEach(b => {
                  ctx.save();
                  ctx.shadowBlur = b.glow ? 20 : 5; ctx.shadowColor = b.color; ctx.fillStyle = b.color || '#fff';
                  if (b.behavior === 'homing') { ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x + b.w, b.y + b.h); ctx.lineTo(b.x - b.w, b.y + b.h); ctx.fill(); } 
                  else if (b.behavior === 'beam') { const grad = ctx.createLinearGradient(b.x, b.y, b.x + b.w, b.y); grad.addColorStop(0, 'rgba(255,255,255,0)'); grad.addColorStop(0.5, b.color); grad.addColorStop(1, 'rgba(255,255,255,0)'); ctx.fillStyle = grad; ctx.fillRect(b.x, b.y, b.w, b.h); } 
                  else { ctx.fillRect(b.x, b.y, b.w, b.h); }
                  ctx.restore();
              });

              g.enemies.forEach(e => {
                  ctx.save();
                  const cx = e.x + e.w/2; const cy = e.y + e.h/2;
                  
                  if (e.type === 'drone') {
                      ctx.shadowBlur = 10; ctx.shadowColor = '#f00'; ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx, e.y + e.h); ctx.lineTo(e.x, e.y); ctx.lineTo(e.x + e.w, e.y); ctx.closePath(); ctx.stroke(); ctx.fillStyle = 'rgba(255,0,0,0.3)'; ctx.fill();
                  } else if (e.type === 'snake') {
                      ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff'; if (e.trail) e.trail.forEach(t => { ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.arc(t.x + e.w/2, t.y + e.h/2, e.w/3, 0, Math.PI*2); ctx.fill(); }); ctx.globalAlpha = 1; ctx.beginPath(); ctx.arc(cx, cy, e.w/2, 0, Math.PI*2); ctx.fill();
                  } else if (e.type === 'tower') {
                      ctx.shadowBlur = 10; ctx.shadowColor = '#ff0'; ctx.strokeStyle = '#ff0'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(cx, cy, e.w/2, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(cx, cy, e.w/4, 0, Math.PI*2); ctx.fill(); ctx.save(); ctx.translate(cx, cy); ctx.rotate(e.tick); ctx.moveTo(-e.w/2, 0); ctx.lineTo(e.w/2, 0); ctx.moveTo(0, -e.h/2); ctx.lineTo(0, e.h/2); ctx.stroke(); ctx.restore();
                  } else if (e.type === 'spider') {
                      ctx.shadowBlur = 10; ctx.shadowColor = '#0f0'; ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(cx, cy, e.w/3, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx - 20, cy - 10); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + 20, cy - 10); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx - 20, cy + 20); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + 20, cy + 20); ctx.stroke();
                  } else if (e.type === 'satellite') {
                      ctx.shadowBlur = 10; ctx.shadowColor = '#aaf'; ctx.fillStyle = '#aaf'; ctx.save(); ctx.translate(cx, cy); ctx.rotate(e.tick); ctx.fillRect(-e.w/2, -5, e.w, 10); ctx.fillRect(-5, -e.h/2, 10, e.h); ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill(); ctx.restore();
                  } else if (e.type === 'cube') {
                      ctx.shadowBlur = 15; ctx.shadowColor = '#a855f7'; ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 3; ctx.strokeRect(e.x, e.y, e.w, e.h); ctx.fillStyle = 'rgba(168, 85, 247, 0.2)'; ctx.fillRect(e.x, e.y, e.w, e.h); ctx.fillStyle = '#fff'; ctx.fillRect(cx-2, cy-2, 4, 4);
                  } else if (e.type === 'specter') {
                      ctx.shadowBlur = 20; ctx.shadowColor = '#fff'; ctx.fillStyle = `rgba(200,200,255,${e.opacity})`; ctx.beginPath(); ctx.arc(cx, cy, e.w/2, Math.PI, 0); ctx.lineTo(e.x + e.w, e.y + e.h); ctx.lineTo(cx, e.y + e.h - 10); ctx.lineTo(e.x, e.y + e.h); ctx.closePath(); ctx.fill();
                  } else if (e.type === 'kamikaze') {
                      ctx.shadowBlur = 15; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.moveTo(cx, e.y + e.h); ctx.lineTo(e.x, e.y); ctx.lineTo(e.x + e.w, e.y); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#fb923c'; ctx.beginPath(); ctx.moveTo(cx, e.y); ctx.lineTo(cx-5, e.y-10); ctx.lineTo(cx+5, e.y-10); ctx.fill();
                  } else if (e.type === 'disc') {
                      ctx.shadowBlur = 10; ctx.shadowColor = '#f0f'; ctx.fillStyle = '#222'; ctx.beginPath(); ctx.ellipse(cx, cy, e.w/2, e.h/2, 0, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#f0f'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(cx, cy-5, 5, 0, Math.PI*2); ctx.fill();
                  } else if (e.type === 'hive') {
                      ctx.shadowBlur = 15; ctx.shadowColor = '#f97316'; ctx.strokeStyle = '#f97316'; ctx.lineWidth = 3; ctx.beginPath(); const r = e.w/2; for(let i=0; i<6; i++) { const a = i * Math.PI / 3; const x = cx + Math.cos(a)*r; const y = cy + Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); ctx.stroke(); ctx.fillStyle = '#fb923c'; ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.fill();
                  } else {
                      ctx.fillStyle = '#fff'; ctx.fillRect(e.x, e.y, e.w, e.h);
                  }
                  ctx.fillStyle = 'red'; ctx.fillRect(e.x, e.y - 6, e.w, 2); ctx.fillStyle = 'lime'; ctx.fillRect(e.x, e.y - 6, e.w * (e.health/e.maxHealth), 2);
                  ctx.restore();
              });

              if (g.boss) {
                  const boss = g.boss;
                  const cx = boss.x + boss.w/2;
                  const cy = boss.y + boss.h/2;
                  ctx.save(); 
                  
                  if (boss.type === 'pyramid') {
                      // 1. Pyramid Titan (Gold)
                      ctx.shadowBlur = 20; ctx.shadowColor = '#eab308'; ctx.fillStyle = '#eab308';
                      ctx.beginPath(); ctx.moveTo(cx, boss.y); ctx.lineTo(boss.x + boss.w, boss.y + boss.h); ctx.lineTo(boss.x, boss.y + boss.h); ctx.closePath(); ctx.fill();
                      ctx.strokeStyle = '#fef08a'; ctx.lineWidth = 2; ctx.stroke();
                      // Eye
                      ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(cx, cy + 20, 15, 0, Math.PI*2); ctx.fill();
                  } 
                  else if (boss.type === 'hydra') {
                      // 2. Mecha Hydra (3 Heads)
                      ctx.strokeStyle = '#4ade80'; ctx.lineWidth = 8; ctx.lineCap = 'round';
                      // Necks
                      ctx.beginPath(); ctx.moveTo(cx, boss.y+boss.h); ctx.quadraticCurveTo(cx-30, cy, boss.x + 20, boss.y+boss.h); ctx.stroke();
                      ctx.beginPath(); ctx.moveTo(cx, boss.y+boss.h); ctx.lineTo(cx, cy); ctx.stroke();
                      ctx.beginPath(); ctx.moveTo(cx, boss.y+boss.h); ctx.quadraticCurveTo(cx+30, cy, boss.x + boss.w - 20, boss.y+boss.h); ctx.stroke();
                      // Heads
                      const heads = [[boss.x + 20, '#60a5fa'], [cx, '#34d399'], [boss.x + boss.w - 20, '#f87171']];
                      heads.forEach(h => {
                          ctx.shadowBlur = 15; ctx.shadowColor = h[1]; ctx.fillStyle = h[1]; 
                          ctx.beginPath(); ctx.arc(h[0], boss.y + boss.h, 15, 0, Math.PI*2); ctx.fill();
                      });
                  }
                  else if (boss.type === 'orb') {
                      // 3. Void Orb (Blue/Black)
                      ctx.shadowBlur = 30; ctx.shadowColor = '#3b82f6'; ctx.fillStyle = '#000';
                      ctx.beginPath(); ctx.arc(cx, cy, 50, 0, Math.PI*2); ctx.fill();
                      ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.stroke();
                      // Rings
                      ctx.save(); ctx.translate(cx, cy); ctx.rotate(boss.tick); 
                      ctx.strokeStyle = '#93c5fd'; ctx.lineWidth = 4;
                      ctx.beginPath(); ctx.ellipse(0, 0, 70, 20, 0, 0, Math.PI*2); ctx.stroke();
                      ctx.beginPath(); ctx.ellipse(0, 0, 70, 20, Math.PI/2, 0, Math.PI*2); ctx.stroke();
                      ctx.restore();
                  }
                  else if (boss.type === 'dragon') {
                      // 4. CosmoTec Dragon (Red/Metallic)
                      ctx.shadowBlur = 15; ctx.shadowColor = '#ef4444';
                      for(let i=0; i<5; i++) {
                          const size = 20 - i*2;
                          ctx.fillStyle = i===0 ? '#fecaca' : '#ef4444';
                          ctx.beginPath(); ctx.arc(cx, boss.y + 20 + i*30, size, 0, Math.PI*2); ctx.fill();
                      }
                      // Wings
                      ctx.fillStyle = '#b91c1c'; 
                      ctx.beginPath(); ctx.moveTo(cx, boss.y+40); ctx.lineTo(boss.x-20, boss.y+60); ctx.lineTo(boss.x, boss.y+80); ctx.fill();
                      ctx.beginPath(); ctx.moveTo(cx, boss.y+40); ctx.lineTo(boss.x+boss.w+20, boss.y+60); ctx.lineTo(boss.x+boss.w, boss.y+80); ctx.fill();
                  }
                  else if (boss.type === 'spider') {
                      // 5. Spider Colossus (Purple/Green)
                      ctx.shadowBlur = 10; ctx.shadowColor = '#a855f7';
                      // Legs
                      ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 3;
                      for(let i=0; i<4; i++) {
                          ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(boss.x - 20, boss.y + i*30); ctx.stroke();
                          ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(boss.x + boss.w + 20, boss.y + i*30); ctx.stroke();
                      }
                      ctx.fillStyle = '#581c87'; ctx.beginPath(); ctx.arc(cx, cy, 40, 0, Math.PI*2); ctx.fill();
                      // Eyes
                      ctx.fillStyle = '#4ade80'; ctx.beginPath(); ctx.arc(cx-10, cy+10, 5, 0, Math.PI*2); ctx.arc(cx+10, cy+10, 5, 0, Math.PI*2); ctx.fill();
                  }
                  else if (boss.type === 'cube') {
                      // 6. Quantum Cube (Neon lines)
                      ctx.shadowBlur = 20; ctx.shadowColor = '#d8b4fe'; ctx.strokeStyle = '#d8b4fe'; ctx.lineWidth = 4;
                      ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
                      ctx.strokeRect(boss.x, boss.y, boss.w, boss.h);
                      // Inner lines
                      ctx.beginPath(); ctx.moveTo(boss.x, boss.y); ctx.lineTo(boss.x+boss.w, boss.y+boss.h); ctx.stroke();
                      ctx.beginPath(); ctx.moveTo(boss.x+boss.w, boss.y); ctx.lineTo(boss.x, boss.y+boss.h); ctx.stroke();
                      ctx.strokeRect(boss.x + 20, boss.y + 20, boss.w - 40, boss.h - 40);
                  }
                  else if (boss.type === 'parasite') {
                      // 7. Star Parasite (Organic Pink)
                      ctx.shadowBlur = 15; ctx.shadowColor = '#f472b6'; ctx.fillStyle = '#be185d';
                      ctx.beginPath(); ctx.arc(cx, cy, 40 + Math.sin(boss.tick)*5, 0, Math.PI*2); ctx.fill();
                      // Tentacles
                      ctx.strokeStyle = '#fbcfe8'; ctx.lineWidth = 4;
                      for(let i=0; i<6; i++) {
                           const angle = (i/6)*Math.PI*2 + boss.tick;
                           ctx.beginPath(); ctx.moveTo(cx, cy); 
                           ctx.quadraticCurveTo(cx + Math.cos(angle)*60, cy + Math.sin(angle)*60, cx + Math.cos(angle)*80, cy + Math.sin(angle)*80);
                           ctx.stroke();
                      }
                  }
                  else if (boss.type === 'star') {
                      // 8. Mecha Star (5 Points)
                      ctx.shadowBlur = 25; ctx.shadowColor = '#fbbf24'; ctx.fillStyle = '#fbbf24';
                      ctx.save(); ctx.translate(cx, cy); ctx.rotate(boss.tick * 0.5);
                      ctx.beginPath();
                      for (let i = 0; i < 5; i++) {
                          ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * 60, -Math.sin((18 + i * 72) / 180 * Math.PI) * 60);
                          ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * 25, -Math.sin((54 + i * 72) / 180 * Math.PI) * 25);
                      }
                      ctx.closePath(); ctx.fill(); ctx.restore();
                  }
                  else if (boss.type === 'tank') {
                      // 9. Space Tank (Blocky Grey)
                      ctx.shadowBlur = 10; ctx.shadowColor = '#9ca3af'; ctx.fillStyle = '#374151';
                      ctx.fillRect(boss.x, boss.y, boss.w, boss.h); // Body
                      ctx.fillStyle = '#1f2937'; ctx.fillRect(boss.x-10, boss.y, 20, boss.h); ctx.fillRect(boss.x+boss.w-10, boss.y, 20, boss.h); // Tracks
                      ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(cx, boss.y+boss.h/2, 20, 0, Math.PI*2); ctx.fill(); // Core
                      ctx.fillStyle = '#6b7280'; ctx.fillRect(cx-10, boss.y+boss.h/2, 20, 40); // Barrel
                  }
                  else if (boss.type === 'clock') {
                      // 10. Apocalypse Clock (Bronze)
                      ctx.shadowBlur = 15; ctx.shadowColor = '#06b6d4'; ctx.fillStyle = '#1e293b';
                      ctx.beginPath(); ctx.arc(cx, cy, 60, 0, Math.PI*2); ctx.fill();
                      ctx.strokeStyle = '#06b6d4'; ctx.lineWidth = 3; ctx.stroke();
                      // Hands
                      ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
                      ctx.save(); ctx.translate(cx, cy);
                      ctx.beginPath(); ctx.moveTo(0,0); ctx.rotate(boss.tick); ctx.lineTo(0, -40); ctx.stroke(); ctx.restore(); // Minute
                      ctx.save(); ctx.translate(cx, cy);
                      ctx.beginPath(); ctx.moveTo(0,0); ctx.rotate(boss.tick * 0.1); ctx.lineTo(0, -25); ctx.stroke(); ctx.restore(); // Hour
                  }
                  else {
                      // Fallback
                      ctx.fillStyle = '#ff0055'; ctx.beginPath(); ctx.moveTo(boss.x, boss.y); ctx.lineTo(boss.x + boss.w, boss.y); ctx.lineTo(boss.x + boss.w/2, boss.y + boss.h); ctx.closePath(); ctx.fill();
                  }

                  ctx.restore();
                  
                  // HP Bar
                  ctx.fillStyle = '#330033'; ctx.fillRect(10, 50, g.width - 20, 10); ctx.fillStyle = '#ff00ff'; ctx.fillRect(10, 50, (g.width - 20) * (boss.health / boss.maxHealth), 10);
              }

              g.particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 20; ctx.fillRect(p.x, p.y, 3, 3); ctx.globalAlpha = 1; });

              ctx.fillStyle = 'white'; ctx.font = 'bold 16px "Courier New"'; ctx.fillText(`SCORE: ${g.score}`, 10, 25);
              ctx.textAlign = 'right'; ctx.fillText(`LVL: ${g.level} | WPN: ${g.player.weaponLevel}`, g.width - 10, 25); ctx.textAlign = 'left';

              const hpPercent = Math.max(0, g.player.health / g.player.maxHealth);
              ctx.fillStyle = '#333'; ctx.fillRect(10, g.height - 30, 150, 15);
              ctx.fillStyle = hpPercent > 0.5 ? '#22c55e' : (hpPercent > 0.2 ? '#eab308' : '#ef4444');
              ctx.fillRect(10, g.height - 30, 150 * hpPercent, 15);
              ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(10, g.height - 30, 150, 15);

              if (g.player.shieldActive) {
                  ctx.fillStyle = '#facc15'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.shadowBlur = 10; ctx.shadowColor = '#facc15';
                  ctx.fillText(`SPECIAL ACTIVE: CHAOS BLOSSOM (${Math.ceil(g.player.shieldTimer/1000)}s)`, g.width/2, g.height - 18); ctx.shadowBlur = 0; ctx.textAlign = 'left';
              }

              if (g.gameState === 'game-over') {
                  ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0,0,g.width,g.height);
                  ctx.fillStyle = '#ff0055'; ctx.font = 'bold 40px "Courier New"'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', g.width/2, g.height/2 - 20);
                  ctx.fillStyle = 'white'; ctx.font = '20px "Courier New"'; ctx.fillText('Tap to Restart', g.width/2, g.height/2 + 30);
              }
          }, []);

          useEffect(() => {
              initGame();
              const canvas = canvasRef.current;
              const g = game.current;
              const resizeCanvas = () => { if(canvas && canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; g.width = canvas.width; g.height = canvas.height; } };
              resizeCanvas(); window.addEventListener('resize', resizeCanvas);
              let animationFrameId; const gameLoop = () => { update(); draw(); animationFrameId = window.requestAnimationFrame(gameLoop); }; gameLoop();
              const handleMove = (e) => {
                  if (g.gameState !== 'playing' && g.gameState !== 'boss') return;
                  if(e.cancelable) e.preventDefault();
                  const rect = canvas.getBoundingClientRect();
                  const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                  const x = clientX - rect.left; const y = clientY - rect.top;
                  g.player.x = Math.max(0, Math.min(g.width - g.player.w, x - g.player.w / 2)); g.player.y = Math.max(0, Math.min(g.height - g.player.h, y - g.player.h / 2));
                  const now = Date.now(); const fireRate = g.player.weaponLevel >= 8 ? 100 : 150;
                  if (now - g.player.lastShot > fireRate) { firePlayerWeapon(g); g.player.lastShot = now; }
              };
              const handleClick = () => { if (g.gameState === 'game-over') { triggerAd(); initGame(); } };
              canvas.addEventListener('mousemove', handleMove); canvas.addEventListener('touchmove', handleMove, { passive: false }); canvas.addEventListener('click', handleClick);
              return () => { window.cancelAnimationFrame(animationFrameId); window.removeEventListener('resize', resizeCanvas); canvas.removeEventListener('mousemove', handleMove); canvas.removeEventListener('touchmove', handleMove); canvas.removeEventListener('click', handleClick); };
          }, [draw, update, initGame, triggerAd]);

          return (
              <div className="w-full h-full relative flex flex-col items-center justify-center bg-transparent">
                  <canvas ref={canvasRef} className="w-full h-full block" />
                  <div className="absolute top-4 left-4 z-10"><button onClick={onBack} className="p-3 bg-white/20 backdrop-blur-md rounded-full text-white hover:bg-white/30 transition border border-white/20"><ChevronLeft size={24} /></button></div>
              </div>
          );
      };

      // --- Main App ---
      const App = () => {
          const [currentScreen, setCurrentScreen] = useState('home');
          const [lastAdTime, setLastAdTime] = useState(0);
          const triggerAd = useCallback(() => { const now = Date.now(); if (now - lastAdTime > 120000) { setLastAdTime(now); } }, [lastAdTime]);
          const startGame = (gameName) => { triggerAd(); setCurrentScreen(gameName); };
          const renderScreen = () => {
              switch(currentScreen) {
                  case 'galaxy-invader': return <GalaxyInvader onBack={() => setCurrentScreen('home')} triggerAd={triggerAd} />;
                  case 'neon-racer': return <NeonRacer onBack={() => setCurrentScreen('home')} triggerAd={triggerAd} />;
                  case 'lingua-quest': return <LinguaQuest onBack={() => setCurrentScreen('home')} triggerAd={triggerAd} />;
                  default: return (
                          <div className="w-full h-full flex flex-col items-center justify-center relative overflow-hidden">
                              <div className="z-10 flex flex-col items-center gap-8 w-full max-w-md px-4">
                                  <h1 className="text-5xl md:text-6xl font-bold text-center neon-title tracking-wider">JoGos<br/>Online</h1>
                                  <div className="w-full grid gap-4 mt-8">
                                      <button onClick={() => startGame('galaxy-invader')} className="glass-box group relative w-full h-24 rounded-xl overflow-hidden">
                                          <div className="relative z-10 flex items-center justify-between p-6 h-full text-white">
                                              <div className="flex flex-col items-start"><span className="text-xl font-bold text-white drop-shadow-md neon-text-small">GALAXY INVADER</span><span className="text-xs text-gray-400">Space Shooter</span></div>
                                              <Rocket size={32} className="text-purple-400" />
                                          </div>
                                      </button>
                                      <button onClick={() => startGame('neon-racer')} className="glass-box group relative w-full h-24 rounded-xl overflow-hidden">
                                          <div className="relative z-10 flex items-center justify-between p-6 h-full text-white">
                                              <div className="flex flex-col items-start"><span className="text-xl font-bold text-white drop-shadow-md neon-text-small">NEON RACER</span><span className="text-xs text-gray-400">High Speed Racing</span></div>
                                              <Car size={32} className="text-pink-400" />
                                          </div>
                                      </button>
                                      <button onClick={() => startGame('lingua-quest')} className="glass-box group relative w-full h-24 rounded-xl overflow-hidden">
                                          <div className="relative z-10 flex items-center justify-between p-6 h-full text-white">
                                              <div className="flex flex-col items-start"><span className="text-xl font-bold text-white drop-shadow-md neon-text-small">LINGUA QUEST</span><span className="text-xs text-gray-400">Learn English</span></div>
                                              <Languages size={32} className="text-green-400" />
                                          </div>
                                      </button>
                                  </div>
                              </div>
                              <div className="absolute bottom-4 text-gray-700 text-xs">v4.1.4</div>
                          </div>
                      );
              }
          };
          return renderScreen();
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>